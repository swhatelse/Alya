---
:header:
  :title: Experiment information
  :time: 2016-12-14 16:17:46.444131551 Z
  :machine: ! 'titan

'
:body:
  :environment:
    :hardware:
      :cpu: ! "processor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t:
        37\nmodel name\t: Intel(R) Core(TM) i5 CPU       M 520  @ 2.40GHz\nstepping\t:
        5\nmicrocode\t: 0x2\ncpu MHz\t\t: 2400.000\ncache size\t: 3072 KB\nphysical
        id\t: 0\nsiblings\t: 4\ncore id\t\t: 0\ncpu cores\t: 2\napicid\t\t: 0\ninitial
        apicid\t: 0\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 11\nwp\t\t:
        yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov
        pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx rdtscp
        lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc
        aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16
        xtpr pdcm pcid sse4_1 sse4_2 popcnt aes lahf_lm ida arat dtherm tpr_shadow
        vnmi flexpriority ept vpid\nbogomips\t: 4787.99\nclflush size\t: 64\ncache_alignment\t:
        64\naddress sizes\t: 36 bits physical, 48 bits virtual\npower management:\n\nprocessor\t:
        1\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 37\nmodel name\t:
        Intel(R) Core(TM) i5 CPU       M 520  @ 2.40GHz\nstepping\t: 5\nmicrocode\t:
        0x2\ncpu MHz\t\t: 2400.000\ncache size\t: 3072 KB\nphysical id\t: 0\nsiblings\t:
        4\ncore id\t\t: 0\ncpu cores\t: 2\napicid\t\t: 1\ninitial apicid\t: 1\nfpu\t\t:
        yes\nfpu_exception\t: yes\ncpuid level\t: 11\nwp\t\t: yes\nflags\t\t: fpu
        vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush
        dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx rdtscp lm constant_tsc
        arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq
        dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid sse4_1 sse4_2
        popcnt aes lahf_lm ida arat dtherm tpr_shadow vnmi flexpriority ept vpid\nbogomips\t:
        4787.99\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 36 bits
        physical, 48 bits virtual\npower management:\n\nprocessor\t: 2\nvendor_id\t:
        GenuineIntel\ncpu family\t: 6\nmodel\t\t: 37\nmodel name\t: Intel(R) Core(TM)
        i5 CPU       M 520  @ 2.40GHz\nstepping\t: 5\nmicrocode\t: 0x2\ncpu MHz\t\t:
        2400.000\ncache size\t: 3072 KB\nphysical id\t: 0\nsiblings\t: 4\ncore id\t\t:
        2\ncpu cores\t: 2\napicid\t\t: 4\ninitial apicid\t: 4\nfpu\t\t: yes\nfpu_exception\t:
        yes\ncpuid level\t: 11\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae
        mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse
        sse2 ss ht tm pbe syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts
        rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor
        ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid sse4_1 sse4_2 popcnt aes
        lahf_lm ida arat dtherm tpr_shadow vnmi flexpriority ept vpid\nbogomips\t:
        4787.99\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 36 bits
        physical, 48 bits virtual\npower management:\n\nprocessor\t: 3\nvendor_id\t:
        GenuineIntel\ncpu family\t: 6\nmodel\t\t: 37\nmodel name\t: Intel(R) Core(TM)
        i5 CPU       M 520  @ 2.40GHz\nstepping\t: 5\nmicrocode\t: 0x2\ncpu MHz\t\t:
        2400.000\ncache size\t: 3072 KB\nphysical id\t: 0\nsiblings\t: 4\ncore id\t\t:
        2\ncpu cores\t: 2\napicid\t\t: 5\ninitial apicid\t: 5\nfpu\t\t: yes\nfpu_exception\t:
        yes\ncpuid level\t: 11\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae
        mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse
        sse2 ss ht tm pbe syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts
        rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor
        ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid sse4_1 sse4_2 popcnt aes
        lahf_lm ida arat dtherm tpr_shadow vnmi flexpriority ept vpid\nbogomips\t:
        4787.99\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 36 bits
        physical, 48 bits virtual\npower management:\n\n"
      :cpu_frequency: '2400000

'
      :gpu: ! "  *-display\n       description: VGA compatible controller\n       product:
        Core Processor Integrated Graphics Controller [8086:46]\n       vendor: Intel
        Corporation [8086]\n       physical id: 2\n       bus info: pci@0000:00:02.0\n
        \      version: 02\n       width: 64 bits\n       clock: 33MHz\n       capabilities:
        vga_controller bus_master cap_list rom\n       configuration: driver=i915
        latency=0\n       resources: irq:42 memory:f2000000-f23fffff memory:d0000000-dfffffff
        ioport:1800(size=8)\n"
    :software:
      :linux: ! 'Linux version 3.13.0-37-generic (buildd@kapok) (gcc version 4.8.2
        (Ubuntu 4.8.2-19ubuntu1) ) #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014

'
      :environment_variables: ! 'XDG_VTNR=8

        LC_PAPER=en_US.UTF-8

        MANPATH=:/home/stemen/Programmes/lustre-v4-III-c-linux64/man:/home/stemen/Programmes/lustre-v4-III-c-linux64/esterelv5_21.linux/man

        XDG_SESSION_ID=c1

        SSH_AGENT_PID=2742

        LC_ADDRESS=en_US.UTF-8

        LC_MONETARY=en_US.UTF-8

        CLUTTER_IM_MODULE=xim

        CUPS_USER=squinito

        GPG_AGENT_INFO=/run/user/1000/keyring-i0ZMIx/gpg:0:1

        TERM=xterm

        VTE_VERSION=3409

        SHELL=/bin/bash

        XDG_SESSION_COOKIE=45a9bb796cbd4fa9de8dbf4d5505312a-1481702497.510088-56734958

        GJS_DEBUG_OUTPUT=stderr

        ESTEREL=/home/stemen/Programmes/lustre-v4-III-c-linux64/esterelv5_21.linux

        WINDOWID=46156436

        LC_NUMERIC=en_US.UTF-8

        GNOME_KEYRING_CONTROL=/run/user/1000/keyring-i0ZMIx

        GJS_DEBUG_TOPICS=JS ERROR;JS LOG

        USER=stemen

        LC_TELEPHONE=en_US.UTF-8

        LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:

        LD_LIBRARY_PATH=:/home/stemen/Programmes/lustre-v4-III-c-linux64/esterelv5_21.linux/lib

        SSH_AUTH_SOCK=/run/user/1000/keyring-i0ZMIx/ssh

        SESSION_MANAGER=local/titan:@/tmp/.ICE-unix/2668,unix/titan:/tmp/.ICE-unix/2668

        DEFAULTS_PATH=/usr/share/gconf/default.default.path

        USERNAME=stemen

        XDG_CONFIG_DIRS=/etc/xdg/xdg-default:/etc/xdg

        DESKTOP_SESSION=default

        PATH=/home/stemen/Programmes/lustre-v4-III-c-linux64/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/stemen/Programmes/lustre-v4-III-c-linux64/esterelv5_21.linux/bin

        LUSTRE_INSTALL=/home/stemen/Programmes/lustre-v4-III-c-linux64

        GDM_XSERVER_LOCATION=local

        LC_IDENTIFICATION=en_US.UTF-8

        PWD=/home/stemen/Dev/LIG/Alya/src/scripts

        XMODIFIERS=@im=none

        LANG=en_US.UTF-8

        GNOME_KEYRING_PID=2591

        MANDATORY_PATH=/usr/share/gconf/default.mandatory.path

        LC_MEASUREMENT=en_US.UTF-8

        PAPERSIZE=a4

        GDMSESSION=default

        MDM_XSERVER_LOCATION=local

        CINNAMON_VERSION=2.4.8

        HOME=/home/stemen

        XDG_SEAT=seat0

        SHLVL=2

        GNOME_DESKTOP_SESSION_ID=this-is-deprecated

        LOGNAME=stemen

        XDG_SESSION_DESKTOP=default

        DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-mPwfTUtqZB,guid=d0d87cac5945f8d95e2aea785850fc61

        QT4_IM_MODULE=xim

        XDG_DATA_DIRS=/usr/share/default:/usr/share/gnome:/usr/local/share/:/usr/share/:/usr/share/mdm/

        MDMSESSION=default

        TEXTDOMAIN=im-config

        WINDOWPATH=8

        DISPLAY=:0

        XDG_RUNTIME_DIR=/run/user/1000

        MDM_LANG=en_US.UTF-8

        GTK_IM_MODULE=xim

        XDG_CURRENT_DESKTOP=X-Cinnamon

        LC_TIME=en_US.UTF-8

        TEXTDOMAINDIR=/usr/share/locale/

        LC_NAME=en_US.UTF-8

        XAUTHORITY=/home/stemen/.Xauthority

        COLORTERM=gnome-terminal

        _=/usr/bin/ruby

'
      :cpu_governor: ! 'performance

'
      :running_softwares: ! 'F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME
        CMD

        4 S     0     1     0  0  80   0 -  8476 poll_s ?        00:00:02 init

        1 S     0     2     0  0  80   0 -     0 kthrea ?        00:00:00 kthreadd

        1 S     0     3     2  0  80   0 -     0 smpboo ?        00:00:00 ksoftirqd/0

        1 S     0     4     2  0  80   0 -     0 worker ?        00:00:00 kworker/0:0

        1 S     0     5     2  0  60 -20 -     0 worker ?        00:00:00 kworker/0:0H

        1 S     0     7     2  0  80   0 -     0 rcu_gp ?        00:00:10 rcu_sched

        1 S     0     8     2  0  80   0 -     0 rcu_no ?        00:00:11 rcuos/0

        1 S     0     9     2  0  80   0 -     0 rcu_no ?        00:00:13 rcuos/1

        1 S     0    10     2  0  80   0 -     0 rcu_no ?        00:00:11 rcuos/2

        1 S     0    11     2  0  80   0 -     0 rcu_no ?        00:00:07 rcuos/3

        1 S     0    12     2  0  80   0 -     0 rcu_gp ?        00:00:00 rcu_bh

        1 S     0    13     2  0  80   0 -     0 rcu_no ?        00:00:00 rcuob/0

        1 S     0    14     2  0  80   0 -     0 rcu_no ?        00:00:00 rcuob/1

        1 S     0    15     2  0  80   0 -     0 rcu_no ?        00:00:00 rcuob/2

        1 S     0    16     2  0  80   0 -     0 rcu_no ?        00:00:00 rcuob/3

        1 S     0    17     2  0 -40   - -     0 smpboo ?        00:00:00 migration/0

        5 S     0    18     2  0 -40   - -     0 smpboo ?        00:00:00 watchdog/0

        5 S     0    19     2  0 -40   - -     0 smpboo ?        00:00:00 watchdog/1

        1 S     0    20     2  0 -40   - -     0 smpboo ?        00:00:00 migration/1

        1 S     0    21     2  0  80   0 -     0 smpboo ?        00:00:00 ksoftirqd/1

        1 S     0    23     2  0  60 -20 -     0 worker ?        00:00:00 kworker/1:0H

        5 S     0    24     2  0 -40   - -     0 smpboo ?        00:00:00 watchdog/2

        1 S     0    25     2  0 -40   - -     0 smpboo ?        00:00:00 migration/2

        1 S     0    26     2  0  80   0 -     0 smpboo ?        00:00:00 ksoftirqd/2

        1 S     0    28     2  0  60 -20 -     0 worker ?        00:00:00 kworker/2:0H

        5 S     0    29     2  0 -40   - -     0 smpboo ?        00:00:00 watchdog/3

        1 S     0    30     2  0 -40   - -     0 smpboo ?        00:00:00 migration/3

        1 S     0    31     2  0  80   0 -     0 smpboo ?        00:00:00 ksoftirqd/3

        1 S     0    32     2  0  80   0 -     0 worker ?        00:00:01 kworker/3:0

        1 S     0    33     2  0  60 -20 -     0 worker ?        00:00:00 kworker/3:0H

        1 S     0    34     2  0  60 -20 -     0 rescue ?        00:00:00 khelper

        5 S     0    35     2  0  80   0 -     0 devtmp ?        00:00:00 kdevtmpfs

        1 S     0    36     2  0  60 -20 -     0 rescue ?        00:00:00 netns

        1 S     0    37     2  0  60 -20 -     0 rescue ?        00:00:00 writeback

        1 S     0    38     2  0  60 -20 -     0 rescue ?        00:00:00 kintegrityd

        1 S     0    39     2  0  60 -20 -     0 rescue ?        00:00:00 bioset

        1 S     0    40     2  0  60 -20 -     0 worker ?        00:00:00 kworker/u9:0

        1 S     0    41     2  0  60 -20 -     0 rescue ?        00:00:00 kblockd

        1 S     0    42     2  0  60 -20 -     0 rescue ?        00:00:00 ata_sff

        1 S     0    43     2  0  80   0 -     0 hub_th ?        00:00:00 khubd

        1 S     0    44     2  0  60 -20 -     0 rescue ?        00:00:00 md

        1 S     0    45     2  0  60 -20 -     0 rescue ?        00:00:00 devfreq_wq

        1 S     0    46     2  0  80   0 -     0 worker ?        00:00:07 kworker/2:1

        1 S     0    48     2  0  80   0 -     0 watchd ?        00:00:00 khungtaskd

        1 S     0    49     2  0  80   0 -     0 kswapd ?        00:00:01 kswapd0

        1 S     0    50     2  0  85   5 -     0 ksm_sc ?        00:00:00 ksmd

        1 S     0    51     2  0  99  19 -     0 khugep ?        00:00:00 khugepaged

        1 S     0    52     2  0  80   0 -     0 fsnoti ?        00:00:00 fsnotify_mark

        1 S     0    53     2  0  80   0 -     0 ecrypt ?        00:00:00 ecryptfs-kthrea

        1 S     0    54     2  0  60 -20 -     0 rescue ?        00:00:00 crypto

        1 S     0    66     2  0  60 -20 -     0 rescue ?        00:00:00 kthrotld

        1 S     0    86     2  0  60 -20 -     0 rescue ?        00:00:00 deferwq

        1 S     0    87     2  0  60 -20 -     0 rescue ?        00:00:00 charger_manager

        1 S     0    97     2  0  80   0 -     0 worker ?        00:00:00 kworker/1:1

        1 S     0   137     2  0  60 -20 -     0 rescue ?        00:00:00 firewire

        1 S     0   138     2  0  60 -20 -     0 rescue ?        00:00:00 firewire_ohci

        1 S     0   139     2  0  60 -20 -     0 rescue ?        00:00:00 kpsmoused

        1 S     0   166     2  0  80   0 -     0 scsi_e ?        00:00:00 scsi_eh_0

        1 S     0   167     2  0  80   0 -     0 scsi_e ?        00:00:00 scsi_eh_1

        1 S     0   168     2  0  80   0 -     0 scsi_e ?        00:00:00 scsi_eh_2

        1 S     0   169     2  0  80   0 -     0 scsi_e ?        00:00:00 scsi_eh_3

        1 S     0   170     2  0  80   0 -     0 scsi_e ?        00:00:00 scsi_eh_4

        1 S     0   171     2  0  80   0 -     0 scsi_e ?        00:00:00 scsi_eh_5

        1 S     0   253     2  0  80   0 -     0 kjourn ?        00:00:00 jbd2/sda2-8

        1 S     0   254     2  0  60 -20 -     0 rescue ?        00:00:00 ext4-rsv-conver

        1 S     0   420     1  0  80   0 -  4868 poll_s ?        00:00:00 upstart-udev-br

        5 S     0   427     1  0  80   0 - 12993 ep_pol ?        00:00:00 systemd-udevd

        1 S     0   479     2  0   9   - -     0 irq_th ?        00:00:00 irq/43-mei_me

        1 S     0   506     2  0  60 -20 -     0 rescue ?        00:00:00 cfg80211

        1 S     0   515     2  0  60 -20 -     0 worker ?        00:00:00 kworker/u9:1

        1 S     0   518     2  0   9   - -     0 irq_th ?        00:00:28 irq/44-iwlwifi

        1 S     0   524     2  0  60 -20 -     0 rescue ?        00:00:00 hd-audio0

        1 S     0   646     2  0  60 -20 -     0 rescue ?        00:00:00 ktpacpid

        1 S     0   684     2  0  80   0 -     0 ips_ad ?        00:00:00 ips-adjust

        1 S     0   687     2  0  60 -20 -     0 rescue ?        00:00:00 kmpathd

        1 S     0   688     2  0  80   0 -     0 ips_mo ?        00:00:02 ips-monitor

        1 S     0   689     2  0  60 -20 -     0 rescue ?        00:00:00 kmpath_handlerd

        1 S     0   809     2  0  60 -20 -     0 rescue ?        00:00:00 kvm-irqfd-clean

        1 S     0   987     1  0  80   0 -  3847 poll_s ?        00:00:00 upstart-socket-

        1 S     0  1183     2  0  60 -20 -     0 rescue ?        00:00:00 iwlwifi

        5 S     0  1392     1  0  80   0 -  4325 fuse_d ?        00:00:02 mount.exfat

        1 S     0  1401     2  0  80   0 -     0 kjourn ?        00:00:00 jbd2/sda6-8

        1 S     0  1402     2  0  60 -20 -     0 rescue ?        00:00:00 ext4-rsv-conver

        4 S     0  1426     1  0  80   0 - 79178 poll_s ?        00:00:00 smbd

        1 S     0  1499     1  0  80   0 -  3818 poll_s ?        00:00:00 upstart-file-br

        5 S   101  1667     1  0  80   0 - 63959 poll_s ?        00:00:00 rsyslogd

        5 S   102  1673     1  0  80   0 - 10020 ep_pol ?        00:00:01 dbus-daemon

        4 S     0  1688     1  0  80   0 - 83611 poll_s ?        00:00:00 ModemManager

        5 S     0  1702     1  0  80   0 -  4823 poll_s ?        00:00:00 bluetoothd

        5 S     0  1712     2  0  70 -10 -     0 rfcomm ?        00:00:00 krfcommd

        4 S     0  1760     1  0  80   0 - 10861 ep_pol ?        00:00:00 systemd-logind

        5 S   107  1797     1  0  80   0 -  8118 poll_s ?        00:00:02 avahi-daemon

        1 S   107  1799  1797  0  80   0 -  8054 unix_s ?        00:00:00 avahi-daemon

        5 S     0  1833     1  0  80   0 - 86513 poll_s ?        00:00:03 NetworkManager

        4 S     0  1839     1  0  80   0 - 70302 poll_s ?        00:00:00 polkitd

        5 S     0  1866     1  0  80   0 -  7655 poll_s ?        00:00:00 wpa_supplicant

        1 S     0  1886  1426  0  80   0 - 77188 poll_s ?        00:00:00 smbd

        5 S     0  1911  1426  0  80   0 - 79178 poll_s ?        00:00:00 smbd

        4 S     0  2060     1  0  80   0 -  3962 n_tty_ tty4     00:00:00 getty

        4 S     0  2062     1  0  80   0 -  3962 n_tty_ tty5     00:00:00 getty

        4 S     0  2068     1  0  80   0 -  3962 n_tty_ tty2     00:00:00 getty

        4 S     0  2069     1  0  80   0 -  3962 n_tty_ tty3     00:00:00 getty

        4 S     0  2072     1  0  80   0 -  3962 n_tty_ tty6     00:00:00 getty

        1 S     0  2102     1  0  80   0 -  5912 hrtime ?        00:00:00 cron

        4 S     0  2135     1  0  80   0 - 19371 poll_s ?        00:00:00 cups-browsed

        5 S     0  2147     1  0  80   0 -  4797 hrtime ?        00:00:01 irqbalance

        1 S     0  2163     1  0  80   0 -  1091 poll_s ?        00:00:04 acpid

        4 S     0  2252     1  0  80   0 - 33213 poll_s ?        00:00:00 mdm

        5 S   116  2317     1  0  80   0 -  7050 poll_s ?        00:00:00 dnsmasq

        1 S     0  2349     1  0  80   0 - 10422 pause  ?        00:00:54 cpufreqd

        1 S   106  2369     1  0  80   0 -  9285 poll_s ?        00:00:00 kerneloops

        4 S     0  2467     1  0  80   0 -  3962 n_tty_ tty1     00:00:00 getty

        5 S     0  2474  2252  0  80   0 - 66808 poll_s ?        00:00:00 mdm

        4 S     0  2482  2474  0  80   0 - 94001 poll_s tty8     00:04:20 Xorg

        1 S   111  2536     1  0  80   0 -  6108 poll_s ?        00:00:00 dbus-launch

        1 S   111  2538     1  0  80   0 -  9777 ep_pol ?        00:00:00 dbus-daemon

        1 S     0  2588     2  0  80   0 -     0 kaudit ?        00:00:00 kauditd

        5 S  1000  2591     1  0  80   0 - 73261 poll_s ?        00:00:00 gnome-keyring-d

        4 S     0  2597     1  0  80   0 - 525102 poll_s ?       00:00:00 console-kit-dae

        4 S  1000  2668  2474  0  80   0 - 98863 poll_s ?        00:00:00 cinnamon-sessio

        1 S  1000  2742  2668  0  80   0 -  2655 poll_s ?        00:00:00 ssh-agent

        1 S  1000  2745     1  0  80   0 -  6108 poll_s ?        00:00:00 dbus-launch

        1 S  1000  2746     1  0  80   0 -  9945 ep_pol ?        00:00:00 dbus-daemon

        0 S  1000  2753     1  0  80   0 - 84378 poll_s ?        00:00:00 at-spi-bus-laun

        0 S  1000  2757  2753  0  80   0 -  9810 ep_pol ?        00:00:00 dbus-daemon

        0 S  1000  2760     1  0  80   0 - 31227 poll_s ?        00:00:00 at-spi2-registr

        0 S  1000  2769  2668  0  80   0 - 259409 poll_s ?       00:00:12 cinnamon-settin

        1 S  1000  2784     1  0  69 -11 - 92467 poll_s ?        00:00:00 pulseaudio

        4 S   112  2786     1  0  81   1 - 42227 poll_s ?        00:00:00 rtkit-daemon

        4 S     0  2791     1  0  80   0 - 59885 poll_s ?        00:00:00 upowerd

        0 S  1000  2850     1  0  80   0 - 48120 poll_s ?        00:00:00 gvfsd

        0 S  1000  2854     1  0  80   0 - 86415 futex_ ?        00:00:00 gvfsd-fuse

        0 S  1000  2962     1  0  80   0 - 73671 poll_s ?        00:00:00 gvfs-udisks2-vo

        4 S     0  2965     1  0  80   0 - 92888 poll_s ?        00:00:02 udisksd

        0 S  1000  2974     1  0  80   0 - 49028 poll_s ?        00:00:00 gvfs-mtp-volume

        0 S  1000  2978     1  0  80   0 - 52069 poll_s ?        00:00:00 gvfs-gphoto2-vo

        0 S  1000  2982     1  0  80   0 - 70451 poll_s ?        00:00:00 gvfs-afc-volume

        4 S   109  2987     1  0  80   0 - 75428 poll_s ?        00:00:00 colord

        0 S  1000  2988  2668  0  80   0 - 59797 wait   ?        00:00:00 cinnamon-launch

        1 S     0  2992     2  0  80   0 -     0 worker ?        00:00:01 kworker/0:2

        0 S  1000  2993  2769  0  80   0 -  5057 hrtime ?        00:00:15 syndaemon

        0 S  1000  2995     1  0  80   0 - 96758 poll_s ?        00:00:00 csd-printer

        0 S  1000  3000  2988  2  80   0 - 432417 poll_s ?       00:13:44 cinnamon

        0 S  1000  3009  2668  0  80   0 - 202966 poll_s ?       00:00:01 nemo

        0 S  1000  3010  2668  0  80   0 - 131589 poll_s ?       00:00:01 nm-applet

        0 S  1000  3013  2668  0  80   0 - 56520 poll_s ?        00:00:00 polkit-gnome-au

        0 S  1000  3019     1  0  80   0 - 44576 poll_s ?        00:00:00 dconf-service

        0 S  1000  3025     1  0  80   0 - 734787 poll_s ?       00:00:15 dropbox

        0 S  1000  3044     1  0  80   0 - 30347 poll_s ?        00:00:00 gvfsd-metadata

        0 S  1000  3049     1  0  80   0 - 13324 poll_s ?        00:00:00 gconfd-2

        0 S  1000  3055     1  0  80   0 - 88811 poll_s ?        00:00:00 gvfsd-trash

        0 S  1000  3059     1  0  80   0 - 64660 poll_s ?        00:00:00 cinnamon-slides

        4 S     0  3070     1  0  80   0 - 71869 poll_s ?        00:00:00 accounts-daemon

        0 S  1000  3143  2668  0  80   0 -  6066 wait   ?        00:00:00 mintupdate-laun

        0 S  1000  3144  2668  0  80   0 - 104388 poll_s ?       00:00:10 cinnamon-screen

        0 S  1000  3147  3143  0  80   0 -  1110 wait   ?        00:00:00 sh

        0 S  1000  3148  3147  0  80   0 - 133237 poll_s ?       00:00:15 mintUpdate

        4 S     0  3178  1833  0  80   0 -  2556 poll_s ?        00:00:00 dhclient

        4 S 65534  3183  1833  0  80   0 -  7764 poll_s ?        00:00:00 dnsmasq

        4 S     0  3292     1  0  80   0 - 75028 ep_pol ?        00:00:05 docker

        5 S     0  3327     1  0  80   0 - 57861 poll_s ?        00:00:00 nmbd

        0 S  1000  3384  2668  0  80   0 - 51500 poll_s ?        00:00:00 applet.py

        0 S  1000  3389     1  0  80   0 - 180246 poll_s ?       00:00:00 scp-dbus-servic

        0 S  1000  3450     1  0  80   0 - 129093 poll_s ?       00:02:44 emacs

        0 S  1000  3455     1  0  80   0 - 134088 poll_s ?       00:00:10 gnome-terminal

        0 S  1000  3474  3455  0  80   0 -  3704 unix_s ?        00:00:00 gnome-pty-helpe

        4 S     0  9543     1  0  80   0 - 19194 ep_pol ?        00:00:00 cupsd

        1 S     0 14345     2  0  80   0 -     0 worker ?        00:00:00 kworker/3:1

        0 S  1000 15208  3450  0  80   0 -  7489 pipe_w ?        00:00:00 aspell

        0 S  1000 15286  3450  0  80   0 - 56098 poll_s pts/8    00:00:02 R

        1 S     0 16472     2  0  80   0 -     0 worker ?        00:00:00 kworker/1:2

        0 S  1000 16902  3455  0  80   0 -  5909 wait   pts/10   00:00:00 bash

        1 S     0 17312     2  0  80   0 -     0 worker ?        00:00:00 kworker/2:2

        1 S     0 17326     2  0  80   0 -     0 worker ?        00:00:00 kworker/u8:0

        1 S     0 17429     2  0  80   0 -     0 worker ?        00:00:00 kworker/u8:2

        1 S     0 17441     2  0  80   0 -     0 worker ?        00:00:00 kworker/u8:1

        1 S     0 17474     2  0  80   0 -     0 worker ?        00:00:00 kworker/1:0

        1 S     0 17475     2  0  80   0 -     0 worker ?        00:00:00 kworker/3:2

        1 S     0 17476     2  0  80   0 -     0 worker ?        00:00:00 kworker/3:3

        1 S     0 17477     2  0  80   0 -     0 worker ?        00:00:00 kworker/3:4

        1 S     0 17478     2  0  80   0 -     0 worker ?        00:00:00 kworker/3:5

        1 S     0 17479     2  0  80   0 -     0 worker ?        00:00:00 kworker/2:0

        1 S     0 17480     2  0  80   0 -     0 worker ?        00:00:00 kworker/2:3

        1 S     0 17484     2  0  80   0 -     0 worker ?        00:00:00 kworker/0:1

        1 S     0 17485     2  0  80   0 -     0 worker ?        00:00:00 kworker/0:3

        1 S     0 17486     2  0  80   0 -     0 worker ?        00:00:00 kworker/0:4

        1 S     0 17487     2  0  80   0 -     0 worker ?        00:00:00 kworker/0:5

        1 S     0 17488     2  0  80   0 -     0 worker ?        00:00:00 kworker/0:6

        0 S  1000 17505 16902  0  80   0 -  3116 wait   pts/10   00:00:00 bash

        0 S  1000 17512 17505  5  80   0 - 22314 pipe_w pts/10   00:00:00 ruby

        1 S     0 17530     2  0  80   0 -     0 worker ?        00:00:00 kworker/u8:3

        0 R  1000 17537 17512  0  80   0 -  2512 -      pts/10   00:00:00 ps

'
      :users: ! 'stemen   tty8         2016-12-14 09:01 (:0)

        stemen   pts/10       2016-12-14 16:29 (:0)

'
  :kernel_info:
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 1
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  for (igaus
      = 1; igaus <= pgaus; igaus += 1) {\n    for (inode = 1; inode <= pnode; inode
      += 1) {\n      agrau[inode - (1) + (pnode) * (igaus - (1))] = _mm_mul_pd( gpden[igaus
      - (1)], _mm_add_pd( _mm_add_pd( _mm_mul_pd( gpadv[1 - (1) + (3) * (igaus - (1))],
      gpcar[1 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ), _mm_mul_pd(
      gpadv[2 - (1) + (3) * (igaus - (1))], gpcar[2 - (1) + (3) * (inode - (1) + (mnode)
      * (igaus - (1)))] ) ), _mm_mul_pd( gpadv[3 - (1) + (3) * (igaus - (1))], gpcar[3
      - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) ) );\n      for (jnode
      = 1; jnode <= pnode; jnode += 1) {\n        wgrgr[inode - (1) + (pnode) * (jnode
      - (1) + (pnode) * (igaus - (1)))] = _mm_add_pd( _mm_add_pd( _mm_mul_pd( gpcar[1
      - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))], gpcar[1 - (1) + (3)
      * (jnode - (1) + (mnode) * (igaus - (1)))] ), _mm_mul_pd( gpcar[2 - (1) + (3)
      * (inode - (1) + (mnode) * (igaus - (1)))], gpcar[2 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) ), _mm_mul_pd( gpcar[3 - (1) + (3) * (inode -
      (1) + (mnode) * (igaus - (1)))], gpcar[3 - (1) + (3) * (jnode - (1) + (mnode)
      * (igaus - (1)))] ) );\n      }\n    }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 1
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest1(const int32_t mnode, const int32_t
      pnode, const int32_t pgaus, const __m128d * gpden, const __m128d * gpcar, const
      __m128d * gpadv, __m128d * wgrgr, __m128d * agrau){\n  int32_t inode;\n  int32_t
      jnode;\n  int32_t igaus;\n  for (igaus = 1; igaus <= pgaus; igaus += 1) {\n
      \   for (inode = 1; inode <= pnode; inode += 1) {\n      agrau[inode - (1) +
      (pnode) * (igaus - (1))] = _mm_mul_pd( gpden[igaus - (1)], _mm_add_pd( _mm_add_pd(
      _mm_mul_pd( gpadv[1 - (1) + (3) * (igaus - (1))], gpcar[1 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ), _mm_mul_pd( gpadv[2 - (1) + (3) * (igaus
      - (1))], gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) ),
      _mm_mul_pd( gpadv[3 - (1) + (3) * (igaus - (1))], gpcar[3 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ) ) );\n      for (jnode = 1; jnode <= pnode;
      jnode += 1) {\n        wgrgr[inode - (1) + (pnode) * (jnode - (1) + (pnode)
      * (igaus - (1)))] = _mm_add_pd( _mm_add_pd( _mm_mul_pd( gpcar[1 - (1) + (3)
      * (inode - (1) + (mnode) * (igaus - (1)))], gpcar[1 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ), _mm_mul_pd( gpcar[2 - (1) + (3) * (inode - (1)
      + (mnode) * (igaus - (1)))], gpcar[2 - (1) + (3) * (jnode - (1) + (mnode) *
      (igaus - (1)))] ) ), _mm_mul_pd( gpcar[3 - (1) + (3) * (inode - (1) + (mnode)
      * (igaus - (1)))], gpcar[3 - (1) + (3) * (jnode - (1) + (mnode) * (igaus - (1)))]
      ) );\n      }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest1(mnode,
      pnode, pgaus, gpden, gpcar, gpadv, wgrgr, agrau);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 1
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest1(const int32_t mnode, const int32_t pnode,
      const int32_t pgaus, const __m128d * gpden, const __m128d * gpcar, const __m128d
      * gpadv, __m128d * wgrgr, __m128d * agrau){\n  int32_t inode;\n  int32_t jnode;\n
      \ int32_t igaus;\n  for (igaus = 1; igaus <= pgaus; igaus += 1) {\n    for (inode
      = 1; inode <= pnode; inode += 1) {\n      agrau[inode - (1) + (pnode) * (igaus
      - (1))] = _mm_mul_pd( gpden[igaus - (1)], _mm_add_pd( _mm_add_pd( _mm_mul_pd(
      gpadv[1 - (1) + (3) * (igaus - (1))], gpcar[1 - (1) + (3) * (inode - (1) + (mnode)
      * (igaus - (1)))] ), _mm_mul_pd( gpadv[2 - (1) + (3) * (igaus - (1))], gpcar[2
      - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) ), _mm_mul_pd( gpadv[3
      - (1) + (3) * (igaus - (1))], gpcar[3 - (1) + (3) * (inode - (1) + (mnode) *
      (igaus - (1)))] ) ) );\n      for (jnode = 1; jnode <= pnode; jnode += 1) {\n
      \       wgrgr[inode - (1) + (pnode) * (jnode - (1) + (pnode) * (igaus - (1)))]
      = _mm_add_pd( _mm_add_pd( _mm_mul_pd( gpcar[1 - (1) + (3) * (inode - (1) + (mnode)
      * (igaus - (1)))], gpcar[1 - (1) + (3) * (jnode - (1) + (mnode) * (igaus - (1)))]
      ), _mm_mul_pd( gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))],
      gpcar[2 - (1) + (3) * (jnode - (1) + (mnode) * (igaus - (1)))] ) ), _mm_mul_pd(
      gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))], gpcar[3 - (1)
      + (3) * (jnode - (1) + (mnode) * (igaus - (1)))] ) );\n      }\n    }\n  }\n}\nvoid
      nsi_element_assembly_split_oss_ndime3(const int32_t kfl_lumped, const int32_t
      mnode, const int32_t ntens, const int32_t kfl_duatss, const int32_t fact_duatss,
      const int32_t kfl_stabi_nsi, const double fvins_nsi, const double fcons_nsi,
      const double bemol_nsi, const int32_t kfl_regim_nsi, const double * fvela_nsi,
      const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi, const int32_t kfl_p1ve2_nsi,
      const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi, const int32_t nbdfp_nsi,
      const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi, const int32_t kfl_limit_nsi,
      const int32_t kfl_penal_nsi, const double penal_nsi, const int32_t kfl_bubbl_nsi,
      const int32_t pnode, const int32_t pgaus, const __m128d * gpden, const __m128d
      * gpvis, const __m128d * gppor, const __m128d * gpsp1, const __m128d * gpsp2,
      const __m128d * gpvol, const __m128d * gpsha, const __m128d * gpcar, const __m128d
      * gpadv, __m128d * gpvep, __m128d * gpgrp, __m128d * gprhs, __m128d * gprhc,
      const __m128d * gpvel, const __m128d * gpsgs, const __m128d * elvel, const __m128d
      * elpre, const __m128d * elbub, __m128d * wgrgr, __m128d * agrau, __m128d *
      elauu, __m128d * elaup, __m128d * elapp, __m128d * elapu, __m128d * elrbu, __m128d
      * elrbp, const __m128d * dtinv_loc, const __m128d * dtsgs, const __m64 * pbubl,
      const __m128d * gpsha_bub, const __m128d * gpcar_bub, __m128d * elauq, __m128d
      * elapq, __m128d * elaqu, __m128d * elaqp, __m128d * elaqq, __m128d * elrbq){\n
      \ __m128d gpsp1_p[(pgaus)];\n  __m128d gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n
      \ __m128d c1[(1)];\n  __m128d c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n
      \ __m128d alpha[(1)];\n  __m128d beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d
      fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n  int32_t inode;\n  int32_t jnode;\n
      \ int32_t jdime;\n  int32_t idofv;\n  int32_t ivect;\n  int32_t igaus;\n  int32_t
      idime;\n  int32_t jdofv;\n  int32_t itime;\n  __m128d fact[(9)];\n  int32_t
      idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod, dtinv_loc, sizeof(dtinv_mod));\n
      \ memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n  memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n
      \ memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n  if (kfl_nota1_nsi == 1) memset(gpsp1_v,
      0, sizeof(gpsp1_v));\n\n  memset(elrbp, 0, sizeof(__m128d) * pnode);\n  memset(elrbu,
      0, sizeof(__m128d) * 3 * pnode);\n  memset(elapp, 0, sizeof(__m128d) * pnode
      * pnode);\n  memset(elauu, 0, sizeof(__m128d) * pnode * 3 * pnode * 3);\n  memset(elaup,
      0, sizeof(__m128d) * pnode * 3 * pnode);\n  memset(elapu, 0, sizeof(__m128d)
      * pnode * pnode * 3);\n  nest1(mnode, pnode, pgaus, gpden, gpcar, gpadv, wgrgr,
      agrau);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 2
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  for (igaus
      = 1; igaus <= pgaus; igaus += 1) {\n    fact[1 - (1)] = _mm_mul_pd( gpsp2[igaus
      - (1)], gpvol[igaus - (1)] );\n    fact[7 - (1)] = _mm_mul_pd( gpvis[igaus -
      (1)], gpvol[igaus - (1)] );\n    fact[8 - (1)] = _mm_mul_pd( gpsp1_v[igaus -
      (1)], gpvol[igaus - (1)] );\n    fact[9 - (1)] = _mm_add_pd( _mm_mul_pd( _mm_mul_pd(
      gpden[igaus - (1)], _mm_set1_pd( pabdf_nsi(1) ) ), dtinv_loc[1 - (1)] ), gppor[igaus
      - (1)] );\n    for (inode = 1; inode <= pnode; inode += 1) {\n      for (idime
      = 1; idime <= 3; idime += 1) {\n        idof[1 - (1)] = (inode - (1)) * (3)
      + idime;\n        fact[2 - (1)] = _mm_mul_pd( fact[1 - (1)], gpcar[idime - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n        for (jnode = 1;
      jnode <= pnode; jnode += 1) {\n          jdof[1 - (1)] = (jnode - (1)) * (3)
      + 1;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)]
      - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[2 - (1)] = (jnode - (1)) *
      (3) + 2;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[2 -
      (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[2
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[3 - (1)] = (jnode - (1)) *
      (3) + 3;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[3 -
      (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[3
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[1 - (1)] = (jnode - (1)) *
      (3) + idime;\n          fact[5 - (1)] = _mm_mul_pd( gpsha[inode - (1) + (pnode)
      * (igaus - (1))], gpvol[igaus - (1)] );\n          fact[6 - (1)] = _mm_add_pd(
      _mm_add_pd( _mm_mul_pd( fact[5 - (1)], _mm_add_pd( agrau[jnode - (1) + (pnode)
      * (igaus - (1))], _mm_mul_pd( fact[9 - (1)], gpsha[jnode - (1) + (pnode) * (igaus
      - (1))] ) ) ), _mm_mul_pd( fact[7 - (1)], wgrgr[inode - (1) + (pnode) * (jnode
      - (1) + (pnode) * (igaus - (1)))] ) ), _mm_mul_pd( _mm_mul_pd( fact[8 - (1)],
      agrau[jnode - (1) + (pnode) * (igaus - (1))] ), agrau[inode - (1) + (pnode)
      * (igaus - (1))] ) );\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3))
      * (jdof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[1 - (1)] - (1))], fact[6 - (1)] );\n        }\n      }\n    }\n
      \ }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 2
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest2(const int32_t mnode, const int32_t
      pnode, const int32_t pgaus, const __m128d * gpden, const __m128d * gpcar, const
      __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpvis, const __m128d
      * dtinv_loc, const __m128d * gppor, const __m128d * gpsha, const __m128d gpsp1_v[(pgaus)],
      const __m128d * wgrgr, const __m128d * agrau, __m128d * elauu){\n  __m128d fact[(9)];\n
      \ int32_t igaus;\n  int32_t inode;\n  int32_t jnode;\n  int32_t idof[(3)];\n
      \ int32_t jdof[(3)];\n  int32_t idime;\n  int32_t jdime;\n  for (igaus = 1;
      igaus <= pgaus; igaus += 1) {\n    fact[1 - (1)] = _mm_mul_pd( gpsp2[igaus -
      (1)], gpvol[igaus - (1)] );\n    fact[7 - (1)] = _mm_mul_pd( gpvis[igaus - (1)],
      gpvol[igaus - (1)] );\n    fact[8 - (1)] = _mm_mul_pd( gpsp1_v[igaus - (1)],
      gpvol[igaus - (1)] );\n    fact[9 - (1)] = _mm_add_pd( _mm_mul_pd( _mm_mul_pd(
      gpden[igaus - (1)], _mm_set1_pd( pabdf_nsi(1) ) ), dtinv_loc[1 - (1)] ), gppor[igaus
      - (1)] );\n    for (inode = 1; inode <= pnode; inode += 1) {\n      for (idime
      = 1; idime <= 3; idime += 1) {\n        idof[1 - (1)] = (inode - (1)) * (3)
      + idime;\n        fact[2 - (1)] = _mm_mul_pd( fact[1 - (1)], gpcar[idime - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n        for (jnode = 1;
      jnode <= pnode; jnode += 1) {\n          jdof[1 - (1)] = (jnode - (1)) * (3)
      + 1;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)]
      - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[2 - (1)] = (jnode - (1)) *
      (3) + 2;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[2 -
      (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[2
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[3 - (1)] = (jnode - (1)) *
      (3) + 3;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[3 -
      (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[3
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[1 - (1)] = (jnode - (1)) *
      (3) + idime;\n          fact[5 - (1)] = _mm_mul_pd( gpsha[inode - (1) + (pnode)
      * (igaus - (1))], gpvol[igaus - (1)] );\n          fact[6 - (1)] = _mm_add_pd(
      _mm_add_pd( _mm_mul_pd( fact[5 - (1)], _mm_add_pd( agrau[jnode - (1) + (pnode)
      * (igaus - (1))], _mm_mul_pd( fact[9 - (1)], gpsha[jnode - (1) + (pnode) * (igaus
      - (1))] ) ) ), _mm_mul_pd( fact[7 - (1)], wgrgr[inode - (1) + (pnode) * (jnode
      - (1) + (pnode) * (igaus - (1)))] ) ), _mm_mul_pd( _mm_mul_pd( fact[8 - (1)],
      agrau[jnode - (1) + (pnode) * (igaus - (1))] ), agrau[inode - (1) + (pnode)
      * (igaus - (1))] ) );\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3))
      * (jdof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[1 - (1)] - (1))], fact[6 - (1)] );\n        }\n      }\n    }\n
      \ }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t kfl_lumped,
      const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss, const int32_t
      fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi, const double
      fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi, const double
      * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi, const
      int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest2(mnode,
      pnode, pgaus, gpden, gpcar, gpsp2, gpvol, gpvis, dtinv_loc, gppor, gpsha, gpsp1_v,
      wgrgr, agrau, elauu);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 2
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest2(const int32_t mnode, const int32_t pnode,
      const int32_t pgaus, const __m128d * gpden, const __m128d * gpcar, const __m128d
      * gpsp2, const __m128d * gpvol, const __m128d * gpvis, const __m128d * dtinv_loc,
      const __m128d * gppor, const __m128d * gpsha, const __m128d gpsp1_v[(pgaus)],
      const __m128d * wgrgr, const __m128d * agrau, __m128d * elauu){\n  __m128d fact[(9)];\n
      \ int32_t igaus;\n  int32_t inode;\n  int32_t jnode;\n  int32_t idof[(3)];\n
      \ int32_t jdof[(3)];\n  int32_t idime;\n  int32_t jdime;\n  for (igaus = 1;
      igaus <= pgaus; igaus += 1) {\n    fact[1 - (1)] = _mm_mul_pd( gpsp2[igaus -
      (1)], gpvol[igaus - (1)] );\n    fact[7 - (1)] = _mm_mul_pd( gpvis[igaus - (1)],
      gpvol[igaus - (1)] );\n    fact[8 - (1)] = _mm_mul_pd( gpsp1_v[igaus - (1)],
      gpvol[igaus - (1)] );\n    fact[9 - (1)] = _mm_add_pd( _mm_mul_pd( _mm_mul_pd(
      gpden[igaus - (1)], _mm_set1_pd( pabdf_nsi(1) ) ), dtinv_loc[1 - (1)] ), gppor[igaus
      - (1)] );\n    for (inode = 1; inode <= pnode; inode += 1) {\n      for (idime
      = 1; idime <= 3; idime += 1) {\n        idof[1 - (1)] = (inode - (1)) * (3)
      + idime;\n        fact[2 - (1)] = _mm_mul_pd( fact[1 - (1)], gpcar[idime - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n        for (jnode = 1;
      jnode <= pnode; jnode += 1) {\n          jdof[1 - (1)] = (jnode - (1)) * (3)
      + 1;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)]
      - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[2 - (1)] = (jnode - (1)) *
      (3) + 2;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[2 -
      (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[2
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[3 - (1)] = (jnode - (1)) *
      (3) + 3;\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[3 -
      (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[3
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (jnode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          jdof[1 - (1)] = (jnode - (1)) *
      (3) + idime;\n          fact[5 - (1)] = _mm_mul_pd( gpsha[inode - (1) + (pnode)
      * (igaus - (1))], gpvol[igaus - (1)] );\n          fact[6 - (1)] = _mm_add_pd(
      _mm_add_pd( _mm_mul_pd( fact[5 - (1)], _mm_add_pd( agrau[jnode - (1) + (pnode)
      * (igaus - (1))], _mm_mul_pd( fact[9 - (1)], gpsha[jnode - (1) + (pnode) * (igaus
      - (1))] ) ) ), _mm_mul_pd( fact[7 - (1)], wgrgr[inode - (1) + (pnode) * (jnode
      - (1) + (pnode) * (igaus - (1)))] ) ), _mm_mul_pd( _mm_mul_pd( fact[8 - (1)],
      agrau[jnode - (1) + (pnode) * (igaus - (1))] ), agrau[inode - (1) + (pnode)
      * (igaus - (1))] ) );\n          elauu[idof[1 - (1)] - (1) + ((pnode) * (3))
      * (jdof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[1 - (1)] - (1))], fact[6 - (1)] );\n        }\n      }\n    }\n
      \ }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t kfl_lumped,
      const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss, const int32_t
      fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi, const double
      fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi, const double
      * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi, const
      int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest2(mnode,
      pnode, pgaus, gpden, gpcar, gpsp2, gpvol, gpvis, dtinv_loc, gppor, gpsha, gpsp1_v,
      wgrgr, agrau, elauu);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 3
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  if (fvins_nsi
      > 0.9) {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n      for (inode
      = 1; inode <= pnode; inode += 1) {\n        for (idime = 1; idime <= 3; idime
      += 1) {\n          idofv = (inode - (1)) * (3) + idime;\n          for (jnode
      = 1; jnode <= pnode; jnode += 1) {\n            fact[2 - (1)] = _mm_mul_pd(
      _mm_mul_pd( gpvis[igaus - (1)], gpvol[igaus - (1)] ), gpcar[idime - (1) + (3)
      * (jnode - (1) + (mnode) * (igaus - (1)))] );\n            jdofv = (jnode -
      (1)) * (3) + 1;\n            elauu[idofv - (1) + ((pnode) * (3)) * (jdofv -
      (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[1 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n            jdofv = (jnode - (1)) * (3) + 2;\n            elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ) );\n            jdofv = (jnode - (1)) *
      (3) + 3;\n            elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))] =
      _mm_add_pd( elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n          }\n          if (fvins_nsi == 2.0) {\n            fact[2 - (1)]
      = _mm_mul_pd( _mm_mul_pd( _mm_mul_pd( _mm_set1_pd( (-2.0) / (3.0) ), gpvis[igaus
      - (1)] ), gpvol[igaus - (1)] ), gpcar[idime - (1) + (3) * (inode - (1) + (mnode)
      * (igaus - (1)))] );\n            for (jnode = 1; jnode <= pnode; jnode += 1)
      {\n              jdofv = (jnode - (1)) * (3) + 1;\n              elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (jnode
      - (1) + (mnode) * (igaus - (1)))] ) );\n              jdofv = (jnode - (1))
      * (3) + 2;\n              elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))]
      = _mm_add_pd( elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[2 - (1) + (3) * (jnode - (1) + (mnode) * (igaus - (1)))]
      ) );\n              jdofv = (jnode - (1)) * (3) + 3;\n              elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (jnode
      - (1) + (mnode) * (igaus - (1)))] ) );\n            }\n          }\n        }\n
      \     }\n    }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 3
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest3(const int32_t pgaus, const int32_t
      pnode, const int32_t mnode, const __m128d * gpvis, const __m128d * gpvol, const
      __m128d * gpcar, const double fvins_nsi, __m128d * elauu){\n  int32_t igaus;\n
      \ int32_t idime;\n  int32_t jdime;\n  int32_t inode;\n  int32_t jnode;\n  __m128d
      fact[(9)];\n  int32_t idofv;\n  int32_t jdofv;\n  if (fvins_nsi > 0.9) {\n    for
      (igaus = 1; igaus <= pgaus; igaus += 1) {\n      for (inode = 1; inode <= pnode;
      inode += 1) {\n        for (idime = 1; idime <= 3; idime += 1) {\n          idofv
      = (inode - (1)) * (3) + idime;\n          for (jnode = 1; jnode <= pnode; jnode
      += 1) {\n            fact[2 - (1)] = _mm_mul_pd( _mm_mul_pd( gpvis[igaus - (1)],
      gpvol[igaus - (1)] ), gpcar[idime - (1) + (3) * (jnode - (1) + (mnode) * (igaus
      - (1)))] );\n            jdofv = (jnode - (1)) * (3) + 1;\n            elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ) );\n            jdofv = (jnode - (1)) *
      (3) + 2;\n            elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))] =
      _mm_add_pd( elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n            jdofv = (jnode - (1)) * (3) + 3;\n            elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ) );\n          }\n          if (fvins_nsi
      == 2.0) {\n            fact[2 - (1)] = _mm_mul_pd( _mm_mul_pd( _mm_mul_pd( _mm_set1_pd(
      (-2.0) / (3.0) ), gpvis[igaus - (1)] ), gpvol[igaus - (1)] ), gpcar[idime -
      (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n            for (jnode
      = 1; jnode <= pnode; jnode += 1) {\n              jdofv = (jnode - (1)) * (3)
      + 1;\n              elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd(
      elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)],
      gpcar[1 - (1) + (3) * (jnode - (1) + (mnode) * (igaus - (1)))] ) );\n              jdofv
      = (jnode - (1)) * (3) + 2;\n              elauu[idofv - (1) + ((pnode) * (3))
      * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode) * (3)) * (jdofv
      - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1) + (3) * (jnode - (1) + (mnode)
      * (igaus - (1)))] ) );\n              jdofv = (jnode - (1)) * (3) + 3;\n              elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (jnode
      - (1) + (mnode) * (igaus - (1)))] ) );\n            }\n          }\n        }\n
      \     }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t
      kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss,
      const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi,
      const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest3(pgaus,
      pnode, mnode, gpvis, gpvol, gpcar, fvins_nsi, elauu);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 3
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest3(const int32_t pgaus, const int32_t pnode,
      const int32_t mnode, const __m128d * gpvis, const __m128d * gpvol, const __m128d
      * gpcar, const double fvins_nsi, __m128d * elauu){\n  int32_t igaus;\n  int32_t
      idime;\n  int32_t jdime;\n  int32_t inode;\n  int32_t jnode;\n  __m128d fact[(9)];\n
      \ int32_t idofv;\n  int32_t jdofv;\n  if (fvins_nsi > 0.9) {\n    for (igaus
      = 1; igaus <= pgaus; igaus += 1) {\n      for (inode = 1; inode <= pnode; inode
      += 1) {\n        for (idime = 1; idime <= 3; idime += 1) {\n          idofv
      = (inode - (1)) * (3) + idime;\n          for (jnode = 1; jnode <= pnode; jnode
      += 1) {\n            fact[2 - (1)] = _mm_mul_pd( _mm_mul_pd( gpvis[igaus - (1)],
      gpvol[igaus - (1)] ), gpcar[idime - (1) + (3) * (jnode - (1) + (mnode) * (igaus
      - (1)))] );\n            jdofv = (jnode - (1)) * (3) + 1;\n            elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ) );\n            jdofv = (jnode - (1)) *
      (3) + 2;\n            elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))] =
      _mm_add_pd( elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n            jdofv = (jnode - (1)) * (3) + 3;\n            elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ) );\n          }\n          if (fvins_nsi
      == 2.0) {\n            fact[2 - (1)] = _mm_mul_pd( _mm_mul_pd( _mm_mul_pd( _mm_set1_pd(
      (-2.0) / (3.0) ), gpvis[igaus - (1)] ), gpvol[igaus - (1)] ), gpcar[idime -
      (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n            for (jnode
      = 1; jnode <= pnode; jnode += 1) {\n              jdofv = (jnode - (1)) * (3)
      + 1;\n              elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd(
      elauu[idofv - (1) + ((pnode) * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)],
      gpcar[1 - (1) + (3) * (jnode - (1) + (mnode) * (igaus - (1)))] ) );\n              jdofv
      = (jnode - (1)) * (3) + 2;\n              elauu[idofv - (1) + ((pnode) * (3))
      * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode) * (3)) * (jdofv
      - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1) + (3) * (jnode - (1) + (mnode)
      * (igaus - (1)))] ) );\n              jdofv = (jnode - (1)) * (3) + 3;\n              elauu[idofv
      - (1) + ((pnode) * (3)) * (jdofv - (1))] = _mm_add_pd( elauu[idofv - (1) + ((pnode)
      * (3)) * (jdofv - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (jnode
      - (1) + (mnode) * (igaus - (1)))] ) );\n            }\n          }\n        }\n
      \     }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t
      kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss,
      const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi,
      const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest3(pgaus,
      pnode, mnode, gpvis, gpvol, gpcar, fvins_nsi, elauu);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 4
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  if (kfl_lumped
      == 1) {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n              memset(gpveo,0,sizeof(__m128d)
      * 3);\n      for (inode = 1; inode <= pnode; inode += 1) {\n        gpveo[1
      - (1)] = _mm_add_pd( gpveo[1 - (1)], _mm_mul_pd( elvel[1 - (1) + (3) * (inode
      - (1) + (pnode) * (2 - (1)))], gpsha[inode - (1) + (pnode) * (igaus - (1))]
      ) );\n        gpveo[2 - (1)] = _mm_add_pd( gpveo[2 - (1)], _mm_mul_pd( elvel[2
      - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))], gpsha[inode - (1) + (pnode)
      * (igaus - (1))] ) );\n        gpveo[3 - (1)] = _mm_add_pd( gpveo[3 - (1)],
      _mm_mul_pd( elvel[3 - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))], gpsha[inode
      - (1) + (pnode) * (igaus - (1))] ) );\n      }\n      fact[1 - (1)] = _mm_mul_pd(
      _mm_mul_pd( gpvol[igaus - (1)], gpden[igaus - (1)] ), dtinv_mod[1 - (1)] );\n
      \     for (inode = 1; inode <= pnode; inode += 1) {\n        fact[2 - (1)] =
      _mm_mul_pd( fact[1 - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))] );\n
      \       idof[1 - (1)] = (inode - (1)) * (3) + 1;\n        elauu[idof[1 - (1)]
      - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1
      - (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[2 - (1)] = (inode - (1)) * (3) + 2;\n        elauu[idof[2 - (1)]
      - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))] = _mm_add_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[3 - (1)] = (inode - (1)) * (3) + 3;\n        elauu[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))] = _mm_add_pd( elauu[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))], fact[2 - (1)] );\n
      \       elrbu[1 - (1) + (3) * (inode - (1))] = _mm_sub_pd( elrbu[1 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpveo[1 - (1)] ) );\n        elrbu[1
      - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[1 - (1) + (3) * (inode - (1))],
      _mm_mul_pd( fact[2 - (1)], elvel[1 - (1) + (3) * (inode - (1) + (pnode) * (2
      - (1)))] ) );\n        elrbu[2 - (1) + (3) * (inode - (1))] = _mm_sub_pd( elrbu[2
      - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpveo[2 - (1)] ) );\n
      \       elrbu[2 - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[2 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[2 - (1) + (3) * (inode -
      (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[3 - (1) + (3) * (inode - (1))]
      = _mm_sub_pd( elrbu[3 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)],
      gpveo[3 - (1)] ) );\n        elrbu[3 - (1) + (3) * (inode - (1))] = _mm_add_pd(
      elrbu[3 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[3 - (1)
      + (3) * (inode - (1) + (pnode) * (2 - (1)))] ) );\n        for (jnode = 1; jnode
      <= pnode; jnode += 1) {\n          jdof[1 - (1)] = (jnode - (1)) * (3) + 1;\n
      \         elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)] - (1))]
      = _mm_sub_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)] -
      (1))], _mm_mul_pd( fact[2 - (1)], gpsha[jnode - (1) + (pnode) * (igaus - (1))]
      ) );\n          jdof[2 - (1)] = (jnode - (1)) * (3) + 2;\n          elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (jdof[2 - (1)] - (1))] = _mm_sub_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (jdof[2 - (1)] - (1))], _mm_mul_pd( fact[2
      - (1)], gpsha[jnode - (1) + (pnode) * (igaus - (1))] ) );\n          jdof[3
      - (1)] = (jnode - (1)) * (3) + 3;\n          elauu[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[3 - (1)] - (1))] = _mm_sub_pd( elauu[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpsha[jnode - (1)
      + (pnode) * (igaus - (1))] ) );\n        }\n      }\n    }\n  } else if (kfl_lumped
      == 2) {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n      fact[1 - (1)]
      = _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpden[igaus - (1)] ), dtinv_mod[1
      - (1)] );\n      for (inode = 1; inode <= pnode; inode += 1) {\n        fact[2
      - (1)] = _mm_mul_pd( fact[1 - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))]
      );\n        idof[1 - (1)] = (inode - (1)) * (3) + 1;\n        elauu[idof[1 -
      (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1
      - (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[2 - (1)] = (inode - (1)) * (3) + 2;\n        elauu[idof[2 - (1)]
      - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))] = _mm_add_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[3 - (1)] = (inode - (1)) * (3) + 3;\n        elauu[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))] = _mm_add_pd( elauu[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))], fact[2 - (1)] );\n
      \       elrbu[1 - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[1 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[1 - (1) + (3) * (inode -
      (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[2 - (1) + (3) * (inode - (1))]
      = _mm_add_pd( elrbu[2 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)],
      elvel[2 - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[3
      - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[3 - (1) + (3) * (inode - (1))],
      _mm_mul_pd( fact[2 - (1)], elvel[3 - (1) + (3) * (inode - (1) + (pnode) * (2
      - (1)))] ) );\n      }\n    }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 4
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest4(const int32_t pgaus, const int32_t
      pnode, const __m128d * gpvol, const __m128d * gpden, const __m128d dtinv_mod[(1)],
      const __m128d * gpsha, const __m128d * elvel, const int32_t kfl_lumped, __m128d
      gpveo[(3)], __m128d * elrbu, __m128d * elauu){\n  int32_t idime;\n  int32_t
      jdime;\n  int32_t igaus;\n  int32_t inode;\n  int32_t jnode;\n  __m128d fact[(9)];\n
      \ int32_t idof[(3)];\n  int32_t jdof[(3)];\n  if (kfl_lumped == 1) {\n    for
      (igaus = 1; igaus <= pgaus; igaus += 1) {\n              memset(gpveo,0,sizeof(__m128d)
      * 3);\n      for (inode = 1; inode <= pnode; inode += 1) {\n        gpveo[1
      - (1)] = _mm_add_pd( gpveo[1 - (1)], _mm_mul_pd( elvel[1 - (1) + (3) * (inode
      - (1) + (pnode) * (2 - (1)))], gpsha[inode - (1) + (pnode) * (igaus - (1))]
      ) );\n        gpveo[2 - (1)] = _mm_add_pd( gpveo[2 - (1)], _mm_mul_pd( elvel[2
      - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))], gpsha[inode - (1) + (pnode)
      * (igaus - (1))] ) );\n        gpveo[3 - (1)] = _mm_add_pd( gpveo[3 - (1)],
      _mm_mul_pd( elvel[3 - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))], gpsha[inode
      - (1) + (pnode) * (igaus - (1))] ) );\n      }\n      fact[1 - (1)] = _mm_mul_pd(
      _mm_mul_pd( gpvol[igaus - (1)], gpden[igaus - (1)] ), dtinv_mod[1 - (1)] );\n
      \     for (inode = 1; inode <= pnode; inode += 1) {\n        fact[2 - (1)] =
      _mm_mul_pd( fact[1 - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))] );\n
      \       idof[1 - (1)] = (inode - (1)) * (3) + 1;\n        elauu[idof[1 - (1)]
      - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1
      - (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[2 - (1)] = (inode - (1)) * (3) + 2;\n        elauu[idof[2 - (1)]
      - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))] = _mm_add_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[3 - (1)] = (inode - (1)) * (3) + 3;\n        elauu[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))] = _mm_add_pd( elauu[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))], fact[2 - (1)] );\n
      \       elrbu[1 - (1) + (3) * (inode - (1))] = _mm_sub_pd( elrbu[1 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpveo[1 - (1)] ) );\n        elrbu[1
      - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[1 - (1) + (3) * (inode - (1))],
      _mm_mul_pd( fact[2 - (1)], elvel[1 - (1) + (3) * (inode - (1) + (pnode) * (2
      - (1)))] ) );\n        elrbu[2 - (1) + (3) * (inode - (1))] = _mm_sub_pd( elrbu[2
      - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpveo[2 - (1)] ) );\n
      \       elrbu[2 - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[2 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[2 - (1) + (3) * (inode -
      (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[3 - (1) + (3) * (inode - (1))]
      = _mm_sub_pd( elrbu[3 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)],
      gpveo[3 - (1)] ) );\n        elrbu[3 - (1) + (3) * (inode - (1))] = _mm_add_pd(
      elrbu[3 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[3 - (1)
      + (3) * (inode - (1) + (pnode) * (2 - (1)))] ) );\n        for (jnode = 1; jnode
      <= pnode; jnode += 1) {\n          jdof[1 - (1)] = (jnode - (1)) * (3) + 1;\n
      \         elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)] - (1))]
      = _mm_sub_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)] -
      (1))], _mm_mul_pd( fact[2 - (1)], gpsha[jnode - (1) + (pnode) * (igaus - (1))]
      ) );\n          jdof[2 - (1)] = (jnode - (1)) * (3) + 2;\n          elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (jdof[2 - (1)] - (1))] = _mm_sub_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (jdof[2 - (1)] - (1))], _mm_mul_pd( fact[2
      - (1)], gpsha[jnode - (1) + (pnode) * (igaus - (1))] ) );\n          jdof[3
      - (1)] = (jnode - (1)) * (3) + 3;\n          elauu[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[3 - (1)] - (1))] = _mm_sub_pd( elauu[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpsha[jnode - (1)
      + (pnode) * (igaus - (1))] ) );\n        }\n      }\n    }\n  } else if (kfl_lumped
      == 2) {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n      fact[1 - (1)]
      = _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpden[igaus - (1)] ), dtinv_mod[1
      - (1)] );\n      for (inode = 1; inode <= pnode; inode += 1) {\n        fact[2
      - (1)] = _mm_mul_pd( fact[1 - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))]
      );\n        idof[1 - (1)] = (inode - (1)) * (3) + 1;\n        elauu[idof[1 -
      (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1
      - (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[2 - (1)] = (inode - (1)) * (3) + 2;\n        elauu[idof[2 - (1)]
      - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))] = _mm_add_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[3 - (1)] = (inode - (1)) * (3) + 3;\n        elauu[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))] = _mm_add_pd( elauu[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))], fact[2 - (1)] );\n
      \       elrbu[1 - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[1 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[1 - (1) + (3) * (inode -
      (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[2 - (1) + (3) * (inode - (1))]
      = _mm_add_pd( elrbu[2 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)],
      elvel[2 - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[3
      - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[3 - (1) + (3) * (inode - (1))],
      _mm_mul_pd( fact[2 - (1)], elvel[3 - (1) + (3) * (inode - (1) + (pnode) * (2
      - (1)))] ) );\n      }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest4(pgaus,
      pnode, gpvol, gpden, dtinv_mod, gpsha, elvel, kfl_lumped, gpveo, elrbu, elauu);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 4
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest4(const int32_t pgaus, const int32_t pnode,
      const __m128d * gpvol, const __m128d * gpden, const __m128d dtinv_mod[(1)],
      const __m128d * gpsha, const __m128d * elvel, const int32_t kfl_lumped, __m128d
      gpveo[(3)], __m128d * elrbu, __m128d * elauu){\n  int32_t idime;\n  int32_t
      jdime;\n  int32_t igaus;\n  int32_t inode;\n  int32_t jnode;\n  __m128d fact[(9)];\n
      \ int32_t idof[(3)];\n  int32_t jdof[(3)];\n  if (kfl_lumped == 1) {\n    for
      (igaus = 1; igaus <= pgaus; igaus += 1) {\n              memset(gpveo,0,sizeof(__m128d)
      * 3);\n      for (inode = 1; inode <= pnode; inode += 1) {\n        gpveo[1
      - (1)] = _mm_add_pd( gpveo[1 - (1)], _mm_mul_pd( elvel[1 - (1) + (3) * (inode
      - (1) + (pnode) * (2 - (1)))], gpsha[inode - (1) + (pnode) * (igaus - (1))]
      ) );\n        gpveo[2 - (1)] = _mm_add_pd( gpveo[2 - (1)], _mm_mul_pd( elvel[2
      - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))], gpsha[inode - (1) + (pnode)
      * (igaus - (1))] ) );\n        gpveo[3 - (1)] = _mm_add_pd( gpveo[3 - (1)],
      _mm_mul_pd( elvel[3 - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))], gpsha[inode
      - (1) + (pnode) * (igaus - (1))] ) );\n      }\n      fact[1 - (1)] = _mm_mul_pd(
      _mm_mul_pd( gpvol[igaus - (1)], gpden[igaus - (1)] ), dtinv_mod[1 - (1)] );\n
      \     for (inode = 1; inode <= pnode; inode += 1) {\n        fact[2 - (1)] =
      _mm_mul_pd( fact[1 - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))] );\n
      \       idof[1 - (1)] = (inode - (1)) * (3) + 1;\n        elauu[idof[1 - (1)]
      - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1
      - (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[2 - (1)] = (inode - (1)) * (3) + 2;\n        elauu[idof[2 - (1)]
      - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))] = _mm_add_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[3 - (1)] = (inode - (1)) * (3) + 3;\n        elauu[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))] = _mm_add_pd( elauu[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))], fact[2 - (1)] );\n
      \       elrbu[1 - (1) + (3) * (inode - (1))] = _mm_sub_pd( elrbu[1 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpveo[1 - (1)] ) );\n        elrbu[1
      - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[1 - (1) + (3) * (inode - (1))],
      _mm_mul_pd( fact[2 - (1)], elvel[1 - (1) + (3) * (inode - (1) + (pnode) * (2
      - (1)))] ) );\n        elrbu[2 - (1) + (3) * (inode - (1))] = _mm_sub_pd( elrbu[2
      - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpveo[2 - (1)] ) );\n
      \       elrbu[2 - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[2 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[2 - (1) + (3) * (inode -
      (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[3 - (1) + (3) * (inode - (1))]
      = _mm_sub_pd( elrbu[3 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)],
      gpveo[3 - (1)] ) );\n        elrbu[3 - (1) + (3) * (inode - (1))] = _mm_add_pd(
      elrbu[3 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[3 - (1)
      + (3) * (inode - (1) + (pnode) * (2 - (1)))] ) );\n        for (jnode = 1; jnode
      <= pnode; jnode += 1) {\n          jdof[1 - (1)] = (jnode - (1)) * (3) + 1;\n
      \         elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)] - (1))]
      = _mm_sub_pd( elauu[idof[1 - (1)] - (1) + ((pnode) * (3)) * (jdof[1 - (1)] -
      (1))], _mm_mul_pd( fact[2 - (1)], gpsha[jnode - (1) + (pnode) * (igaus - (1))]
      ) );\n          jdof[2 - (1)] = (jnode - (1)) * (3) + 2;\n          elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (jdof[2 - (1)] - (1))] = _mm_sub_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (jdof[2 - (1)] - (1))], _mm_mul_pd( fact[2
      - (1)], gpsha[jnode - (1) + (pnode) * (igaus - (1))] ) );\n          jdof[3
      - (1)] = (jnode - (1)) * (3) + 3;\n          elauu[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[3 - (1)] - (1))] = _mm_sub_pd( elauu[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (jdof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpsha[jnode - (1)
      + (pnode) * (igaus - (1))] ) );\n        }\n      }\n    }\n  } else if (kfl_lumped
      == 2) {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n      fact[1 - (1)]
      = _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpden[igaus - (1)] ), dtinv_mod[1
      - (1)] );\n      for (inode = 1; inode <= pnode; inode += 1) {\n        fact[2
      - (1)] = _mm_mul_pd( fact[1 - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))]
      );\n        idof[1 - (1)] = (inode - (1)) * (3) + 1;\n        elauu[idof[1 -
      (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))] = _mm_add_pd( elauu[idof[1
      - (1)] - (1) + ((pnode) * (3)) * (idof[1 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[2 - (1)] = (inode - (1)) * (3) + 2;\n        elauu[idof[2 - (1)]
      - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))] = _mm_add_pd( elauu[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (idof[2 - (1)] - (1))], fact[2 - (1)] );\n
      \       idof[3 - (1)] = (inode - (1)) * (3) + 3;\n        elauu[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))] = _mm_add_pd( elauu[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (idof[3 - (1)] - (1))], fact[2 - (1)] );\n
      \       elrbu[1 - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[1 - (1) + (3)
      * (inode - (1))], _mm_mul_pd( fact[2 - (1)], elvel[1 - (1) + (3) * (inode -
      (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[2 - (1) + (3) * (inode - (1))]
      = _mm_add_pd( elrbu[2 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)],
      elvel[2 - (1) + (3) * (inode - (1) + (pnode) * (2 - (1)))] ) );\n        elrbu[3
      - (1) + (3) * (inode - (1))] = _mm_add_pd( elrbu[3 - (1) + (3) * (inode - (1))],
      _mm_mul_pd( fact[2 - (1)], elvel[3 - (1) + (3) * (inode - (1) + (pnode) * (2
      - (1)))] ) );\n      }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest4(pgaus,
      pnode, gpvol, gpden, dtinv_mod, gpsha, elvel, kfl_lumped, gpveo, elrbu, elauu);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 5
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  for (igaus
      = 1; igaus <= pgaus; igaus += 1) {\n    for (inode = 1; inode <= pnode; inode
      += 1) {\n      idof[1 - (1)] = (inode - (1)) * (3) + 1;\n      idof[2 - (1)]
      = (inode - (1)) * (3) + 2;\n      idof[3 - (1)] = (inode - (1)) * (3) + 3;\n
      \     for (jnode = 1; jnode <= pnode; jnode += 1) {\n        fact[1 - (1)] =
      _mm_mul_pd( gpvol[igaus - (1)], gpsha[jnode - (1) + (pnode) * (igaus - (1))]
      );\n        fact[1 + 1 - (1)] = _mm_mul_pd( fact[1 - (1)], gpcar[1 - (1) + (3)
      * (inode - (1) + (mnode) * (igaus - (1)))] );\n        elapu[jnode - (1) + (pnode)
      * (idof[1 - (1)] - (1))] = _mm_add_pd( elapu[jnode - (1) + (pnode) * (idof[1
      - (1)] - (1))], fact[1 + 1 - (1)] );\n        fact[2 + 1 - (1)] = _mm_mul_pd(
      fact[1 - (1)], gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      );\n        elapu[jnode - (1) + (pnode) * (idof[2 - (1)] - (1))] = _mm_add_pd(
      elapu[jnode - (1) + (pnode) * (idof[2 - (1)] - (1))], fact[2 + 1 - (1)] );\n
      \       fact[3 + 1 - (1)] = _mm_mul_pd( fact[1 - (1)], gpcar[3 - (1) + (3) *
      (inode - (1) + (mnode) * (igaus - (1)))] );\n        elapu[jnode - (1) + (pnode)
      * (idof[3 - (1)] - (1))] = _mm_add_pd( elapu[jnode - (1) + (pnode) * (idof[3
      - (1)] - (1))], fact[3 + 1 - (1)] );\n        elaup[idof[1 - (1)] - (1) + ((pnode)
      * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[1 - (1)] - (1) + ((pnode) *
      (3)) * (jnode - (1))], fact[1 + 1 - (1)] );\n        elaup[idof[2 - (1)] - (1)
      + ((pnode) * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[2 - (1)] - (1) +
      ((pnode) * (3)) * (jnode - (1))], fact[2 + 1 - (1)] );\n        elaup[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[3 -
      (1)] - (1) + ((pnode) * (3)) * (jnode - (1))], fact[3 + 1 - (1)] );\n      }\n
      \   }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 5
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest5(const int32_t mnode, const int32_t
      pgaus, const int32_t pnode, const __m128d * gpvol, const __m128d * gpsha, const
      __m128d * gpcar, __m128d * elapu, __m128d * elaup){\n  int32_t igaus;\n  int32_t
      inode;\n  int32_t jnode;\n  int32_t idime;\n  int32_t jdime;\n  int32_t idof[(3)];\n
      \ __m128d fact[(9)];\n  for (igaus = 1; igaus <= pgaus; igaus += 1) {\n    for
      (inode = 1; inode <= pnode; inode += 1) {\n      idof[1 - (1)] = (inode - (1))
      * (3) + 1;\n      idof[2 - (1)] = (inode - (1)) * (3) + 2;\n      idof[3 - (1)]
      = (inode - (1)) * (3) + 3;\n      for (jnode = 1; jnode <= pnode; jnode += 1)
      {\n        fact[1 - (1)] = _mm_mul_pd( gpvol[igaus - (1)], gpsha[jnode - (1)
      + (pnode) * (igaus - (1))] );\n        fact[1 + 1 - (1)] = _mm_mul_pd( fact[1
      - (1)], gpcar[1 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n
      \       elapu[jnode - (1) + (pnode) * (idof[1 - (1)] - (1))] = _mm_add_pd( elapu[jnode
      - (1) + (pnode) * (idof[1 - (1)] - (1))], fact[1 + 1 - (1)] );\n        fact[2
      + 1 - (1)] = _mm_mul_pd( fact[1 - (1)], gpcar[2 - (1) + (3) * (inode - (1) +
      (mnode) * (igaus - (1)))] );\n        elapu[jnode - (1) + (pnode) * (idof[2
      - (1)] - (1))] = _mm_add_pd( elapu[jnode - (1) + (pnode) * (idof[2 - (1)] -
      (1))], fact[2 + 1 - (1)] );\n        fact[3 + 1 - (1)] = _mm_mul_pd( fact[1
      - (1)], gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n
      \       elapu[jnode - (1) + (pnode) * (idof[3 - (1)] - (1))] = _mm_add_pd( elapu[jnode
      - (1) + (pnode) * (idof[3 - (1)] - (1))], fact[3 + 1 - (1)] );\n        elaup[idof[1
      - (1)] - (1) + ((pnode) * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[1 -
      (1)] - (1) + ((pnode) * (3)) * (jnode - (1))], fact[1 + 1 - (1)] );\n        elaup[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[2 -
      (1)] - (1) + ((pnode) * (3)) * (jnode - (1))], fact[2 + 1 - (1)] );\n        elaup[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[3 -
      (1)] - (1) + ((pnode) * (3)) * (jnode - (1))], fact[3 + 1 - (1)] );\n      }\n
      \   }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t kfl_lumped,
      const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss, const int32_t
      fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi, const double
      fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi, const double
      * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi, const
      int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest5(mnode,
      pgaus, pnode, gpvol, gpsha, gpcar, elapu, elaup);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 5
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest5(const int32_t mnode, const int32_t pgaus,
      const int32_t pnode, const __m128d * gpvol, const __m128d * gpsha, const __m128d
      * gpcar, __m128d * elapu, __m128d * elaup){\n  int32_t igaus;\n  int32_t inode;\n
      \ int32_t jnode;\n  int32_t idime;\n  int32_t jdime;\n  int32_t idof[(3)];\n
      \ __m128d fact[(9)];\n  for (igaus = 1; igaus <= pgaus; igaus += 1) {\n    for
      (inode = 1; inode <= pnode; inode += 1) {\n      idof[1 - (1)] = (inode - (1))
      * (3) + 1;\n      idof[2 - (1)] = (inode - (1)) * (3) + 2;\n      idof[3 - (1)]
      = (inode - (1)) * (3) + 3;\n      for (jnode = 1; jnode <= pnode; jnode += 1)
      {\n        fact[1 - (1)] = _mm_mul_pd( gpvol[igaus - (1)], gpsha[jnode - (1)
      + (pnode) * (igaus - (1))] );\n        fact[1 + 1 - (1)] = _mm_mul_pd( fact[1
      - (1)], gpcar[1 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n
      \       elapu[jnode - (1) + (pnode) * (idof[1 - (1)] - (1))] = _mm_add_pd( elapu[jnode
      - (1) + (pnode) * (idof[1 - (1)] - (1))], fact[1 + 1 - (1)] );\n        fact[2
      + 1 - (1)] = _mm_mul_pd( fact[1 - (1)], gpcar[2 - (1) + (3) * (inode - (1) +
      (mnode) * (igaus - (1)))] );\n        elapu[jnode - (1) + (pnode) * (idof[2
      - (1)] - (1))] = _mm_add_pd( elapu[jnode - (1) + (pnode) * (idof[2 - (1)] -
      (1))], fact[2 + 1 - (1)] );\n        fact[3 + 1 - (1)] = _mm_mul_pd( fact[1
      - (1)], gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] );\n
      \       elapu[jnode - (1) + (pnode) * (idof[3 - (1)] - (1))] = _mm_add_pd( elapu[jnode
      - (1) + (pnode) * (idof[3 - (1)] - (1))], fact[3 + 1 - (1)] );\n        elaup[idof[1
      - (1)] - (1) + ((pnode) * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[1 -
      (1)] - (1) + ((pnode) * (3)) * (jnode - (1))], fact[1 + 1 - (1)] );\n        elaup[idof[2
      - (1)] - (1) + ((pnode) * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[2 -
      (1)] - (1) + ((pnode) * (3)) * (jnode - (1))], fact[2 + 1 - (1)] );\n        elaup[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (jnode - (1))] = _mm_sub_pd( elaup[idof[3 -
      (1)] - (1) + ((pnode) * (3)) * (jnode - (1))], fact[3 + 1 - (1)] );\n      }\n
      \   }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t kfl_lumped,
      const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss, const int32_t
      fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi, const double
      fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi, const double
      * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi, const
      int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest5(mnode,
      pgaus, pnode, gpvol, gpsha, gpcar, elapu, elaup);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 6
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  if (kfl_stabi_nsi
      != -1) {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n      for (inode
      = 1; inode <= pnode; inode += 1) {\n        for (jnode = inode + 1; jnode <=
      pnode; jnode += 1) {\n          fact[2 - (1)] = _mm_mul_pd( _mm_mul_pd( gpsp1_p[igaus
      - (1)], wgrgr[jnode - (1) + (pnode) * (inode - (1) + (pnode) * (igaus - (1)))]
      ), gpvol[igaus - (1)] );\n          elapp[jnode - (1) + (pnode) * (inode - (1))]
      = _mm_add_pd( elapp[jnode - (1) + (pnode) * (inode - (1))], fact[2 - (1)] );\n
      \         elapp[inode - (1) + (pnode) * (jnode - (1))] = _mm_add_pd( elapp[inode
      - (1) + (pnode) * (jnode - (1))], fact[2 - (1)] );\n        }\n        fact[2
      - (1)] = _mm_mul_pd( _mm_mul_pd( gpsp1_p[igaus - (1)], wgrgr[inode - (1) + (pnode)
      * (inode - (1) + (pnode) * (igaus - (1)))] ), gpvol[igaus - (1)] );\n        elapp[inode
      - (1) + (pnode) * (inode - (1))] = _mm_add_pd( elapp[inode - (1) + (pnode) *
      (inode - (1))], fact[2 - (1)] );\n      }\n    }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 6
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest6(const int32_t kfl_stabi_nsi, const
      int32_t pgaus, const int32_t pnode, __m128d gpsp1_p[(pgaus)], __m128d * wgrgr,
      const __m128d * gpvol, __m128d * elapp){\n  int32_t igaus;\n  int32_t inode;\n
      \ int32_t jnode;\n  __m128d fact[(9)];\n  if (kfl_stabi_nsi != -1) {\n    for
      (igaus = 1; igaus <= pgaus; igaus += 1) {\n      for (inode = 1; inode <= pnode;
      inode += 1) {\n        for (jnode = inode + 1; jnode <= pnode; jnode += 1) {\n
      \         fact[2 - (1)] = _mm_mul_pd( _mm_mul_pd( gpsp1_p[igaus - (1)], wgrgr[jnode
      - (1) + (pnode) * (inode - (1) + (pnode) * (igaus - (1)))] ), gpvol[igaus -
      (1)] );\n          elapp[jnode - (1) + (pnode) * (inode - (1))] = _mm_add_pd(
      elapp[jnode - (1) + (pnode) * (inode - (1))], fact[2 - (1)] );\n          elapp[inode
      - (1) + (pnode) * (jnode - (1))] = _mm_add_pd( elapp[inode - (1) + (pnode) *
      (jnode - (1))], fact[2 - (1)] );\n        }\n        fact[2 - (1)] = _mm_mul_pd(
      _mm_mul_pd( gpsp1_p[igaus - (1)], wgrgr[inode - (1) + (pnode) * (inode - (1)
      + (pnode) * (igaus - (1)))] ), gpvol[igaus - (1)] );\n        elapp[inode -
      (1) + (pnode) * (inode - (1))] = _mm_add_pd( elapp[inode - (1) + (pnode) * (inode
      - (1))], fact[2 - (1)] );\n      }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest6(kfl_stabi_nsi,
      pgaus, pnode, gpsp1_p, wgrgr, gpvol, elapp);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 6
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest6(const int32_t kfl_stabi_nsi, const int32_t
      pgaus, const int32_t pnode, __m128d gpsp1_p[(pgaus)], __m128d * wgrgr, const
      __m128d * gpvol, __m128d * elapp){\n  int32_t igaus;\n  int32_t inode;\n  int32_t
      jnode;\n  __m128d fact[(9)];\n  if (kfl_stabi_nsi != -1) {\n    for (igaus =
      1; igaus <= pgaus; igaus += 1) {\n      for (inode = 1; inode <= pnode; inode
      += 1) {\n        for (jnode = inode + 1; jnode <= pnode; jnode += 1) {\n          fact[2
      - (1)] = _mm_mul_pd( _mm_mul_pd( gpsp1_p[igaus - (1)], wgrgr[jnode - (1) + (pnode)
      * (inode - (1) + (pnode) * (igaus - (1)))] ), gpvol[igaus - (1)] );\n          elapp[jnode
      - (1) + (pnode) * (inode - (1))] = _mm_add_pd( elapp[jnode - (1) + (pnode) *
      (inode - (1))], fact[2 - (1)] );\n          elapp[inode - (1) + (pnode) * (jnode
      - (1))] = _mm_add_pd( elapp[inode - (1) + (pnode) * (jnode - (1))], fact[2 -
      (1)] );\n        }\n        fact[2 - (1)] = _mm_mul_pd( _mm_mul_pd( gpsp1_p[igaus
      - (1)], wgrgr[inode - (1) + (pnode) * (inode - (1) + (pnode) * (igaus - (1)))]
      ), gpvol[igaus - (1)] );\n        elapp[inode - (1) + (pnode) * (inode - (1))]
      = _mm_add_pd( elapp[inode - (1) + (pnode) * (inode - (1))], fact[2 - (1)] );\n
      \     }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t
      kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss,
      const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi,
      const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest6(kfl_stabi_nsi,
      pgaus, pnode, gpsp1_p, wgrgr, gpvol, elapp);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 7
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  for (igaus
      = 1; igaus <= pgaus; igaus += 1) {\n    fact[2 - (1)] = _mm_mul_pd( _mm_set1_pd(
      penal_nsi ), gpvol[igaus - (1)] );\n    for (inode = 1; inode <= pnode; inode
      += 1) {\n      elapp[inode - (1) + (pnode) * (inode - (1))] = _mm_add_pd( elapp[inode
      - (1) + (pnode) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpsha[inode - (1)
      + (pnode) * (igaus - (1))] ) );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode
      - (1)], _mm_mul_pd( _mm_mul_pd( fact[2 - (1)], gpsha[inode - (1) + (pnode) *
      (igaus - (1))] ), elpre[inode - (1) + (pnode) * (1 - (1))] ) );\n    }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 7
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest7(const int32_t pnode, const int32_t
      pgaus, const double penal_nsi, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * elpre, __m128d * elapp, __m128d * elrbp){\n  __m128d fact[(9)];\n
      \ int32_t igaus;\n  int32_t inode;\n  for (igaus = 1; igaus <= pgaus; igaus
      += 1) {\n    fact[2 - (1)] = _mm_mul_pd( _mm_set1_pd( penal_nsi ), gpvol[igaus
      - (1)] );\n    for (inode = 1; inode <= pnode; inode += 1) {\n      elapp[inode
      - (1) + (pnode) * (inode - (1))] = _mm_add_pd( elapp[inode - (1) + (pnode) *
      (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpsha[inode - (1) + (pnode) * (igaus
      - (1))] ) );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd(
      _mm_mul_pd( fact[2 - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))] ), elpre[inode
      - (1) + (pnode) * (1 - (1))] ) );\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest7(pnode,
      pgaus, penal_nsi, gpvol, gpsha, elpre, elapp, elrbp);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 7
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest7(const int32_t pnode, const int32_t pgaus,
      const double penal_nsi, const __m128d * gpvol, const __m128d * gpsha, const
      __m128d * elpre, __m128d * elapp, __m128d * elrbp){\n  __m128d fact[(9)];\n
      \ int32_t igaus;\n  int32_t inode;\n  for (igaus = 1; igaus <= pgaus; igaus
      += 1) {\n    fact[2 - (1)] = _mm_mul_pd( _mm_set1_pd( penal_nsi ), gpvol[igaus
      - (1)] );\n    for (inode = 1; inode <= pnode; inode += 1) {\n      elapp[inode
      - (1) + (pnode) * (inode - (1))] = _mm_add_pd( elapp[inode - (1) + (pnode) *
      (inode - (1))], _mm_mul_pd( fact[2 - (1)], gpsha[inode - (1) + (pnode) * (igaus
      - (1))] ) );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd(
      _mm_mul_pd( fact[2 - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))] ), elpre[inode
      - (1) + (pnode) * (1 - (1))] ) );\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest7(pnode,
      pgaus, penal_nsi, gpvol, gpsha, elpre, elapp, elrbp);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 8
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  if (kfl_stabi_nsi
      == -1) {\n                memset(gpvep,0,sizeof(__m128d) * 3 * pgaus);\n  }
      else if (kfl_limit_nsi == -1) {\n                memset(gpvep,0,sizeof(__m128d)
      * 3 * pgaus);\n  } else if (kfl_limit_nsi > 0) {\n    for (igaus = 1; igaus
      <= pgaus; igaus += 1) {\n                  memset(c1,0,sizeof(c1));\n                  memset(c2,0,sizeof(c2));\n
      \                 memset(c3,0,sizeof(c3));\n      for (idime = 1; idime <= 3;
      idime += 1) {\n                    memset(c4,0,sizeof(c4));\n        for (inode
      = 1; inode <= pnode; inode += 1) {\n          c4[1 - (1)] = _mm_add_pd( c4[1
      - (1)], _mm_mul_pd( agrau[inode - (1) + (pnode) * (igaus - (1))], elvel[idime
      - (1) + (3) * (inode - (1) + (pnode) * (1 - (1)))] ) );\n        }\n        c4[1
      - (1)] = _mm_mul_pd( gpsp1[igaus - (1)], c4[1 - (1)] );\n        c1[1 - (1)]
      = _mm_add_pd( c1[1 - (1)], _mm_mul_pd( _mm_sub_pd( gpvep[idime - (1) + (3) *
      (igaus - (1))], c4[1 - (1)] ), _mm_sub_pd( gpvep[idime - (1) + (3) * (igaus
      - (1))], c4[1 - (1)] ) ) );\n        c3[1 - (1)] = _mm_add_pd( c3[1 - (1)],
      _mm_mul_pd( gpvep[idime - (1) + (3) * (igaus - (1))], gpvep[idime - (1) + (3)
      * (igaus - (1))] ) );\n        c2[1 - (1)] = _mm_add_pd( c2[1 - (1)], _mm_mul_pd(
      c4[1 - (1)], c4[1 - (1)] ) );\n      }\n      c3[1 - (1)] = _mm_add_pd( _mm_sqrt_pd(
      c2[1 - (1)] ), _mm_sqrt_pd( c3[1 - (1)] ) );\n      c1[1 - (1)] = _mm_sqrt_pd(
      c1[1 - (1)] );\n                  beta[0] = c1[0] / ( c3[0] + DBL_EPSILON );\n
      \     if (kfl_limit_nsi == 1) {\n        alpha[1 - (1)] = Min(_mm_set1_pd( 1.0
      ), _mm_mul_pd( _mm_set1_pd( 2.0 ), _mm_sub_pd( _mm_set1_pd( 1.0 ), beta[1 -
      (1)] ) ));\n      } else if (kfl_limit_nsi == 2) {\n        alpha[1 - (1)] =
      _mm_mul_pd( _mm_set1_pd( 0.5 ), _mm_add_pd( Tanh(_mm_mul_pd( _mm_set1_pd( 20.0
      ), _mm_sub_pd( beta[1 - (1)], _mm_set1_pd( 0.8 ) ) )), _mm_set1_pd( 1.0 ) )
      );\n      }\n      for (idime = 1; idime <= 3; idime += 1) {\n        gpvep[idime
      - (1) + (3) * (igaus - (1))] = _mm_mul_pd( alpha[1 - (1)], gpvep[idime - (1)
      + (3) * (igaus - (1))] );\n      }\n    }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 8
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest8(const int32_t pgaus, const int32_t
      pnode, const __m128d * elvel, __m128d * agrau, const __m128d * gpsp1, const
      int32_t kfl_limit_nsi, const int32_t kfl_stabi_nsi, __m128d * gpvep){\n  int32_t
      igaus;\n  int32_t idime;\n  int32_t inode;\n  __m128d c1[(1)];\n  __m128d c2[(1)];\n
      \ __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d beta[(1)];\n  __m128d alpha[(1)];\n
      \ if (kfl_stabi_nsi == -1) {\n                memset(gpvep,0,sizeof(__m128d)
      * 3 * pgaus);\n  } else if (kfl_limit_nsi == -1) {\n                memset(gpvep,0,sizeof(__m128d)
      * 3 * pgaus);\n  } else if (kfl_limit_nsi > 0) {\n    for (igaus = 1; igaus
      <= pgaus; igaus += 1) {\n                  memset(c1,0,sizeof(c1));\n                  memset(c2,0,sizeof(c2));\n
      \                 memset(c3,0,sizeof(c3));\n      for (idime = 1; idime <= 3;
      idime += 1) {\n                    memset(c4,0,sizeof(c4));\n        for (inode
      = 1; inode <= pnode; inode += 1) {\n          c4[1 - (1)] = _mm_add_pd( c4[1
      - (1)], _mm_mul_pd( agrau[inode - (1) + (pnode) * (igaus - (1))], elvel[idime
      - (1) + (3) * (inode - (1) + (pnode) * (1 - (1)))] ) );\n        }\n        c4[1
      - (1)] = _mm_mul_pd( gpsp1[igaus - (1)], c4[1 - (1)] );\n        c1[1 - (1)]
      = _mm_add_pd( c1[1 - (1)], _mm_mul_pd( _mm_sub_pd( gpvep[idime - (1) + (3) *
      (igaus - (1))], c4[1 - (1)] ), _mm_sub_pd( gpvep[idime - (1) + (3) * (igaus
      - (1))], c4[1 - (1)] ) ) );\n        c3[1 - (1)] = _mm_add_pd( c3[1 - (1)],
      _mm_mul_pd( gpvep[idime - (1) + (3) * (igaus - (1))], gpvep[idime - (1) + (3)
      * (igaus - (1))] ) );\n        c2[1 - (1)] = _mm_add_pd( c2[1 - (1)], _mm_mul_pd(
      c4[1 - (1)], c4[1 - (1)] ) );\n      }\n      c3[1 - (1)] = _mm_add_pd( _mm_sqrt_pd(
      c2[1 - (1)] ), _mm_sqrt_pd( c3[1 - (1)] ) );\n      c1[1 - (1)] = _mm_sqrt_pd(
      c1[1 - (1)] );\n                  beta[0] = c1[0] / ( c3[0] + DBL_EPSILON );\n
      \     if (kfl_limit_nsi == 1) {\n        alpha[1 - (1)] = Min(_mm_set1_pd( 1.0
      ), _mm_mul_pd( _mm_set1_pd( 2.0 ), _mm_sub_pd( _mm_set1_pd( 1.0 ), beta[1 -
      (1)] ) ));\n      } else if (kfl_limit_nsi == 2) {\n        alpha[1 - (1)] =
      _mm_mul_pd( _mm_set1_pd( 0.5 ), _mm_add_pd( Tanh(_mm_mul_pd( _mm_set1_pd( 20.0
      ), _mm_sub_pd( beta[1 - (1)], _mm_set1_pd( 0.8 ) ) )), _mm_set1_pd( 1.0 ) )
      );\n      }\n      for (idime = 1; idime <= 3; idime += 1) {\n        gpvep[idime
      - (1) + (3) * (igaus - (1))] = _mm_mul_pd( alpha[1 - (1)], gpvep[idime - (1)
      + (3) * (igaus - (1))] );\n      }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest8(pgaus,
      pnode, elvel, agrau, gpsp1, kfl_limit_nsi, kfl_stabi_nsi, gpvep);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 8
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest8(const int32_t pgaus, const int32_t pnode,
      const __m128d * elvel, __m128d * agrau, const __m128d * gpsp1, const int32_t
      kfl_limit_nsi, const int32_t kfl_stabi_nsi, __m128d * gpvep){\n  int32_t igaus;\n
      \ int32_t idime;\n  int32_t inode;\n  __m128d c1[(1)];\n  __m128d c2[(1)];\n
      \ __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d beta[(1)];\n  __m128d alpha[(1)];\n
      \ if (kfl_stabi_nsi == -1) {\n                memset(gpvep,0,sizeof(__m128d)
      * 3 * pgaus);\n  } else if (kfl_limit_nsi == -1) {\n                memset(gpvep,0,sizeof(__m128d)
      * 3 * pgaus);\n  } else if (kfl_limit_nsi > 0) {\n    for (igaus = 1; igaus
      <= pgaus; igaus += 1) {\n                  memset(c1,0,sizeof(c1));\n                  memset(c2,0,sizeof(c2));\n
      \                 memset(c3,0,sizeof(c3));\n      for (idime = 1; idime <= 3;
      idime += 1) {\n                    memset(c4,0,sizeof(c4));\n        for (inode
      = 1; inode <= pnode; inode += 1) {\n          c4[1 - (1)] = _mm_add_pd( c4[1
      - (1)], _mm_mul_pd( agrau[inode - (1) + (pnode) * (igaus - (1))], elvel[idime
      - (1) + (3) * (inode - (1) + (pnode) * (1 - (1)))] ) );\n        }\n        c4[1
      - (1)] = _mm_mul_pd( gpsp1[igaus - (1)], c4[1 - (1)] );\n        c1[1 - (1)]
      = _mm_add_pd( c1[1 - (1)], _mm_mul_pd( _mm_sub_pd( gpvep[idime - (1) + (3) *
      (igaus - (1))], c4[1 - (1)] ), _mm_sub_pd( gpvep[idime - (1) + (3) * (igaus
      - (1))], c4[1 - (1)] ) ) );\n        c3[1 - (1)] = _mm_add_pd( c3[1 - (1)],
      _mm_mul_pd( gpvep[idime - (1) + (3) * (igaus - (1))], gpvep[idime - (1) + (3)
      * (igaus - (1))] ) );\n        c2[1 - (1)] = _mm_add_pd( c2[1 - (1)], _mm_mul_pd(
      c4[1 - (1)], c4[1 - (1)] ) );\n      }\n      c3[1 - (1)] = _mm_add_pd( _mm_sqrt_pd(
      c2[1 - (1)] ), _mm_sqrt_pd( c3[1 - (1)] ) );\n      c1[1 - (1)] = _mm_sqrt_pd(
      c1[1 - (1)] );\n                  beta[0] = c1[0] / ( c3[0] + DBL_EPSILON );\n
      \     if (kfl_limit_nsi == 1) {\n        alpha[1 - (1)] = Min(_mm_set1_pd( 1.0
      ), _mm_mul_pd( _mm_set1_pd( 2.0 ), _mm_sub_pd( _mm_set1_pd( 1.0 ), beta[1 -
      (1)] ) ));\n      } else if (kfl_limit_nsi == 2) {\n        alpha[1 - (1)] =
      _mm_mul_pd( _mm_set1_pd( 0.5 ), _mm_add_pd( Tanh(_mm_mul_pd( _mm_set1_pd( 20.0
      ), _mm_sub_pd( beta[1 - (1)], _mm_set1_pd( 0.8 ) ) )), _mm_set1_pd( 1.0 ) )
      );\n      }\n      for (idime = 1; idime <= 3; idime += 1) {\n        gpvep[idime
      - (1) + (3) * (igaus - (1))] = _mm_mul_pd( alpha[1 - (1)], gpvep[idime - (1)
      + (3) * (igaus - (1))] );\n      }\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest8(pgaus,
      pnode, elvel, agrau, gpsp1, kfl_limit_nsi, kfl_stabi_nsi, gpvep);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 9
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  if (kfl_stabi_nsi
      == -1) {\n                          memset(gpgrp,0,sizeof(__m128d) * 3 * pgaus);\n
      \ } else {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n      gpgrp[1
      - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[1 - (1) + (3) * (igaus - (1))],
      _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[1 - (1) + (3) * (igaus - (1))] ) );\n
      \     gpgrp[2 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[2 - (1) + (3)
      * (igaus - (1))], _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[2 - (1) + (3) * (igaus
      - (1))] ) );\n      gpgrp[3 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[3
      - (1) + (3) * (igaus - (1))], _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[3 - (1)
      + (3) * (igaus - (1))] ) );\n    }\n    if (kfl_sgsti_nsi == 1) {\n      for
      (igaus = 1; igaus <= pgaus; igaus += 1) {\n        fact[2 - (1)] = _mm_mul_pd(
      _mm_mul_pd( gpden[igaus - (1)], dtsgs[1 - (1)] ), gpsp1_v[igaus - (1)] );\n
      \       fact1_p[1 - (1)] = _mm_mul_pd( _mm_mul_pd( gpden[igaus - (1)], dtsgs[1
      - (1)] ), gpsp1_p[igaus - (1)] );\n        gpvep[1 - (1) + (3) * (igaus - (1))]
      = _mm_add_pd( gpvep[1 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)],
      gpsgs[1 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[1
      - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[1 - (1) + (3) * (igaus - (1))],
      _mm_mul_pd( fact1_p[1 - (1)], gpsgs[1 - (1) + (3) * (igaus - (1) + (pgaus) *
      (2 - (1)))] ) );\n        gpvep[2 - (1) + (3) * (igaus - (1))] = _mm_add_pd(
      gpvep[2 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)], gpsgs[2 - (1)
      + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[2 - (1) + (3)
      * (igaus - (1))] = _mm_add_pd( gpgrp[2 - (1) + (3) * (igaus - (1))], _mm_mul_pd(
      fact1_p[1 - (1)], gpsgs[2 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))]
      ) );\n        gpvep[3 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpvep[3 - (1)
      + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)], gpsgs[3 - (1) + (3) * (igaus
      - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[3 - (1) + (3) * (igaus - (1))]
      = _mm_add_pd( gpgrp[3 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact1_p[1 -
      (1)], gpsgs[3 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n      }\n
      \   }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 9
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest9(const int32_t pgaus, __m128d gpsp1_p[(pgaus)],
      __m128d * gprhs, const __m128d * gpden, const __m128d * dtsgs, __m128d gpsp1_v[(pgaus)],
      const __m128d * gpsgs, const int32_t kfl_sgsti_nsi, const int32_t kfl_stabi_nsi,
      __m128d * gpgrp, __m128d * gpvep){\n  int32_t igaus;\n  int32_t idime;\n  __m128d
      fact[(9)];\n  __m128d fact1_p[(1)];\n  if (kfl_stabi_nsi == -1) {\n                          memset(gpgrp,0,sizeof(__m128d)
      * 3 * pgaus);\n  } else {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n
      \     gpgrp[1 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[1 - (1) + (3)
      * (igaus - (1))], _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[1 - (1) + (3) * (igaus
      - (1))] ) );\n      gpgrp[2 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[2
      - (1) + (3) * (igaus - (1))], _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[2 - (1)
      + (3) * (igaus - (1))] ) );\n      gpgrp[3 - (1) + (3) * (igaus - (1))] = _mm_add_pd(
      gpgrp[3 - (1) + (3) * (igaus - (1))], _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[3
      - (1) + (3) * (igaus - (1))] ) );\n    }\n    if (kfl_sgsti_nsi == 1) {\n      for
      (igaus = 1; igaus <= pgaus; igaus += 1) {\n        fact[2 - (1)] = _mm_mul_pd(
      _mm_mul_pd( gpden[igaus - (1)], dtsgs[1 - (1)] ), gpsp1_v[igaus - (1)] );\n
      \       fact1_p[1 - (1)] = _mm_mul_pd( _mm_mul_pd( gpden[igaus - (1)], dtsgs[1
      - (1)] ), gpsp1_p[igaus - (1)] );\n        gpvep[1 - (1) + (3) * (igaus - (1))]
      = _mm_add_pd( gpvep[1 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)],
      gpsgs[1 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[1
      - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[1 - (1) + (3) * (igaus - (1))],
      _mm_mul_pd( fact1_p[1 - (1)], gpsgs[1 - (1) + (3) * (igaus - (1) + (pgaus) *
      (2 - (1)))] ) );\n        gpvep[2 - (1) + (3) * (igaus - (1))] = _mm_add_pd(
      gpvep[2 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)], gpsgs[2 - (1)
      + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[2 - (1) + (3)
      * (igaus - (1))] = _mm_add_pd( gpgrp[2 - (1) + (3) * (igaus - (1))], _mm_mul_pd(
      fact1_p[1 - (1)], gpsgs[2 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))]
      ) );\n        gpvep[3 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpvep[3 - (1)
      + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)], gpsgs[3 - (1) + (3) * (igaus
      - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[3 - (1) + (3) * (igaus - (1))]
      = _mm_add_pd( gpgrp[3 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact1_p[1 -
      (1)], gpsgs[3 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n      }\n
      \   }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t kfl_lumped,
      const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss, const int32_t
      fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi, const double
      fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi, const double
      * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi, const
      int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest9(pgaus,
      gpsp1_p, gprhs, gpden, dtsgs, gpsp1_v, gpsgs, kfl_sgsti_nsi, kfl_stabi_nsi,
      gpgrp, gpvep);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 9
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest9(const int32_t pgaus, __m128d gpsp1_p[(pgaus)],
      __m128d * gprhs, const __m128d * gpden, const __m128d * dtsgs, __m128d gpsp1_v[(pgaus)],
      const __m128d * gpsgs, const int32_t kfl_sgsti_nsi, const int32_t kfl_stabi_nsi,
      __m128d * gpgrp, __m128d * gpvep){\n  int32_t igaus;\n  int32_t idime;\n  __m128d
      fact[(9)];\n  __m128d fact1_p[(1)];\n  if (kfl_stabi_nsi == -1) {\n                          memset(gpgrp,0,sizeof(__m128d)
      * 3 * pgaus);\n  } else {\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n
      \     gpgrp[1 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[1 - (1) + (3)
      * (igaus - (1))], _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[1 - (1) + (3) * (igaus
      - (1))] ) );\n      gpgrp[2 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[2
      - (1) + (3) * (igaus - (1))], _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[2 - (1)
      + (3) * (igaus - (1))] ) );\n      gpgrp[3 - (1) + (3) * (igaus - (1))] = _mm_add_pd(
      gpgrp[3 - (1) + (3) * (igaus - (1))], _mm_mul_pd( gpsp1_p[igaus - (1)], gprhs[3
      - (1) + (3) * (igaus - (1))] ) );\n    }\n    if (kfl_sgsti_nsi == 1) {\n      for
      (igaus = 1; igaus <= pgaus; igaus += 1) {\n        fact[2 - (1)] = _mm_mul_pd(
      _mm_mul_pd( gpden[igaus - (1)], dtsgs[1 - (1)] ), gpsp1_v[igaus - (1)] );\n
      \       fact1_p[1 - (1)] = _mm_mul_pd( _mm_mul_pd( gpden[igaus - (1)], dtsgs[1
      - (1)] ), gpsp1_p[igaus - (1)] );\n        gpvep[1 - (1) + (3) * (igaus - (1))]
      = _mm_add_pd( gpvep[1 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)],
      gpsgs[1 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[1
      - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpgrp[1 - (1) + (3) * (igaus - (1))],
      _mm_mul_pd( fact1_p[1 - (1)], gpsgs[1 - (1) + (3) * (igaus - (1) + (pgaus) *
      (2 - (1)))] ) );\n        gpvep[2 - (1) + (3) * (igaus - (1))] = _mm_add_pd(
      gpvep[2 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)], gpsgs[2 - (1)
      + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[2 - (1) + (3)
      * (igaus - (1))] = _mm_add_pd( gpgrp[2 - (1) + (3) * (igaus - (1))], _mm_mul_pd(
      fact1_p[1 - (1)], gpsgs[2 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))]
      ) );\n        gpvep[3 - (1) + (3) * (igaus - (1))] = _mm_add_pd( gpvep[3 - (1)
      + (3) * (igaus - (1))], _mm_mul_pd( fact[2 - (1)], gpsgs[3 - (1) + (3) * (igaus
      - (1) + (pgaus) * (2 - (1)))] ) );\n        gpgrp[3 - (1) + (3) * (igaus - (1))]
      = _mm_add_pd( gpgrp[3 - (1) + (3) * (igaus - (1))], _mm_mul_pd( fact1_p[1 -
      (1)], gpsgs[3 - (1) + (3) * (igaus - (1) + (pgaus) * (2 - (1)))] ) );\n      }\n
      \   }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t kfl_lumped,
      const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss, const int32_t
      fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi, const double
      fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi, const double
      * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi, const
      int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest9(pgaus,
      gpsp1_p, gprhs, gpden, dtsgs, gpsp1_v, gpsgs, kfl_sgsti_nsi, kfl_stabi_nsi,
      gpgrp, gpvep);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 10
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  for (igaus
      = 1; igaus <= pgaus; igaus += 1) {\n    fact[5 - (1)] = _mm_mul_pd( gpden[igaus
      - (1)], dtinv_mod[1 - (1)] );\n    for (itime = 2; itime <= nbdfp_nsi; itime
      += 1) {\n      gprhs[1 - (1) + (3) * (igaus - (1))] = _mm_sub_pd( gprhs[1 -
      (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd( _mm_set1_pd( pabdf_nsi(itime)
      ), fact[5 - (1)] ), gpvel[1 - (1) + (3) * (igaus - (1) + (pgaus) * (itime -
      (1)))] ) );\n      gprhs[2 - (1) + (3) * (igaus - (1))] = _mm_sub_pd( gprhs[2
      - (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd( _mm_set1_pd( pabdf_nsi(itime)
      ), fact[5 - (1)] ), gpvel[2 - (1) + (3) * (igaus - (1) + (pgaus) * (itime -
      (1)))] ) );\n      gprhs[3 - (1) + (3) * (igaus - (1))] = _mm_sub_pd( gprhs[3
      - (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd( _mm_set1_pd( pabdf_nsi(itime)
      ), fact[5 - (1)] ), gpvel[3 - (1) + (3) * (igaus - (1) + (pgaus) * (itime -
      (1)))] ) );\n    }\n    for (inode = 1; inode <= pnode; inode += 1) {\n      fact[2
      - (1)] = _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1) + (pnode) * (igaus
      - (1))] );\n      fact[4 - (1)] = _mm_mul_pd( gpvol[igaus - (1)], agrau[inode
      - (1) + (pnode) * (igaus - (1))] );\n      elrbu[1 - (1) + (3) * (inode - (1))]
      = _mm_add_pd( _mm_add_pd( elrbu[1 - (1) + (3) * (inode - (1))], _mm_mul_pd(
      fact[2 - (1)], gprhs[1 - (1) + (3) * (igaus - (1))] ) ), _mm_mul_pd( fact[4
      - (1)], gpvep[1 - (1) + (3) * (igaus - (1))] ) );\n      elrbu[2 - (1) + (3)
      * (inode - (1))] = _mm_add_pd( _mm_add_pd( elrbu[2 - (1) + (3) * (inode - (1))],
      _mm_mul_pd( fact[2 - (1)], gprhs[2 - (1) + (3) * (igaus - (1))] ) ), _mm_mul_pd(
      fact[4 - (1)], gpvep[2 - (1) + (3) * (igaus - (1))] ) );\n      elrbu[3 - (1)
      + (3) * (inode - (1))] = _mm_add_pd( _mm_add_pd( elrbu[3 - (1) + (3) * (inode
      - (1))], _mm_mul_pd( fact[2 - (1)], gprhs[3 - (1) + (3) * (igaus - (1))] ) ),
      _mm_mul_pd( fact[4 - (1)], gpvep[3 - (1) + (3) * (igaus - (1))] ) );\n      elrbp[inode
      - (1)] = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus
      - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))] ), gprhc[igaus - (1)] )
      );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd( _mm_mul_pd(
      gpvol[igaus - (1)], gpcar[1 - (1) + (3) * (inode - (1) + (mnode) * (igaus -
      (1)))] ), gpgrp[1 - (1) + (3) * (igaus - (1))] ) );\n      elrbp[inode - (1)]
      = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)],
      gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ), gpgrp[2 -
      (1) + (3) * (igaus - (1))] ) );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode
      - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpcar[3 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ), gpgrp[3 - (1) + (3) * (igaus - (1))] )
      );\n    }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 10
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest10(const int32_t mnode, const int32_t
      pgaus, const __m128d * gpden, __m128d dtinv_mod[(1)], const int32_t nbdfp_nsi,
      const __m128d * gpvel, const int32_t pnode, const __m128d * gpvol, const __m128d
      * gpsha, __m128d * agrau, __m128d * gprhc, const __m128d * gpcar, __m128d *
      gpvep, __m128d * gpgrp, __m128d * gprhs, __m128d * elrbu, __m128d * elrbp){\n
      \ int32_t igaus;\n  __m128d fact[(9)];\n  int32_t idime;\n  int32_t itime;\n
      \ int32_t inode;\n  for (igaus = 1; igaus <= pgaus; igaus += 1) {\n    fact[5
      - (1)] = _mm_mul_pd( gpden[igaus - (1)], dtinv_mod[1 - (1)] );\n    for (itime
      = 2; itime <= nbdfp_nsi; itime += 1) {\n      gprhs[1 - (1) + (3) * (igaus -
      (1))] = _mm_sub_pd( gprhs[1 - (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd(
      _mm_set1_pd( pabdf_nsi(itime) ), fact[5 - (1)] ), gpvel[1 - (1) + (3) * (igaus
      - (1) + (pgaus) * (itime - (1)))] ) );\n      gprhs[2 - (1) + (3) * (igaus -
      (1))] = _mm_sub_pd( gprhs[2 - (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd(
      _mm_set1_pd( pabdf_nsi(itime) ), fact[5 - (1)] ), gpvel[2 - (1) + (3) * (igaus
      - (1) + (pgaus) * (itime - (1)))] ) );\n      gprhs[3 - (1) + (3) * (igaus -
      (1))] = _mm_sub_pd( gprhs[3 - (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd(
      _mm_set1_pd( pabdf_nsi(itime) ), fact[5 - (1)] ), gpvel[3 - (1) + (3) * (igaus
      - (1) + (pgaus) * (itime - (1)))] ) );\n    }\n    for (inode = 1; inode <=
      pnode; inode += 1) {\n      fact[2 - (1)] = _mm_mul_pd( gpvol[igaus - (1)],
      gpsha[inode - (1) + (pnode) * (igaus - (1))] );\n      fact[4 - (1)] = _mm_mul_pd(
      gpvol[igaus - (1)], agrau[inode - (1) + (pnode) * (igaus - (1))] );\n      elrbu[1
      - (1) + (3) * (inode - (1))] = _mm_add_pd( _mm_add_pd( elrbu[1 - (1) + (3) *
      (inode - (1))], _mm_mul_pd( fact[2 - (1)], gprhs[1 - (1) + (3) * (igaus - (1))]
      ) ), _mm_mul_pd( fact[4 - (1)], gpvep[1 - (1) + (3) * (igaus - (1))] ) );\n
      \     elrbu[2 - (1) + (3) * (inode - (1))] = _mm_add_pd( _mm_add_pd( elrbu[2
      - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gprhs[2 - (1) + (3)
      * (igaus - (1))] ) ), _mm_mul_pd( fact[4 - (1)], gpvep[2 - (1) + (3) * (igaus
      - (1))] ) );\n      elrbu[3 - (1) + (3) * (inode - (1))] = _mm_add_pd( _mm_add_pd(
      elrbu[3 - (1) + (3) * (inode - (1))], _mm_mul_pd( fact[2 - (1)], gprhs[3 - (1)
      + (3) * (igaus - (1))] ) ), _mm_mul_pd( fact[4 - (1)], gpvep[3 - (1) + (3) *
      (igaus - (1))] ) );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode - (1)],
      _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1) + (pnode) * (igaus
      - (1))] ), gprhc[igaus - (1)] ) );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode
      - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpcar[1 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ), gpgrp[1 - (1) + (3) * (igaus - (1))] )
      );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd( _mm_mul_pd(
      gpvol[igaus - (1)], gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus -
      (1)))] ), gpgrp[2 - (1) + (3) * (igaus - (1))] ) );\n      elrbp[inode - (1)]
      = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)],
      gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ), gpgrp[3 -
      (1) + (3) * (igaus - (1))] ) );\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest10(mnode,
      pgaus, gpden, dtinv_mod, nbdfp_nsi, gpvel, pnode, gpvol, gpsha, agrau, gprhc,
      gpcar, gpvep, gpgrp, gprhs, elrbu, elrbp);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 10
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest10(const int32_t mnode, const int32_t pgaus,
      const __m128d * gpden, __m128d dtinv_mod[(1)], const int32_t nbdfp_nsi, const
      __m128d * gpvel, const int32_t pnode, const __m128d * gpvol, const __m128d *
      gpsha, __m128d * agrau, __m128d * gprhc, const __m128d * gpcar, __m128d * gpvep,
      __m128d * gpgrp, __m128d * gprhs, __m128d * elrbu, __m128d * elrbp){\n  int32_t
      igaus;\n  __m128d fact[(9)];\n  int32_t idime;\n  int32_t itime;\n  int32_t
      inode;\n  for (igaus = 1; igaus <= pgaus; igaus += 1) {\n    fact[5 - (1)] =
      _mm_mul_pd( gpden[igaus - (1)], dtinv_mod[1 - (1)] );\n    for (itime = 2; itime
      <= nbdfp_nsi; itime += 1) {\n      gprhs[1 - (1) + (3) * (igaus - (1))] = _mm_sub_pd(
      gprhs[1 - (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd( _mm_set1_pd( pabdf_nsi(itime)
      ), fact[5 - (1)] ), gpvel[1 - (1) + (3) * (igaus - (1) + (pgaus) * (itime -
      (1)))] ) );\n      gprhs[2 - (1) + (3) * (igaus - (1))] = _mm_sub_pd( gprhs[2
      - (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd( _mm_set1_pd( pabdf_nsi(itime)
      ), fact[5 - (1)] ), gpvel[2 - (1) + (3) * (igaus - (1) + (pgaus) * (itime -
      (1)))] ) );\n      gprhs[3 - (1) + (3) * (igaus - (1))] = _mm_sub_pd( gprhs[3
      - (1) + (3) * (igaus - (1))], _mm_mul_pd( _mm_mul_pd( _mm_set1_pd( pabdf_nsi(itime)
      ), fact[5 - (1)] ), gpvel[3 - (1) + (3) * (igaus - (1) + (pgaus) * (itime -
      (1)))] ) );\n    }\n    for (inode = 1; inode <= pnode; inode += 1) {\n      fact[2
      - (1)] = _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1) + (pnode) * (igaus
      - (1))] );\n      fact[4 - (1)] = _mm_mul_pd( gpvol[igaus - (1)], agrau[inode
      - (1) + (pnode) * (igaus - (1))] );\n      elrbu[1 - (1) + (3) * (inode - (1))]
      = _mm_add_pd( _mm_add_pd( elrbu[1 - (1) + (3) * (inode - (1))], _mm_mul_pd(
      fact[2 - (1)], gprhs[1 - (1) + (3) * (igaus - (1))] ) ), _mm_mul_pd( fact[4
      - (1)], gpvep[1 - (1) + (3) * (igaus - (1))] ) );\n      elrbu[2 - (1) + (3)
      * (inode - (1))] = _mm_add_pd( _mm_add_pd( elrbu[2 - (1) + (3) * (inode - (1))],
      _mm_mul_pd( fact[2 - (1)], gprhs[2 - (1) + (3) * (igaus - (1))] ) ), _mm_mul_pd(
      fact[4 - (1)], gpvep[2 - (1) + (3) * (igaus - (1))] ) );\n      elrbu[3 - (1)
      + (3) * (inode - (1))] = _mm_add_pd( _mm_add_pd( elrbu[3 - (1) + (3) * (inode
      - (1))], _mm_mul_pd( fact[2 - (1)], gprhs[3 - (1) + (3) * (igaus - (1))] ) ),
      _mm_mul_pd( fact[4 - (1)], gpvep[3 - (1) + (3) * (igaus - (1))] ) );\n      elrbp[inode
      - (1)] = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus
      - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))] ), gprhc[igaus - (1)] )
      );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd( _mm_mul_pd(
      gpvol[igaus - (1)], gpcar[1 - (1) + (3) * (inode - (1) + (mnode) * (igaus -
      (1)))] ), gpgrp[1 - (1) + (3) * (igaus - (1))] ) );\n      elrbp[inode - (1)]
      = _mm_add_pd( elrbp[inode - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)],
      gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ), gpgrp[2 -
      (1) + (3) * (igaus - (1))] ) );\n      elrbp[inode - (1)] = _mm_add_pd( elrbp[inode
      - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpcar[3 - (1) + (3) * (inode
      - (1) + (mnode) * (igaus - (1)))] ), gpgrp[3 - (1) + (3) * (igaus - (1))] )
      );\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const int32_t
      kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t kfl_duatss,
      const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double fvins_nsi,
      const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest10(mnode,
      pgaus, gpden, dtinv_mod, nbdfp_nsi, gpvel, pnode, gpvol, gpsha, agrau, gprhc,
      gpcar, gpvep, gpgrp, gprhs, elrbu, elrbp);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 11
      :unroll: true
      :inline: :included
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  if (maxval(pbubl)
      == 1) {\n    if (kfl_stabi_nsi != -1) {\n    }\n                    memset(elauq,
      0, sizeof(__m128d) * pnode * 3);\n                    memset(elapq, 0, sizeof(__m128d)
      * pnode);\n                    memset(elaqu, 0, sizeof(__m128d) * pnode * 3);\n
      \                   memset(elaqp, 0, sizeof(__m128d) * pnode);\n                    memset(elaqq,
      0, sizeof(__m128d));\n                    memset(elrbq, 0, sizeof(__m128d));\n
      \   if (kfl_press_nsi == 1) {\n      for (igaus = 1; igaus <= pgaus; igaus +=
      1) {\n        fact[2 - (1)] = _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus
      - (1)] );\n        for (inode = 1; inode <= pnode; inode += 1) {\n          idof[3
      - (1)] = (inode - (1)) * (3) + 1;\n          elauq[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (1 - (1))] = _mm_sub_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (inode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          elaqu[1 - (1) + (1) * (idof[3 -
      (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[1 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n          idof[3 - (1)] = (inode - (1)) * (3) + 2;\n          elauq[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (1 - (1))] = _mm_sub_pd( elauq[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (1 - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          elaqu[1 - (1)
      + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3 -
      (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1) + (3) * (inode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)] = (inode - (1)) *
      (3) + 3;\n          elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))]
      = _mm_sub_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n          elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n        }\n      }\n
      \   } else {\n      for (igaus = 1; igaus <= pgaus; igaus += 1) {\n        fact[2
      - (1)] = _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus - (1)] );\n        for
      (inode = 1; inode <= pnode; inode += 1) {\n          idof[3 - (1)] = (inode
      - (1)) * (3) + 1;\n          elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1
      - (1))] = _mm_add_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))],
      _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1) + (pnode) * (igaus
      - (1))] ), gpcar_bub[1 - (1) + (3) * (igaus - (1))] ) );\n          elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3
      - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (inode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)] = (inode - (1)) *
      (3) + 2;\n          elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))]
      = _mm_add_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))], _mm_mul_pd(
      _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))]
      ), gpcar_bub[2 - (1) + (3) * (igaus - (1))] ) );\n          elaqu[1 - (1) +
      (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3 - (1)]
      - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1) + (3) * (inode - (1) + (mnode)
      * (igaus - (1)))] ) );\n          idof[3 - (1)] = (inode - (1)) * (3) + 3;\n
      \         elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))] = _mm_add_pd(
      elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))], _mm_mul_pd( _mm_mul_pd(
      gpvol[igaus - (1)], gpsha[inode - (1) + (pnode) * (igaus - (1))] ), gpcar_bub[3
      - (1) + (3) * (igaus - (1))] ) );\n          elaqu[1 - (1) + (1) * (idof[3 -
      (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n        }\n      }\n    }\n    for (igaus = 1; igaus <= pgaus; igaus +=
      1) {\n      elaqq[1 - (1) + (1) * (1 - (1))] = _mm_add_pd( elaqq[1 - (1) + (1)
      * (1 - (1))], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus -
      (1)] ), _mm_set1_pd( penal_nsi ) ) );\n      elrbq[1 - (1)] = _mm_add_pd( elrbq[1
      - (1)], _mm_mul_pd( _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus
      - (1)] ), _mm_set1_pd( penal_nsi ) ), elbub[1 - (1)] ) );\n      elrbq[1 - (1)]
      = _mm_add_pd( elrbq[1 - (1)], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus
      - (1)] ), gprhc[igaus - (1)] ) );\n    }\n  }\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 11
      :unroll: true
      :inline: :inlined
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\ninline void nest11(const int32_t mnode, const int32_t
      pgaus, const int32_t pnode, const __m128d * gpcar, const __m128d * gpvol, const
      __m128d * gpsha, const __m128d * gpcar_bub, const __m64 * pbubl, const int32_t
      kfl_stabi_nsi, const int32_t kfl_press_nsi, const double penal_nsi, const __m128d
      * elbub, __m128d * gprhc, const __m128d * gpsha_bub, __m128d * elauq, __m128d
      * elaqu, __m128d * elapq, __m128d * elaqp, __m128d * elaqq, __m128d * elrbq){\n
      \ __m128d fact[(9)];\n  int32_t igaus;\n  int32_t idof[(3)];\n  int32_t idime;\n
      \ int32_t inode;\n  if (maxval(pbubl) == 1) {\n    if (kfl_stabi_nsi != -1)
      {\n    }\n                    memset(elauq, 0, sizeof(__m128d) * pnode * 3);\n
      \                   memset(elapq, 0, sizeof(__m128d) * pnode);\n                    memset(elaqu,
      0, sizeof(__m128d) * pnode * 3);\n                    memset(elaqp, 0, sizeof(__m128d)
      * pnode);\n                    memset(elaqq, 0, sizeof(__m128d));\n                    memset(elrbq,
      0, sizeof(__m128d));\n    if (kfl_press_nsi == 1) {\n      for (igaus = 1; igaus
      <= pgaus; igaus += 1) {\n        fact[2 - (1)] = _mm_mul_pd( gpvol[igaus - (1)],
      gpsha_bub[igaus - (1)] );\n        for (inode = 1; inode <= pnode; inode +=
      1) {\n          idof[3 - (1)] = (inode - (1)) * (3) + 1;\n          elauq[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (1 - (1))] = _mm_sub_pd( elauq[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (1 - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          elaqu[1 - (1)
      + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3 -
      (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (inode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)] = (inode - (1)) *
      (3) + 2;\n          elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))]
      = _mm_sub_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n          elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)]
      = (inode - (1)) * (3) + 3;\n          elauq[idof[3 - (1)] - (1) + ((pnode) *
      (3)) * (1 - (1))] = _mm_sub_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (inode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          elaqu[1 - (1) + (1) * (idof[3 -
      (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n        }\n      }\n    } else {\n      for (igaus = 1; igaus <= pgaus;
      igaus += 1) {\n        fact[2 - (1)] = _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus
      - (1)] );\n        for (inode = 1; inode <= pnode; inode += 1) {\n          idof[3
      - (1)] = (inode - (1)) * (3) + 1;\n          elauq[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (1 - (1))] = _mm_add_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1)
      + (pnode) * (igaus - (1))] ), gpcar_bub[1 - (1) + (3) * (igaus - (1))] ) );\n
      \         elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)]
      = (inode - (1)) * (3) + 2;\n          elauq[idof[3 - (1)] - (1) + ((pnode) *
      (3)) * (1 - (1))] = _mm_add_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1)
      + (pnode) * (igaus - (1))] ), gpcar_bub[2 - (1) + (3) * (igaus - (1))] ) );\n
      \         elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)]
      = (inode - (1)) * (3) + 3;\n          elauq[idof[3 - (1)] - (1) + ((pnode) *
      (3)) * (1 - (1))] = _mm_add_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1)
      + (pnode) * (igaus - (1))] ), gpcar_bub[3 - (1) + (3) * (igaus - (1))] ) );\n
      \         elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n        }\n      }\n
      \   }\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n      elaqq[1 - (1)
      + (1) * (1 - (1))] = _mm_add_pd( elaqq[1 - (1) + (1) * (1 - (1))], _mm_mul_pd(
      _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus - (1)] ), _mm_set1_pd( penal_nsi
      ) ) );\n      elrbq[1 - (1)] = _mm_add_pd( elrbq[1 - (1)], _mm_mul_pd( _mm_mul_pd(
      _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus - (1)] ), _mm_set1_pd( penal_nsi
      ) ), elbub[1 - (1)] ) );\n      elrbq[1 - (1)] = _mm_add_pd( elrbq[1 - (1)],
      _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus - (1)] ), gprhc[igaus
      - (1)] ) );\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest11(mnode,
      pgaus, pnode, gpcar, gpvol, gpsha, gpcar_bub, pbubl, kfl_stabi_nsi, kfl_press_nsi,
      penal_nsi, elbub, gprhc, gpsha_bub, elauq, elaqu, elapq, elaqp, elaqq, elrbq);\n}\n"
    ? :vector_length: 2
      :preprocessor: false
      :nests:
      - 11
      :unroll: true
      :inline: :call
      :CFLAGS: -O3
    : ! "double pabdf_nsi(const int32_t x){\n  double y;\n  y = 1.0;\n  return y;\n}\nint32_t
      maxval(const __m64 * x){\n  int32_t y;\n  int32_t i;\n  int32_t a[(2)];\n  *((int64_t
      * ) &a[1 - (1)]) = _m_to_int64( *(x) );\n  y = a[1 - (1)];\n  for (i = 2; i
      <= 2; i += 1) {\n    if (a[i - (1)] > y) {\n      y = a[i - (1)];\n    }\n  }\n
      \ return y;\n}\n__m128d Min(const __m128d x, const __m128d y){\n  __m128d z;\n
      \ int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n  double tmp3[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  _mm_storeu_pd( (double
      * ) &tmp2[1 - (1)], y );\n  for (i = 1; i <= 2; i += 1) {\n    tmp3[i - (1)]
      = (tmp1[i - (1)] < tmp2[i - (1)] ? tmp1[i - (1)] : tmp2[i - (1)]);\n  }\n  z
      = _mm_loadu_pd( &tmp3[1 - (1)] );\n  return z;\n}\n__m128d Tanh(const __m128d
      x){\n  __m128d y;\n  int32_t i;\n  double tmp1[(2)];\n  double tmp2[(2)];\n
      \ _mm_storeu_pd( (double * ) &tmp1[1 - (1)], x );\n  for (i = 1; i <= 2; i +=
      1) {\n    tmp2[i - (1)] = tanh( tmp1[i - (1)] );\n  }\n  y = _mm_loadu_pd( &tmp2[1
      - (1)] );\n  return y;\n}\nvoid nest11(const int32_t mnode, const int32_t pgaus,
      const int32_t pnode, const __m128d * gpcar, const __m128d * gpvol, const __m128d
      * gpsha, const __m128d * gpcar_bub, const __m64 * pbubl, const int32_t kfl_stabi_nsi,
      const int32_t kfl_press_nsi, const double penal_nsi, const __m128d * elbub,
      __m128d * gprhc, const __m128d * gpsha_bub, __m128d * elauq, __m128d * elaqu,
      __m128d * elapq, __m128d * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d
      fact[(9)];\n  int32_t igaus;\n  int32_t idof[(3)];\n  int32_t idime;\n  int32_t
      inode;\n  if (maxval(pbubl) == 1) {\n    if (kfl_stabi_nsi != -1) {\n    }\n
      \                   memset(elauq, 0, sizeof(__m128d) * pnode * 3);\n                    memset(elapq,
      0, sizeof(__m128d) * pnode);\n                    memset(elaqu, 0, sizeof(__m128d)
      * pnode * 3);\n                    memset(elaqp, 0, sizeof(__m128d) * pnode);\n
      \                   memset(elaqq, 0, sizeof(__m128d));\n                    memset(elrbq,
      0, sizeof(__m128d));\n    if (kfl_press_nsi == 1) {\n      for (igaus = 1; igaus
      <= pgaus; igaus += 1) {\n        fact[2 - (1)] = _mm_mul_pd( gpvol[igaus - (1)],
      gpsha_bub[igaus - (1)] );\n        for (inode = 1; inode <= pnode; inode +=
      1) {\n          idof[3 - (1)] = (inode - (1)) * (3) + 1;\n          elauq[idof[3
      - (1)] - (1) + ((pnode) * (3)) * (1 - (1))] = _mm_sub_pd( elauq[idof[3 - (1)]
      - (1) + ((pnode) * (3)) * (1 - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          elaqu[1 - (1)
      + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3 -
      (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1) + (3) * (inode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)] = (inode - (1)) *
      (3) + 2;\n          elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))]
      = _mm_sub_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3)) * (1 - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[2 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n          elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)]
      = (inode - (1)) * (3) + 3;\n          elauq[idof[3 - (1)] - (1) + ((pnode) *
      (3)) * (1 - (1))] = _mm_sub_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1) + (3) * (inode - (1)
      + (mnode) * (igaus - (1)))] ) );\n          elaqu[1 - (1) + (1) * (idof[3 -
      (1)] - (1))] = _mm_add_pd( elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd(
      fact[2 - (1)], gpcar[3 - (1) + (3) * (inode - (1) + (mnode) * (igaus - (1)))]
      ) );\n        }\n      }\n    } else {\n      for (igaus = 1; igaus <= pgaus;
      igaus += 1) {\n        fact[2 - (1)] = _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus
      - (1)] );\n        for (inode = 1; inode <= pnode; inode += 1) {\n          idof[3
      - (1)] = (inode - (1)) * (3) + 1;\n          elauq[idof[3 - (1)] - (1) + ((pnode)
      * (3)) * (1 - (1))] = _mm_add_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1)
      + (pnode) * (igaus - (1))] ), gpcar_bub[1 - (1) + (3) * (igaus - (1))] ) );\n
      \         elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[1 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)]
      = (inode - (1)) * (3) + 2;\n          elauq[idof[3 - (1)] - (1) + ((pnode) *
      (3)) * (1 - (1))] = _mm_add_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1)
      + (pnode) * (igaus - (1))] ), gpcar_bub[2 - (1) + (3) * (igaus - (1))] ) );\n
      \         elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[2 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n          idof[3 - (1)]
      = (inode - (1)) * (3) + 3;\n          elauq[idof[3 - (1)] - (1) + ((pnode) *
      (3)) * (1 - (1))] = _mm_add_pd( elauq[idof[3 - (1)] - (1) + ((pnode) * (3))
      * (1 - (1))], _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha[inode - (1)
      + (pnode) * (igaus - (1))] ), gpcar_bub[3 - (1) + (3) * (igaus - (1))] ) );\n
      \         elaqu[1 - (1) + (1) * (idof[3 - (1)] - (1))] = _mm_add_pd( elaqu[1
      - (1) + (1) * (idof[3 - (1)] - (1))], _mm_mul_pd( fact[2 - (1)], gpcar[3 - (1)
      + (3) * (inode - (1) + (mnode) * (igaus - (1)))] ) );\n        }\n      }\n
      \   }\n    for (igaus = 1; igaus <= pgaus; igaus += 1) {\n      elaqq[1 - (1)
      + (1) * (1 - (1))] = _mm_add_pd( elaqq[1 - (1) + (1) * (1 - (1))], _mm_mul_pd(
      _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus - (1)] ), _mm_set1_pd( penal_nsi
      ) ) );\n      elrbq[1 - (1)] = _mm_add_pd( elrbq[1 - (1)], _mm_mul_pd( _mm_mul_pd(
      _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus - (1)] ), _mm_set1_pd( penal_nsi
      ) ), elbub[1 - (1)] ) );\n      elrbq[1 - (1)] = _mm_add_pd( elrbq[1 - (1)],
      _mm_mul_pd( _mm_mul_pd( gpvol[igaus - (1)], gpsha_bub[igaus - (1)] ), gprhc[igaus
      - (1)] ) );\n    }\n  }\n}\nvoid nsi_element_assembly_split_oss_ndime3(const
      int32_t kfl_lumped, const int32_t mnode, const int32_t ntens, const int32_t
      kfl_duatss, const int32_t fact_duatss, const int32_t kfl_stabi_nsi, const double
      fvins_nsi, const double fcons_nsi, const double bemol_nsi, const int32_t kfl_regim_nsi,
      const double * fvela_nsi, const int32_t kfl_rmom2_nsi, const int32_t kfl_press_nsi,
      const int32_t kfl_p1ve2_nsi, const int32_t kfl_linea_nsi, const int32_t kfl_confi_nsi,
      const int32_t nbdfp_nsi, const int32_t kfl_sgsti_nsi, const int32_t kfl_nota1_nsi,
      const int32_t kfl_limit_nsi, const int32_t kfl_penal_nsi, const double penal_nsi,
      const int32_t kfl_bubbl_nsi, const int32_t pnode, const int32_t pgaus, const
      __m128d * gpden, const __m128d * gpvis, const __m128d * gppor, const __m128d
      * gpsp1, const __m128d * gpsp2, const __m128d * gpvol, const __m128d * gpsha,
      const __m128d * gpcar, const __m128d * gpadv, __m128d * gpvep, __m128d * gpgrp,
      __m128d * gprhs, __m128d * gprhc, const __m128d * gpvel, const __m128d * gpsgs,
      const __m128d * elvel, const __m128d * elpre, const __m128d * elbub, __m128d
      * wgrgr, __m128d * agrau, __m128d * elauu, __m128d * elaup, __m128d * elapp,
      __m128d * elapu, __m128d * elrbu, __m128d * elrbp, const __m128d * dtinv_loc,
      const __m128d * dtsgs, const __m64 * pbubl, const __m128d * gpsha_bub, const
      __m128d * gpcar_bub, __m128d * elauq, __m128d * elapq, __m128d * elaqu, __m128d
      * elaqp, __m128d * elaqq, __m128d * elrbq){\n  __m128d gpsp1_p[(pgaus)];\n  __m128d
      gpsp1_v[(pgaus)];\n  __m128d gpsp2_v[(pgaus)];\n  __m128d c1[(1)];\n  __m128d
      c2[(1)];\n  __m128d c3[(1)];\n  __m128d c4[(1)];\n  __m128d alpha[(1)];\n  __m128d
      beta[(1)];\n  __m128d gpveo[(3)];\n  __m128d fact1_p[(1)];\n  __m128d dtinv_mod[(1)];\n
      \ int32_t inode;\n  int32_t jnode;\n  int32_t jdime;\n  int32_t idofv;\n  int32_t
      ivect;\n  int32_t igaus;\n  int32_t idime;\n  int32_t jdofv;\n  int32_t itime;\n
      \ __m128d fact[(9)];\n  int32_t idof[(3)];\n  int32_t jdof[(3)];\n  memcpy(dtinv_mod,
      dtinv_loc, sizeof(dtinv_mod));\n  memcpy(gpsp1_p, gpsp1, sizeof(gpsp1_p));\n
      \ memcpy(gpsp1_v, gpsp1, sizeof(gpsp1_v));\n  memcpy(gpsp2_v, gpsp2, sizeof(gpsp2_v));\n\n
      \ if (kfl_nota1_nsi == 1) memset(gpsp1_v, 0, sizeof(gpsp1_v));\n\n  memset(elrbp,
      0, sizeof(__m128d) * pnode);\n  memset(elrbu, 0, sizeof(__m128d) * 3 * pnode);\n
      \ memset(elapp, 0, sizeof(__m128d) * pnode * pnode);\n  memset(elauu, 0, sizeof(__m128d)
      * pnode * 3 * pnode * 3);\n  memset(elaup, 0, sizeof(__m128d) * pnode * 3 *
      pnode);\n  memset(elapu, 0, sizeof(__m128d) * pnode * pnode * 3);\n  nest11(mnode,
      pgaus, pnode, gpcar, gpvol, gpsha, gpcar_bub, pbubl, kfl_stabi_nsi, kfl_press_nsi,
      penal_nsi, elbub, gprhc, gpsha_bub, elauq, elaqu, elapq, elaqp, elaqq, elrbq);\n}\n"
