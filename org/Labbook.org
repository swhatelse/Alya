#+TITLE:  LabBook
#+AUTHOR: Steven QUINITO MASNADA
#+BABEL: :tangle yes
#+TAGS: Arnaud(a) Brice(b) Script(s) Analysis (c) R(r) Technical(t) deprecated(d) Modifications(m) noexport(n)

* Todo 
  - [ ] Finish alya kernel
      DEADLINE: <2016-11-10 jeu.> 
  - [ ] SVML Intrinsics
    - Works only with intel compiler
    - Only for 128 and 256
  - [ ] Blocking
  - [ ] Unrolling step
  - [ ] Loop reordering
  - [ ] Moving parts into functions
  - [ ] look AMD implementation of intrinsics
  - [ ] Check intrinsics precision
  - [ ] Check similarities of the 2 kernels 
* 2016
** October
*** 2016-10-04
**** Meeting Alya
     Loops \to subroutine, inlining.
     Make tutorial to explain the steps.
     24th October telco 14h.
**** Looking for general pattern                                   :noexport:
        - First:
          Possible to reuse gpcar(:,dim,inode,igaus)
          #+BEGIN_SRC fortran
            agrau(:,inode,igaus) = gpden(:,igaus) * (
                                                gpadv(:,dim,igaus)*gpcar(:,dim,inode,igaus) 
                                                + etc)
            wgrgr(:,inode,jnode,igaus) = gpcar(:,1,inode,igaus)*gpcar(:,1,jnode,igaus)
                                                + etc 
          #+END_SRC
        - Second
          #+BEGIN_SRC fortran
            fact0(:) = gpsp2(:,igaus) * gpvol(:,igaus)
            fact6(:) = gpvis(:,igaus) * gpvol(:,igaus)
            fact7(:) = gpsp1_v(:,igaus) * gpvol(:,igaus) 
            fact8(:) = pabdf_nsi(1) * gpden(:,igaus) * dtinv_loc(:) + gppor(:,igaus)

            factDIM(:) = fact0(:) * gpcar(:,DIM,inode,igaus)
            ...
            fact4(:) = gpsha(:,inode,igaus) * gpvol(:,igaus)

            fact5(:) = fact4(:) * ( agrau(:,jnode,igaus) + fact8(:) * gpsha(:,jnode,igaus) ) & ! ( rho/dt N_j + s Nj + rho*(a.grad)Nj ) Ni
            &         +  fact6(:) * wgrgr(:,inode,jnode,igaus) & ! mu * grad(Ni) . grad(Nj)
            &         +  fact7(:) * agrau(:,jnode,igaus) * agrau(:,inode,igaus) ! tau1 * rho*(a.grad)Nj * rho*(a.grad)Ni

            elauu(:,idofDIMJ,jdofDIMI) = elauu(:,idofDIMJ,jdofDIMI) + factDIMJ(:) * gpcar(:,1,jnode,igaus) + fact5(:)
            elauu(:,idofDIMJ,jdofDIMI) = elauu(:,idofDIMJ,jdofDIMI) + factDIMJ(:) * gpcar(:,1,jnode,igaus)
            ...
                  
          #+END_SRC
        - Third
          Some similarities with the second nest, elauu is almost
          computed the same way with unrolling on the dimension.
          #+BEGIN_SRC fortran
            fact1                       = gpvis(:,igaus) * gpvol(:,igaus) * gpcar(:,idime,jnode,igaus)     
            elauu(:,idofv,jdofv) = elauu(:,idofv,jdofv) + fact1(:) * gpcar(:,DIM,inode,igaus)

            fact1 = -2.0_rp/3.0_rp * gpvis(:,igaus) * gpvol(:,igaus) * gpcar(:,idime,inode,igaus)
            elauu(:,idofv,jdofv) = elauu(:,idofv,jdofv) + fact1(:) * gpcar(:,DIM,inode,igaus)
          #+END_SRC
        - Fourth
          The first elauu and elbru is calculated in the same way between
          kfl_lumped = 1 and 2. Fact 0 = Fact1 but fact1 invovles less
          computations better reuse. The first is unrolled. In
          kfl_lumped = 1 te second elauu is computed with a slightly
          different factor. We could try to parametrize the
          computation of elauu.
          #+BEGIN_SRC fortran
            if( kfl_lumped == 1 ) then 
               gpveo(:,idime) = gpveo(:,idime) + elvel(:,idime,inode,2) * gpsha(:,inode,igaus)
               fact0(:)             = gpvol(:,igaus) * gpden(:,igaus) * gpsha(:,inode,igaus) * dtinv_loc(:)
               elauu(:,idofDIM,idofDIM) = elauu(:,idofDIM,idofDIM) + fact0(:)
               ...

               elrbu(:,idime,inode) = elrbu(:,idime,inode) - fact0(:) * gpveo(:,idime)
               elrbu(:,idime,inode) = elrbu(:,idime,inode) + fact0(:) * elvel(:,idime,inode,2)

               elauu(:,idofDIM,jdofDIM) = elauu(:,idofDIM,jdofDIM) - fact0*gpsha(:,jnode,igaus) 
               ...
            else if( kfl_lumped == 2 ) then 
               fact0(:) = gpvol(:,igaus) * gpden(:,igaus) * dtinv_loc(:)
               fact1(:) = fact0(:) * gpsha(:,inode,igaus)
               elauu(:,idof1,idof1) = elauu(:,idof1,idof1) + fact1(:)
               elrbu(:,idime,inode) = elrbu(:,idime,inode) + fact1(:) * elvel(:,idime,inode,2)
            end if
                  
          #+END_SRC
        - Fiveth
          Same pattern as four. Very close to 2. fact4 = fact0 of 2.
          #+BEGIN_SRC fortran
            ! ( div(u) , q ) and - ( p , div(v) ) 
            !
            fact0(:)             = gpvol(:,igaus) * gpsha(:,jnode,igaus) 
            factDIM(:)             = fact0(:) * gpcar(:,DIM,inode,igaus)
            ...

            elapu(:,jnode,idofDIM) = elapu(:,jnode,idofDIM) + factDIM(:)
            ...

            elaup(:,idofDIM,jnode) = elaup(:,idofDIM,jnode) - factDIM(:)
            ...
          #+END_SRC
        - Sixth
          #+BEGIN_SRC fortran
            !     Pressure: ( tau1' * grad(p) , grad(q) )
            !     
            fact1(:)             = gpsp1_p(:,igaus) * wgrgr(:,jnode,inode,igaus) * gpvol(:,igaus)
            elapp(:,jnode,inode) = elapp(:,jnode,inode) + fact1(:)
            elapp(:,inode,jnode) = elapp(:,inode,jnode) + fact1(:)

            fact1(:)             = gpsp1_p(:,igaus) * wgrgr(:,inode,inode,igaus) * gpvol(:,igaus)
            elapp(:,inode,inode) = elapp(:,inode,inode) + fact1(:)
          #+END_SRC
        - Seventh
          #+BEGIN_SRC fortran
            !----------------------------------------------------------------------
            !
            ! bu and bp
            !
            ! P1  = P [ tau1' * rho * a.grad(u) ]
            ! P1' = P1 + tau1' * rho * u'n / dt
            !
            ! P2  = P [ tau1' * ( grad(p) - f ) ]
            ! P2' = P2 + tau1' * rho * u'n / dt + tau1' * f 
            !
            !----------------------------------------------------------------------

                  c4(:) = c4(:) + agrau(:,inode,igaus) * elvel(:,idime,inode,1)

                  c4(:) = gpsp1(:,igaus) * c4(:)
                  c1(:) = c1(:) + ( gpvep(:,idime,igaus) - c4(:) )**2
                  c3(:) = c3(:) + gpvep(:,idime,igaus) * gpvep(:,idime,igaus)
                  c2(:) = c2(:) + c4(:) * c4(:)

                  c3(:)   = sqrt( c2(:) ) + sqrt( c3(:) )
                  c1(:)   = sqrt( c1(:) )
                  beta(:) = c1(:) / ( c3(:) + epsilon(1.0_rp) )

                  if( kfl_limit_nsi == 1 ) then
                     alpha(:) = min(1.0_rp,2.0_rp*(1.0_rp-beta(:)))
                  else if( kfl_limit_nsi == 2 ) then
                     alpha(:) = 0.5_rp*(tanh(20.0_rp*(beta(:)-0.8_rp))+1.0_rp)
                  end if

                  gpvep(:,idime,igaus) = alpha(:) * gpvep(:,idime,igaus)
          #+END_SRC
        - Eighth
          #+BEGIN_SRC fortran
            !     
            !     P2 <= P2 + tau1' * f
            !     
            gpgrp(DEF_VECT,idime,igaus) = gpgrp(DEF_VECT,idime,igaus) + gpsp1_p(DEF_VECT,igaus) * gprhs(DEF_VECT,idime,igaus)
          #+END_SRC
        - Nineth
          #+BEGIN_SRC fortran
            !     P1 <= P1 + tau1' * rho * u'n / dt
            !     P2 <= P2 + tau1' * rho * u'n / dt
            !     
                  fact1(DEF_VECT)    = gpden(DEF_VECT,igaus) * dtsgs(DEF_VECT) * gpsp1_v(DEF_VECT,igaus)
                  fact1_p (DEF_VECT) = gpden(DEF_VECT,igaus) * dtsgs(DEF_VECT) * gpsp1_p(DEF_VECT,igaus)

                  gpvep(DEF_VECT,idime,igaus) = gpvep(DEF_VECT,idime,igaus) + fact1(DEF_VECT)   * gpsgs(DEF_VECT,idime,igaus,2)
                  gpgrp(DEF_VECT,idime,igaus) = gpgrp(DEF_VECT,idime,igaus) + fact1_p(DEF_VECT) * gpsgs(DEF_VECT,idime,igaus,2)
          #+END_SRC
        - Tenth
          #+BEGIN_SRC fortran
            !     bu = ( f + rho*u^n/dt , v ) + ( rho * a.grad(v) , tau1' * rho u'^n/dt + P1 ) 
            !    = ( f + rho*u^n/dt , v ) + ( rho * a.grad(v) , P1' ) 
            !
            ! bp = ( f + rho*u'^n/dt , tau1' grad(q) ) + ( P2 , grad(q) )
            !    = ( P2' , grad(q) ) 
            !

                  fact4(DEF_VECT) = gpden(DEF_VECT,igaus) * dtinv_loc(DEF_VECT)

                  gprhs(DEF_VECT,DIM,igaus) = gprhs(DEF_VECT,DIM,igaus) - pabdf_nsi(itime) * fact4(DEF_VECT) * gpvel(DEF_VECT,DIM,igaus,itime)  
                  ...


                  fact1(DEF_VECT) = gpvol(DEF_VECT,igaus) * gpsha(DEF_VECT,inode,igaus) ! ( f + rho*u^n/dt , v )
                  fact3(DEF_VECT) = gpvol(DEF_VECT,igaus) * agrau(DEF_VECT,inode,igaus) ! ( rho * a.grad(v) , P1' ) 

                  elrbu(DEF_VECT,DIM,inode)  = elrbu(DEF_VECT,DIM,inode) + fact1(DEF_VECT) * gprhs(DEF_VECT,DIM,igaus) + fact3(DEF_VECT) * gpvep(DEF_VECT,DIM,igaus) 
                  ...

                  elrbp(DEF_VECT,inode)    = elrbp(DEF_VECT,inode)   + gpvol(DEF_VECT,igaus) * ( ! ( P2' , grad(q) ) 
                  gpcar(DEF_VECT,DIM,inode,igaus) * gpgrp(DEF_VECT,DIM,igaus)  
                  + ...
          #+END_SRC
**** Possible optimization
****** 1st nest
       - We could possibly block the second inner loop to reduce the
         possible cache misses when wgrgr is accessed, because the data are not
         accessed sequentially. But the provided example work with small
         array and it should fit into the cache. 2-D blocking should be
         enough.
       - Unrolling should be beneficient on the the second inner loop
         and maybe the first.
****** 2nd nest
       - Fact4 should moved out to the jnode loop to avoid useless
         computation.
       - Fact5 may be useless here as used only one time to compute
         elauu, this would save few memory related operations.
       - Blocking could be interesting for the access to wgrgr and
         elauu. May be a 2-D blocking should be enough.
****** 3rd nest
       - Blocking the inner loops that compute elauu. 2-D blocking
         should be enough.
       - Unrolling the jnode loops.

       - Different loop reorganisation can be made here. Fact1 could be
         computed more efficiently. The memory access to gpcar are made
         in a contiguous way but by column. It access different memory
         location pnode^2 x ndime times for gpcar. Same thing for elauu,
         there are 2.(2.ndime^2 . pnode^2 + ndime/x . pnode ). The 1/x
         come from contiguous memory access that allow to take
         advantages of L1 cache with a size of cache x. Because gpcar
         is accessed sequentially to compute elauu. Here to compute elauu
         we can either use the cache for elauu or gpcar.
         Access to elauu are most costly than gpcar because it is accessed more
         often. So made be it worth to reorganize loops to access elauu
         the more sequentially possible.

****** 4th nest
       - Blocking the jnode loop because elauu not accessed
         sequentially. 2-D blocking.
       - Maybe loop reordering.
       - Unroll jnode.
****** 5th nest
       - Blocking should be beneficial for access to elaup. 2-D
         blocking.
       - Unrolling jnode loop.
****** 6th nest
       - Regarding to the access pattern to elapp blocking should be
         ok.
       - Unroll jnode loop.
****** 7th nest
       - Unroll inode
****** 8th nest
       - Unroll the loop inode that compute C4.
       - Maybe unroll the idime loop.
****** 9th nest
       - Unrolling the igaus loop.
****** 10th nest
       - Maybe blocking for gprhs. 3-D?
       - Unroll itime loop.
****** 11th nest
       - Blocking for elaqu and elauq
       - Unroll last igaus loop
** November
*** 2016-11-09
**** Report
***** Structure     
     1. Intro
       - Porting on Accelerators \to one of the current model of HPC
         programming. Target last Xeon Phi KNL \to Vector instructions
         AVX 512 \to should bring speedup. 
       - What is BOAST
         - Porting over architecture time consumming \to BOAST allows to
           write portable code \to  ease developer's task using meta
           programming to describe the kernels. 
         - Code factorization
         - Multiple targets CPUs, GPUs and accelerators (C, Fortran,
           CUDA, OpenCL)
         - Generate multiple variant of same code \to test different
           optimization strategies.
         - Tuning to find the best optimizations.
     2. Using BOAST
       - What we have already done
         Working on kernel matrix assembly.
         - Porting with BOAST:
           Vectorized code \to Provide example of AVX vectorization
           along with fortran vectorization.
       - To be done
         - Comparing optimization strategies(tiling, unrolling, loop
           reordering, etc...)
         - Tuning (size of vector, block size, unrolling factors, etc..)
***** Writing
      1. Intro
         Along with GPUs, accelerators are also part of the current
         programming model and the third approach consists in using
         them. In order to port kernels on accelerators such as the
         Intel Knight Landing Xeon Phi, we rely on BOAST. BOAST
         provides scientific application developers with a framework
         to develop and test application computing kernels. It put
         the focus on portability by allowing the developer to
         meta-program his kernels using a dedicated langugage with
         orthogonal optimizations and it can generate code in C, Fortran,
         CUDA and OpenCL. Thus, with this framework it is easy to
         generate different optimized versions of the same kernel to
         tune the performances according to the target plateform. 
         We were given 2 matrices assembly kernels and our goal is to:
         - use BOAST to factorize them, 
         - vectorize them in order to take advantage of the new AVX 512
           instructions set, 
         - test different optimizations strategies such as loop
           unrolling, loop tiling, loop reordering, etc... 
         - and find the right unrolling factor, tile size, vector
           size, etc... 

      2. Using BOAST
         
* Sandbox :noexport:
** Fortran
*** Loop vectorization
    #+BEGIN_SRC fortran
      #define PGAUS 10
      #define PNODE 50
       #define DEF_VECT 75
            
            program test
            
            real :: t1(DEF_VECT,PNODE,PGAUS)
            real :: t2(DEF_VECT,PNODE,PGAUS)
            real :: t3(DEF_VECT,PGAUS)
            real :: res1(DEF_VECT,PNODE,PGAUS)
            real :: res1b(DEF_VECT,PNODE,PGAUS)
            real :: res2(DEF_VECT,PNODE,PNODE,PGAUS)
            real :: res2b(DEF_VECT,PNODE,PNODE,PGAUS)
            logical :: b
            
            call random_number(t1)
            call random_number(t2)
            call random_number(t3)
            

            do igaus = 1,PGAUS
               do inode = 1,PNODE
                  res1b(:,inode,igaus) = t3(:,igaus) * t1(:,inode,igaus)
               end do
            end do
            
      !     Simplified
            do inode = 1,PNODE
               res1(:,inode,:) = t3(:,:) * t1(:,inode,:)
            end do
            
      !     Verification
            b = .true.
            do i = 1,DEF_VECT
               do igaus = 1,PGAUS
                  do inode = 1,PNODE
                     if (res1(i,inode,igaus) /= res1b(i,inode,igaus)) then
                        b = .false.
                     end if
                  end do
               end do
            end do
            
            if (b) then
               print *, "Ok"
            else
               print *, "Error"
            end if
            
      !     Original
            do igaus = 1,PGAUS
               do inode = 1,PNODE
                  do jnode = 1,PNODE
                     res2(:,inode,jnode,igaus) = t1(:,inode,igaus) * t1(:,jnode,igaus)
                  end do
               end do
            end do
            
      !     Simplified
            do inode = 1,PNODE
               do jnode = 1,PNODE
                  res2b(:,inode,jnode,:) = t1(:,inode,:) * t1(:,jnode,:)
               end do
            end do
            
            b = .true.
            
            do i = 1,DEF_VECT
               do igaus = 1,PGAUS
                  do inode = 1,PNODE
                     do jnode = 1,PNODE
                        if (res2(i,inode,jnode,igaus) /= res2b(i,inode,jnode,igaus)) then
                           b = .false.
                        end if
                     end do
                  end do
               end do
            end do
            
            if (b) then
               print *, "Ok"
            else
               print *, "Error"
            end if
            
            end program test        
    #+END_SRC

** BOAST
*** Expression
    #+BEGIN_SRC ruby 
      require 'BOAST'
      include BOAST

      p = Procedure("foo"){
        decl x = Int("x")
        exp = x === 1
        pr exp
      }
              
      k = p.ckernel
      k.build
    #+END_SRC

    #+RESULTS:
    : SUBROUTINE foo()
    :   integer, parameter :: wp=kind(1.0d0)
    :   integer(kind=4) :: x
    :   x = 1
    : END SUBROUTINE foo

*** Arrays
    #+BEGIN_SRC ruby 
      require 'BOAST'
      include BOAST

      set_lang(FORTRAN)
      p = Procedure("foo"){
        decl a = Real('a', :vector_length => 2, :dim => [Dim(10)])
        # decl a = Real('a', :dim => [Dim(10)])
        pr a[1,1..2] === 0.0
      }

      k = p.ckernel
      k.build
    #+END_SRC

    #+RESULTS:

*** Playing with vectors
**** Vectorization in fortran
    #+BEGIN_SRC ruby 
            require 'BOAST'
            include BOAST
            require 'narray'
            set_lang(FORTRAN)

            k1 = BOAST::CKernel::new
            k2 = BOAST::CKernel::new

            pgaus = Int("pgaus", :dir => :in)
            pnode = Int("pnode", :dir => :in)
            def_vect = Int("def_vect", :dir => :in)
            ndime = Int("ndime", :dir => :in)
            gpden = Real("gpden", :dir => :in, :dim => [Dim(def_vect),Dim(pgaus)])
            gpadv = Real("gpadv", :dir => :in, :dim => [Dim(def_vect),Dim(ndime),Dim(pgaus)])
            gpcar = Real("gpcar", :dir => :in, :dim => [Dim(def_vect),Dim(ndime),Dim(pnode),Dim(pgaus)])
            agrau1 = Real("agrau", :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])
            agrau2 = Real("agrau", :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])

            p1 = Procedure::new("foo",[pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau1])
            k1.code.print <<EOF
            subroutine foo(pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau)
              integer, parameter :: wp=kind(1.0d0)
              integer(kind=4), intent(in) :: pgaus
              integer(kind=4), intent(in) :: pnode
              integer(kind=4), intent(in) :: def_vect
              integer(kind=4), intent(in) :: ndime
              real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpden
              real(kind=8), intent(in), dimension(def_vect, ndime, pgaus) :: gpadv
              real(kind=8), intent(in), dimension(def_vect, ndime, pnode, pgaus) :: gpcar
              real(kind=8), intent(out), dimension(def_vect, pnode, pgaus) :: agrau
              integer(kind=4) :: igaus
              integer(kind=4) :: inode

              do igaus = 1,pgaus  
                do inode = 1,pnode
                            agrau(:,inode,igaus) =  gpden(:,igaus) * ( gpadv(:,1,igaus)*gpcar(:,1,inode,igaus) + gpadv(:,2,igaus)*gpcar(:,2,inode,igaus) )                      
                end do
               end do
            end subroutine foo
      EOF
            k1.procedure = p1


            p2 = Procedure::new("foo",[pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau2])
            k2.code.print <<EOF
            subroutine foo(pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau)
              integer, parameter :: wp=kind(1.0d0)
              integer(kind=4), intent(in) :: pgaus
              integer(kind=4), intent(in) :: pnode
              integer(kind=4), intent(in) :: def_vect
              integer(kind=4), intent(in) :: ndime
              real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpden
              real(kind=8), intent(in), dimension(def_vect, ndime, pgaus) :: gpadv
              real(kind=8), intent(in), dimension(def_vect, ndime, pnode, pgaus) :: gpcar
              real(kind=8), intent(out), dimension(def_vect, pnode, pgaus) :: agrau
              integer(kind=4) :: igaus
              integer(kind=4) :: inode

                do inode = 1,pnode
                            agrau(:,inode,:) =  gpden(:,:) * ( gpadv(:,1,:)*gpcar(:,1,inode,:) + gpadv(:,2,:)*gpcar(:,2,inode,:) )                      
                end do
            end subroutine foo
      EOF
            k2.procedure = p2

            stats1 = []
            stats2 = []

            checker = []

            pgaus = 20
            def_vect = 10
            pnode = 8
            ndime = 2
            
            10000.times{|i|
              gpden = NArray.float(def_vect, pgaus).random
              gpadv = NArray.float(def_vect, ndime, pgaus).random
              gpcar = NArray.float(def_vect, ndime, pnode, pgaus).random
              agrau1 = NArray.float(def_vect, pnode, pgaus)
              agrau2 = NArray.float(def_vect, pnode, pgaus)

              stats1[i] = k1.run(pgaus, pnode, def_vect, ndime, gpden, gpadv, gpcar, agrau1)
              stats2[i] = k2.run(pgaus, pnode, def_vect, ndime, gpden, gpadv, gpcar, agrau2)
              checker[i] = agrau1 == agrau2
            }
            
            t = []
            t[1] = stats1.inject(0){|sum,e| sum+e[:duration]} / stats1.length
            t[2] = stats2.inject(0){|sum,e| sum+e[:duration]} / stats2.length
            t
            
            # checker.include? false
    #+END_SRC

    #+RESULTS:
    | hline | 3.4143904999999938e-06 | 3.3715627999999837e-06 |
    
**** Trying using vectors
      This does not compile but the generated C code is correct.
     #+BEGIN_SRC ruby :tangle 
       require 'BOAST'
       include BOAST
       require 'narray'

       set_array_start(0)
       set_lang(C)
       #set_model(:sandybridge)

       vector_length = 4
       x = Int("x", :dir => :in)

       a = Int("a", :vector_length => vector_length, :dir => :in, :dim => [Dim(x)])
       b = Int("b", :vector_length => vector_length, :dir => :in, :dim => [Dim(x)])
       c = Int("c", :vector_length => vector_length, :dir => :out, :dim => [Dim(x)])


       p1 = Procedure("foo", [x,a,b,c]){
         decl i = Int("i")
         pr For(i,0,x){
           pr c[i] === a[i] + b[i]
         }
       }

       k1 = p1.ckernel

       # k1.build
     #+END_SRC

     #+RESULTS:
     : void foo(const int32_t x, const __m128i * a, const __m128i * b, __m128i * c){
     :   int32_t i;
     :   for (i = 0; i <= x; i += 1) {
     :     c[i] = _mm_add_epi32( a[i], b[i] );
     :   }
     : }

      Working vector c code:
      #+BEGIN_SRC C :tangle /tmp/vec2.c
        #include<stdio.h>
        #include<stdint.h>
        #include <emmintrin.h>

        #define SIZE 12
        #define VEC_LEN 4

        void foo(const int32_t x, const __m128i *a, const __m128i *b, __m128i * c){
            int i;
            for(i = 0; i < x; i++){
                c[i] = _mm_add_epi32( a[i], b[i] );
            }
        }

        void print128_num(__m128i *var, int32_t size)
        {
            int i;
            /* printf("Numerical:"); */
            for(i = 0; i < size; i++){
                uint32_t *val = (uint32_t*) &var[i];
                printf("%i %i %i %i ", 
                       val[0], val[1], val[2], val[3]);
            }
            printf("\n");
        }

        int main (int argc, char **argv){
            int32_t size = SIZE/VEC_LEN;
            int32_t t1[SIZE] = {1,2,3,4,5,6,7,8};
            int32_t t2[SIZE] = {8,7,6,5,4,3,2,1};

            int i;
            unsigned int seed1 = 3;
            unsigned int seed2 = 8;

            for(i = 0; i < SIZE; i++){
                t1[i] = rand_r(&seed1) % 10;
            }

            for(i = 0; i < SIZE; i++){
                t2[i] = rand_r(&seed2) % 10;
            }
            
            for(i = 0; i < SIZE; i++){
                printf("%d ", t1[i]);
            }
            printf("\n");

            for(i = 0; i < SIZE; i++){
                printf("%d ", t2[i]);
            }
            printf("\n");
            
            /* __m128i a = _mm_set_epi32(4, 3, 2, 1); */
            /* __m128i b = _mm_set_epi32(7, 6, 5, 4); */
            __m128i *a;
            __m128i *b;
            __m128i *c = malloc(sizeof(__m128i)*size);

            a = (__m128i*) t1;
            b = (__m128i*) t2;

            foo(size,a,b,c);

            print128_num(c, size);
            return 0;
        }
      #+END_SRC

      1D arrays:
     #+BEGIN_SRC ruby 
       require 'BOAST'
       include BOAST
       require 'narray'

       set_array_start(0)

       v_len = 1
       x = Int("x", :dir => :in)
       a = Int("a", :dir => :in, :dim => [Dim(x)])
       b = Int("b", :dir => :in, :dim => [Dim(x)])
       c = Int("c", :dir => :out, :dim => [Dim(x)])

       p1 = Procedure::new("foo", [x,a,b,c]){      
         decl i = Int("i")       
         if get_lang == CL or get_lang == CUDA then
           decl a1 = Int("a1", :vector_length => v_len)
           decl b1 = Int("b1", :vector_length => v_len)
           decl c1 = Int("c1", :vector_length => v_len)

           pr i === get_global_id(0) * v_len
           pr a1 === a[i]
           pr b1 === b[i]
           pr c1 === c[i]
           pr c1 === a1 + b1
           pr c[i] === c1
           
         else
           decl a1 = Int("a1", :vector_length => v_len, :dim => [Dim(x/v_len)], :allocate => true)
           decl b1 = Int("b1", :vector_length => v_len,  :dim => [Dim(x/v_len)], :allocate => true)
           decl c1 = Int("c1", :vector_length => v_len, :dim => [Dim(x/v_len)], :allocate => true)
           
           expr = [a1[i] === a[i*v_len], 
                   b1[i] === b[i*v_len],
                   c1[i] === c[i*v_len],
                   c1[i] === a1[i] + b1[i],
                   c[i*v_len] === c1[i]]

           pr For(i, 0, x/v_len-1){
             expr.each{|e| pr e}
           }
         end
       }

       set_lang(CL)
       k1 = p1.ckernel
       k1.build

       set_lang(C)
       k2 = CKernel::new
       BOAST::get_output.puts "#include <emmintrin.h>"             
       pr p1
       k2.procedure = p1
       k2.build

       x = 512
       NArray.srand(10)
       a = NArray.int(x).random!(x)
       b = NArray.int(x).random!(x)
       c1 = NArray.int(x)
       c2 = NArray.int(x)

       k1.run(x,a,b,c1,:global_work_size => [512,1,1], :local_work_size => [128, 1, 1])
       k2.run(x,a,b,c2,:global_work_size => [128,1,1], :local_work_size => [128, 1, 1])
       c1 == c2
  
     #+END_SRC

     #+RESULTS:
     : true

      2D arrays:
     #+BEGIN_SRC ruby :tangle /tmp/vec2D.rb
       require 'BOAST'
       include BOAST
       require 'narray'

       set_array_start(0)

       v_len = 4
       x = Int("x", :dir => :in)
       a = Int("a", :dir => :in, :dim => [Dim(x),Dim(x)])
       b = Int("b", :dir => :in, :dim => [Dim(x),Dim(x)])
       c = Int("c", :dir => :out, :dim => [Dim(x),Dim(x)])

       p1 = Procedure::new("foo", [x,a,b,c]){      
         decl i = Int("i")       
         decl j = Int("j")       
         if get_lang == CL or get_lang == CUDA then
           decl a1 = Int("a1", :vector_length => v_len)
           decl b1 = Int("b1", :vector_length => v_len)
           decl c1 = Int("c1", :vector_length => v_len)

           pr i === get_global_id(0) * v_len
           pr j === get_global_id(1)
           pr a1 === a[i,j]
           pr b1 === b[i,j]
           pr c1 === a1 + b1
           pr c[i,j] === c1           
         else
           decl a1 = Int("a1", :vector_length => v_len, :dim => [Dim(x/v_len),Dim(x)], :allocate => true)
           decl b1 = Int("b1", :vector_length => v_len, :dim => [Dim(x/v_len),Dim(x)], :allocate => true)
           decl c1 = Int("c1", :vector_length => v_len, :dim => [Dim(x/v_len),Dim(x)], :allocate => true)
           
           pr For(j, 0, x-1){
             pr For(i, 0, x/v_len-1){
               pr a1[i,j] === a[i*v_len,j]
               pr b1[i,j] === b[i*v_len,j]
               pr c1[i,j] === c[i*v_len,j]
               pr c1[i,j] === a1[i,j] + b1[i,j]
               pr c[i*v_len,j] === c1[i,j]
             }
           }
         end
       }

       set_lang(CL)
       k1 = p1.ckernel
       k1.build

       set_lang(C)
       k2 = CKernel::new
       BOAST::get_output.puts "#include <emmintrin.h>"             
       pr p1
       k2.procedure = p1
       k2.build

       x = 512
       NArray.srand(10)
       a = NArray.int(x,x).random!(10)
       b = NArray.int(x,x).random!(10)
       c1 = NArray.int(x,x)
       c2 = NArray.int(x,x)

       k1.run(x,a,b,c1,:global_work_size => [128,512,1], :local_work_size => [128, 1, 1])
       k2.run(x,a,b,c2,:global_work_size => [1024,8,1], :local_work_size => [128, 1, 1])
       c1 == c2
     #+END_SRC

     #+RESULTS:
     #+begin_example
     #include <emmintrin.h>
     void foo(const int32_t x, const int32_t * a, const int32_t * b, int32_t * c){
       int32_t i;
       int32_t j;
       __m128i a1[(x)*((x) / (4))];
       __m128i b1[(x)*((x) / (4))];
       __m128i c1[(x)*((x) / (4))];
       for (j = 0; j <= x - (1); j += 1) {
         for (i = 0; i <= (x) / (4) - (1); i += 1) {
           a1[i + ((x) / (4)) * (j)] = _mm_loadu_si128( &a[(i) * (4) + (x) * (j)] );
           b1[i + ((x) / (4)) * (j)] = _mm_loadu_si128( &b[(i) * (4) + (x) * (j)] );
           c1[i + ((x) / (4)) * (j)] = _mm_loadu_si128( &c[(i) * (4) + (x) * (j)] );
           c1[i + ((x) / (4)) * (j)] = _mm_add_epi32( a1[i + ((x) / (4)) * (j)], b1[i + ((x) / (4)) * (j)] );
           _mm_storeu_si128( (__m128i * ) &c[(i) * (4) + (x) * (j)], c1[i + ((x) / (4)) * (j)] );
         }
       }
     }
#+end_example

     #+BEGIN_SRC ruby :tangle /tmp/vec2D.rb
       require 'BOAST'
       include BOAST
       require 'narray'

       set_array_start(0)

       v_len = 4
       x = Int("x", :dir => :in)
       a = Int("a", :dir => :in, :dim => [Dim(x),Dim(x)])

       p = Procedure::new("foo", [x,a]){      
         decl a1 = Int("a1", :vector_length => v_len, :dim => [Dim(x/v_len),Dim(x)], :allocate => true)         
         pr a1 === a
       }

       set_lang(FORTRAN)
       k = CKernel::new
       if get_lang == C then
         BOAST::get_output.puts "#include <emmintrin.h>"             
       end
       pr p
       k.procedure = p
       k.build

       x = 512
       NArray.srand(10)
       a = NArray.int(x,x).random!(10)

       k.run(x,a)
       k
     #+END_SRC

     #+RESULTS:
****** Verifying vectors
       #+BEGIN_SRC ruby
         require 'BOAST'
         include BOAST
         require 'narray'

         v_len = 2
         x = Int("x", :dir => :in)
         a = Real("a", :dir => :in, :dim => [Dim(v_len),Dim(x)])
         b = Real("b", :dir => :in, :dim => [Dim(v_len),Dim(x)])
         c = Real("c", :dir => :out, :dim => [Dim(v_len),Dim(x)])

         p1 = Procedure::new("foo", [x,a,b,c]){      
           decl i = Int("i")       
           decl a1 = Real("a1", :vector_length => v_len)
           decl b1 = Real("b1", :vector_length => v_len)
           decl c1 = Real("c1", :vector_length => v_len)
           
           pr For(i,1,x){
             pr a1 === a[1,i]
             pr b1 === b[1,i]
             pr c1 === a1 + b1
             pr c[1,i] === c1
           }
         }

         p2 = Procedure::new("bar", [x,a,b,c]){      
           decl i = Int("i")       
           decl j = Int("j")       

           pr For(i,1,x){
             pr For(j,1,v_len){
               pr c[j,i] === a[j,i] + b[j,i]
             }
           }
         }

         set_lang(FORTRAN)
         k1 = CKernel::new
         BOAST::get_output.puts "#include <emmintrin.h>"             
         pr p1
         k1.procedure = p1
         k1.build

         set_lang(C)
         k2 = p2.ckernel

         x = 8
         NArray.srand(10)
         a = NArray.float(v_len,x).random(x)
         b = NArray.float(v_len,x).random(x)
         c1 = NArray.float(v_len,x)
         c2 = NArray.float(v_len,x)

         k1.run(x,a,b,c1)
         k2.run(x,a,b,c2)
         c1 == c2

       #+END_SRC

       #+RESULTS:
       : true

****** Vectorizing first loop
     #+BEGIN_SRC ruby
       require 'BOAST'
       include BOAST
       require 'narray'
       set_lang(FORTRAN)

       pgaus = Int("pgaus", :dir => :in)
       pnode = Int("pnode", :dir => :in)
       def_vect = Int("def_vect", :dir => :in)
       ndime = Int("ndime", :dir => :in)
       gpden = Real("gpden", :vector_length => 2, :dir => :in, :dim => [Dim(def_vect),Dim(pgaus)])
       gpadv = Real("gpadv", :vector_length => 2, :dir => :in, :dim => [Dim(def_vect),Dim(ndime),Dim(pgaus)])
       gpcar = Real("gpcar", :vector_length => 2, :dir => :in, :dim => [Dim(def_vect),Dim(ndime),Dim(pnode),Dim(pgaus)])
       agrau = Real("agrau", :vector_length => 2, :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])


       p1 = Procedure::new("foo",[pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau]){
         decl igaus = Int("igaus")
         decl inode = Int("inode")
         pr For(igaus,1,pgaus){
           pr For(inode,1,pnode){

           }
         }
       }
       k1 = p1.ckernel

     #+END_SRC

     #+RESULTS:
     #+begin_example
     SUBROUTINE foo(pgaus, pnode, def_vect, ndime, gpden, gpadv, gpcar, agr&
     &au)
       integer, parameter :: wp=kind(1.0d0)
       integer(kind=4), intent(in) :: pgaus
       integer(kind=4), intent(in) :: pnode
       integer(kind=4), intent(in) :: def_vect
       integer(kind=4), intent(in) :: ndime
       real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpden
       real(kind=8), intent(in), dimension(def_vect, ndime, pgaus) :: gpadv
       real(kind=8), intent(in), dimension(def_vect, ndime, pnode, pgaus) :&
     &: gpcar
       real(kind=8), intent(out), dimension(def_vect, pnode, pgaus) :: agra&
     &u
     END SUBROUTINE foo
#+end_example

**** Generic 
       #+BEGIN_SRC ruby
         require 'BOAST'
         include BOAST

         pgaus = Int("pgaus", :dir => :in)
         pnode = Int("pnode", :dir => :in)
         def_vect = Int("def_vect", :dir => :in)
         gpden = Real("gpden", :dir => :in, :dim => [Dim(def_vect),Dim(pgaus)])
         gpadv = Real("gpadv", :dir => :in, :dim => [Dim(def_vect),Dim(pgaus)])
         gpcar = Real("gpcar", :dir => :in, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])
         agrau = Real("agrau", :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])
         wgrgr = Real("wgrgr", :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pnode),Dim(pgaus)])

         orig1 = Procedure("orig1", [pgaus,pnode,def_vect,gpden,gpadv,agrau,wgrgr]){
           decl igaus = Int("igaus")
           decl inode = Int("inode")

           pr For(igaus,1,pgaus){
             pr For(inode,1,pnode){
# pr agrau[1..def_vect,inode,igaus]
               # pr agrau[1..def_vect,inode,igaus] === gpden[1..def_vect,igaus] * ( 
               #                                       gpadv[1..def_vect,igaus]*gpcar[1..def_vect,inode,igaus])
             }
           }
         }

         k = orig1.ckernel
         k

       #+END_SRC

       #+RESULTS:
=SUBROUTINE orig1(pgaus, pnode, def_vect, gpden, gpadv, agrau, wgrgr)
  integer, parameter :: wp=kind(1.0d0)
  integer(kind=4), intent(in) :: pgaus
  integer(kind=4), intent(in) :: pnode
  integer(kind=4), intent(in) :: def_vect
  real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpden
  real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpadv
  real(kind=8), intent(out), dimension(def_vect, pnode, pgaus) :: agra&
&u
  real(kind=8), intent(out), dimension(def_vect, pnode, pnode, pgaus) &
&:: wgrgr
  integer(kind=4) :: igaus
  integer(kind=4) :: inode
  do igaus = 1, pgaus, 1
    do inode = 1, pnode, 1
    end do
  end do
END SUBROUTINE orig1
*** Model
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      
      set_model(:knl)
      set_lang(C)
      v_len = 8
      
      p = Procedure("p"){
        decl x = Real("x", :vector_length => v_len)
        decl y = Real("y", :vector_length => v_len)
        pr y === x + y
      }

      k = p.ckernel
      # k.build
      k
    #+END_SRC

    #+RESULTS:
    : void p(){
    :   __m512d x;
    :   __m512d y;
    :   y = _mm512_add_pd( x, y );
    : }

*** Vector addition: Loop vs vectorization
       Code not portable, vector style works only in Fortran.
       #+BEGIN_SRC ruby
         require 'BOAST'
         include BOAST

         s = Int("s")
         a = Real("a", :dir => :in, :dim => [Dim(s)])
         b = Real("b", :dir => :in, :dim => [Dim(s)])
         c = Real("c", :dir => :out, :dim => [Dim(s)])

         p1 = Procedure("p1", [s,a,b,c]){
           decl i = Int("i")
           pr For(i,0,s){
             pr c[i] === a[i] + b[i]
           }
         }

         p2 = Procedure("p2", [s,a,b,c]){
           pr  c === a + b
         }


         set_array_start(0)
         set_lang(FORTRAN)
         k1 = p1.ckernel
         k2 = p2.ckernel
         BOAST::verbose = true
         # k1.build(:FCFLAGS => "-ftree-vectorize")
         # k1.build(:FCFLAGS => "-O3")


         stats1 = []
         stats2 = []

         s = 128

         1000.times{ |i|

           a = NArray.float(s).random
           b = NArray.float(s).random
           c = NArray.float(s)

           stats1[i] = k1.run(s, a, b, c, :global_work_size => [1024,1024,1], :local_work_size => [32, 32, 1])
           stats2[i] = k2.run(s, a, b, c, :global_work_size => [1024,1024,1], :local_work_size => [32, 32, 1])

         }

         t = []
         t[1] = stats1.inject(0){|sum,e| sum+e[:duration]} / stats1.length
         t[2] = stats2.inject(0){|sum,e| sum+e[:duration]} / stats2.length

         k1
       #+END_SRC

       #+RESULTS:
       #+begin_example
       SUBROUTINE p1(s, a, b, c)
         integer, parameter :: wp=kind(1.0d0)
         integer(kind=4) :: s
         real(kind=8), intent(in), dimension(0:s - (1)) :: a
         real(kind=8), intent(in), dimension(0:s - (1)) :: b
         real(kind=8), intent(out), dimension(0:s - (1)) :: c
         integer(kind=4) :: i
         do i = 0, s, 1
           c(i) = a(i) + b(i)
         end do
       END SUBROUTINE p1
#+end_example
       
*** Unrolling
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      # set_array_start(0)
      def gen(step)
        a = Int("a",:dir => :out, :dim => [Dim(10)]) 

        p1 = Procedure::new("p1",[a]){
          decl i = Int("i")
          decl j = Int("j")
          pr For(i,1,10,:step => step){
            pr For(j,0,step-1){
              pr a[i+j] === a[i+j] + i+j
            }.unroll
          }
        }
        set_lang(C)
        k = p1.ckernel
        return k
      end

      k = gen(5)
      k.build
      a = NArray.int(10).random!(20)
      k.run(a)
      k
    #+END_SRC

    #+RESULTS:
    #+begin_example
    void p1(int32_t * a){
      int32_t i;
      int32_t j;
      for (i = 1; i <= 10; i += 5) {
        a[i + 0 - (1)] = a[i + 0 - (1)] + i + 0;
        a[i + 1 - (1)] = a[i + 1 - (1)] + i + 1;
        a[i + 2 - (1)] = a[i + 2 - (1)] + i + 2;
        a[i + 3 - (1)] = a[i + 3 - (1)] + i + 3;
        a[i + 4 - (1)] = a[i + 4 - (1)] + i + 4;
      }
    }
#+end_example

*** Copying external function
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST

      body = <<EOF
      subroutine foo(x,y) 
        integer, intent(in) :: x(10)
        integer, intent(out) :: y(10)
        y = 2*x
      end subroutine foo
      EOF

      x = Int("x", :dir => :in, :dim => [Dim(10)])
      y = Int("y", :dir => :out, :dim => [Dim(10)])
      p = Procedure::new("foo", [x,y])
      k = CKernel::new
      k.procedure = p
      get_output.print body
      k.build
      x = NArray.int(10).random!(20)
      y = NArray.int(10)
      k.run(x,y)
      y
    #+END_SRC

    #+RESULTS:
    : NArray.int(10): 
    : [ 22, 16, 36, 22, 12, 8, 22, 22, 10, 28 ]

*** Calling a function
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      x = Int("x", :dir => :in)               
      y = Int("y")               
      a = Int("a", :dir => :inout, :dim => [Dim(x)])                

      p1 = Procedure("p1", [x],:return => y){
          pr y === 1
      }

      set_lang(FORTRAN)
      k1 = CKernel::new
      k1.procedure = p1

      k1.build
      k2 = CKernel::new(:kernels =>[k1])
      p2 = Procedure("p2",[x,a]){
        decl i = Int("i")
        pr For(i,1,x){
          pr a[i] === a[i] + k1.procedure.call(x)        
        }
      }

      pr p1
      pr p2
      k2.procedure = p2
           
      x = 10
      a = NArray.int(x)
      puts k2
      k2.build
      k2.run(x,a)
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      x = Int("x", :dir => :in)               
      y = Int("y")               
      a = Int("a", :dir => :inout, :dim => [Dim(x)])                

      p1 = Procedure("p1", [x],:return => y){
        pr y === 1
      }

      set_lang(FORTRAN)
      k1 = CKernel::new
      k1.procedure = p1

      k1.build
      k2 = CKernel::new
      p2 = Procedure("p2",[x,a],:functions => [p1]){
        decl i = Int("i")
        pr For(i,1,x){
          pr a[i] === a[i] + k1.procedure.call(x)        
        }
      }

      pr p1
      pr p2
      k2.procedure = p2

      x = 10
      a = NArray.int(x)
      puts k2
      k2.build
      k2.run(x,a)

    #+END_SRC

    #+RESULTS:
    | :duration=>1.037e-06 |

*** Modular loops
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      decl a = Int("a", :dir => :inout, :dim => [Dim(4)])

      p = Procedure("foo",[a]){
        decl i = Int("i")
        decl j = Int("j")
        decl b = Int("b")

        f1 = For(i,1,3)
        f2 = For(j,1,4)
        pr b === 0

        opn f2
          opn f1
            pr b === b + 1
            pr a[j] === b
          close f1
        close f2
      }

      k = p.ckernel
      k.build
      a = NArray.int(4)
      k.run(a)
      a
                
    #+END_SRC

    #+RESULTS:
    : NArray.int(4): 
    : [ 3, 6, 9, 12 ]

    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      decl a = Int("a", :dir => :inout, :dim => [Dim(4)])

      p = Procedure("foo",[a]){
        decl i = Int("i")
        decl j = Int("j")
        decl b = Int("b")

        (2..3).each{|dim|
        f1 = For(i,1,3)
        f2 = For(j,1,dim)
        block = lambda {
            pr b === b + 1
            pr a[j] === b
        }

        pr b === 0
       
        f4 = lambda{ pr f2.unroll, &block}

        lambda{ pr f1, &f4}.call
        }
      }

      k = p.ckernel
      k.build
      a = NArray.int(4)
      # k.run(a)
      # a
      k
                
    #+END_SRC

    #+RESULTS:
    #+begin_example
    SUBROUTINE foo(a)
      integer, parameter :: wp=kind(1.0d0)
      integer(kind=4), intent(inout), dimension(4) :: a
      integer(kind=4) :: i
      integer(kind=4) :: j
      integer(kind=4) :: b
      b = 0
      do i = 1, 3, 1
        b = b + 1
        a(1) = b
        b = b + 1
        a(2) = b
      end do
      b = 0
      do i = 1, 3, 1
        b = b + 1
        a(1) = b
        b = b + 1
        a(2) = b
        b = b + 1
        a(3) = b
      end do
    END SUBROUTINE foo
#+end_example

    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      p = Procedure("foo"){
        decl inode = Int("inode")
        decl jnode = Int("jnode")
        decl idime = Int("idime")
        decl jdime = Int("jdime")
        decl igaus = Int("igaus")
        decl idofv = Int("idofv")
        decl jdofv = Int("jdofv")

        decl pnode = Int("pnode")
        decl ndime = Int("ndime")
        decl pgaus = Int("pgaus")
        decl gpvis = Int("gpvis", :dim => [Dim(1),Dim(5)])
        decl gpvol = Int("gpvol", :dim => [Dim(1),Dim(5)])
        decl gpcar = Int("gpcar", :dim => [Dim(1),Dim(3),Dim(5)])
        decl elauu = Int("elauu", :dim => [Dim(1),Dim(5),Dim(5)])
        decl fact1 = Int("fact1")
        
        for_inode = For(inode,1,pnode)
        for_jnode = For(jnode,1,pnode)
        for_idime = For(idime,1,ndime)

        for_jdime = lambda{|dim|
          return For(jdime,1,dim)
        }

        block1 = lambda{
          pr fact1 === gpvis[1,igaus] * gpvol[1,igaus] * gpcar[1,idime,jnode,igaus]
        }

        block2 = lambda{
          pr idofv === (inode-1)*ndime + idime
        }

        block3 = lambda{
          # pr jdofv === (jnode-1)*ndime + jdime
          pr jdofv === ndime + jdime
          # pr elauu[1,idofv,jdofv] === elauu[1,idofv,jdofv] * fact1 * gpcar[1,idime,inode,igaus]
        }

        dim = 3

        pr For(igaus,1,pgaus){ 
          opn for_inode
          opn for_idime
          # block2.call
          opn for_jnode
          block1.call
          lambda{ pr for_jdime.call(dim).unroll, &block3 }.call
          close for_jnode
          close for_idime
          close for_inode
        }
        
      }
      k = p.ckernel
    #+END_SRC

    #+RESULTS:
    #+begin_example
    SUBROUTINE foo()
      integer, parameter :: wp=kind(1.0d0)
      integer(kind=4) :: inode
      integer(kind=4) :: jnode
      integer(kind=4) :: idime
      integer(kind=4) :: jdime
      integer(kind=4) :: igaus
      integer(kind=4) :: idofv
      integer(kind=4) :: jdofv
      integer(kind=4) :: pnode
      integer(kind=4) :: ndime
      integer(kind=4) :: pgaus
      integer(kind=4), dimension(1, 5) :: gpvis
      integer(kind=4), dimension(1, 5) :: gpvol
      integer(kind=4), dimension(1, 3, 5) :: gpcar
      integer(kind=4), dimension(1, 5, 5) :: elauu
      integer(kind=4) :: fact1
      do igaus = 1, pgaus, 1
        do inode = 1, pnode, 1
          do idime = 1, ndime, 1
            do jnode = 1, pnode, 1
              fact1 = ((gpvis(1, igaus)) * (gpvol(1, igaus))) * (gpcar(1, &
    &idime, jnode))
              jdofv = ndime + 1
              jdofv = ndime + 2
              jdofv = ndime + 3
            end do
          end do
        end do
      end do
    END SUBROUTINE foo
#+end_example

*** Inlining
    #+BEGIN_SRC ruby 
      require 'BOAST'
      include BOAST

      set_lang(FORTRAN)

      def generate_p(inline = false)
        x = Int("x", :dim => [Dim(10)], :dir => :in)
        y = Int("y", :dim => [Dim(10)], :dir => :inout)
        z = Int("z")

        block = lambda{
          decl i = Int("i")
          pr For(i,1,10){
            pr y[i] === x[i] * 2
          }
        }
       
        p = Procedure("p", [x,y], :return => z, :inline => inline, &block)
        k1 = p.ckernel 

        q = Procedure("q", [x,y], :functions => [p]){
          pr y === x + 2
          if inline then
            pr p.call(x,  y )
          else
            block.call
          end
        }

        k2 = CKernel::new
        pr p if inline
        pr q
        k2.procedure = q
        return k2
      end

      NArray.srand(10)
      x = NArray.int(10).random!(9)
      y = NArray.int(10)

      # ks = {:false => generate_p(false), :true => generate_p(true)}
      # 10.times{|i|
      #   ks.each{|k,v|
      #     v.run(x,y)
      #   }
      # }
      # ks  
generate_p(false)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    SUBROUTINE q(x, y)
      integer, parameter :: wp=kind(1.0d0)
      integer(kind=4), intent(in), dimension(10) :: x
      integer(kind=4), intent(inout), dimension(10) :: y
      integer(kind=4) :: p
      y = x + 2
      integer(kind=4) :: i
      do i = 1, 10, 1
        y(i) = (x(i)) * (2)
      end do
    END SUBROUTINE q
#+end_example

*** Loop tiling
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST

      def getstartend(x,block)
        return [[{:start => x-x%block+1, :end => x}, {:start => 1, :end => x-x%block}],
                [{:start => 1, :end => x-x%block}, {:start => x-x%block+1, :end => x}],
                [{:start => x-x%block+1, :end => x}, {:start => x-x%block+1, :end => x}]]
      end

      def gen(block)
        x = Int("x", :dir => :in)
        a = Int("a", :dir => :in, :dim => [Dim(x),Dim(x)])
        b = Int("b", :dir => :in, :dim => [Dim(x),Dim(x)])
        c = Int("c", :dir => :out, :dim => [Dim(x),Dim(x)])

        p = Procedure("p",[x,a,b,c]){
          decl i = Int("i")
          decl j = Int("j")

          exp1 = c[j,i] === c[j,i] + a[j,i] + b[i,j]

          if block > 1 then
            decl ii = Int("ii")
            decl jj = Int("jj")
            
            exp = For(ii,i,i+block-1){
              pr For(jj,0,block-1){
                pr c[jj+j,ii] === c[jj+j,ii] + a[jj+j,ii] + b[ii,jj+j]
              }.unroll
            }
            
            bounds = getstartend(x,block)

            block_remaining = lambda{
              pr If(x%block != 0){
                bounds.each{|e|
                  pr For(i,e[0][:start],e[0][:end]){
                    pr For(j,e[1][:start],e[1][:end]){
                      pr exp1
                    }
                  }
                }
              }
            }
          else
            exp = exp1
          end

          pr For(i,1,x-block+1, :step => block){
            pr For(j,1,x-block+1, :step => block){
              pr exp
            }
          }
          block_remaining.call if block > 1
        }
        k = p.ckernel
        return k
      end

      set_lang(C)
      blk = {:block1 => 1, :block2 => 64}
      kernels = {:block1 => 1, :block2 => 2}

      blk.each{|k,v|
        kernels[k] = gen(v)
        puts kernels[k]
        kernels[k].build
      }

      x = 1024
      c = {:block1 => [], :block2 => []}
      stats = {:block1 => [], :block2 => []}

      1000.times{|i|
        a = NArray.int(x,x).random!(999)
        b = NArray.int(x,x).random!(999)
        blk.each_key{|j|
          c[j] = NArray.int(x,x)
          stats[j][i] = kernels[j].run(x,a,b,c[j])
        }
        raise "Not correct" if ((c[:block1] - c[:block2]).abs > 0).to_a.flatten.include? 1 
      }

      res = {}
      blk.each_key{|k|
        res[k] = stats[k].inject(0){|sum,e| sum+e[:duration]} / stats[k].length
      }

      puts res
      # x.times{|i|
      #   s = ""
      #   x.times{|j|
      #     s += "#{c[0].to_a[j][i]} "
      #   }
      #   puts s
      # }

    #+END_SRC
** Ruby
*** Meta
**** Eval string of string 
    This one would be good but it does not work, it fails to find the
    variable i:
    #+BEGIN_SRC ruby 
      exp1 = ""
      code=<<EOF
        dim = 3
        dim.times{|i|
          exp1 += "v_gpadv[#{i+1}]"
          exp1 +=  " + " if i+1 < dim
        }
      EOF
      eval code
      exp1
    #+END_SRC

    #+RESULTS:

     This solution works but is a little bit ugly, it is more
     difficult to read the expression:
    #+BEGIN_SRC ruby 
      exp1 = ""
      code=<<EOF
        dim = 3
        dim.times{|i|
          exp1 += "v_gpadv[" + (i+1).to_s + "]"
          exp1 +=  " + " if i+1 < dim
        }
      EOF
      eval code
      exp1
    #+END_SRC

    #+RESULTS:

     This one is better, we can still read the expression and it is
     concise:
     #+BEGIN_SRC ruby 
      exp1 = ""
      code=<<EOF
        dim = 3
        dim.times{|i|
          exp1 += sprintf("v_gpadv[%d]", i)
          exp1 +=  " + " if i+1 < dim
        }
      EOF
      eval code
      exp1     
     #+END_SRC

     #+RESULTS:
     : v_gpadv[0] + v_gpadv[1] + v_gpadv[2]

     #+BEGIN_SRC ruby 
     a = "a_1"
     b = "b_1"
     a_1 = [1,2,3]
     b_1 = [4,5,6]
     i = 2
     exp = "#{a_1}[#{i}] + #{b_1}[#{i}]"
     eval exp
     #+END_SRC

     #+RESULTS:
     : 9

**** Generate array of blocks
     - Array of a block
       #+BEGIN_SRC ruby
         exp1 = ["",""]
         x = []
         2.times{|j|
           x[j] = Proc.new{
             dim = j+2
             dim.times{|i|
               exp1[j] += "v_gpadv[" + (i+1).to_s + "]*v_gpcar[" + (i+1).to_s + "]"
               exp1[j] +=  " + " if i+1 < dim
             }
           }
         }
         x[0].call
         x[1].call
         exp1
       #+END_SRC

       #+RESULTS:
     | v_gpadv[1]*v_gpcar[1] + v_gpadv[2]*v_gpcar[2] | v_gpadv[1]*v_gpcar[1] + v_gpadv[2]*v_gpcar[2] + v_gpadv[3]*v_gpcar[3] |

     - Array of For:
       #+BEGIN_SRC ruby 
         require 'BOAST'
         include BOAST

         x = Int("x", :dir => :in)
         a = Int("a", :dir => :in, :dim => [Dim(x)])
         b = Int("b", :dir => :in, :dim => [Dim(x)])
         c = Int("c", :dir => :in, :dim => [Dim(x)])

         p = Procedure("foo",[x,a,b,c]){         
           decl i = Int("i")
           for1 = []
           3.times{|j|
             for1[j] =  For(i,0,x){
               pr c[i] === a[i] * j  + b[i] * j
             }
           }
           pr for1[1]
           pr for1[2]
         }
         k = p.ckernel
       #+END_SRC

       #+RESULTS:
       #+begin_example
       SUBROUTINE foo(x, a, b, c)
         integer, parameter :: wp=kind(1.0d0)
         integer(kind=4), intent(in) :: x
         integer(kind=4), intent(in), dimension(x) :: a
         integer(kind=4), intent(in), dimension(x) :: b
         integer(kind=4), intent(in), dimension(x) :: c
         integer(kind=4) :: i
         do i = 0, x, 1
           c(i) = (a(i)) * (1) + (b(i)) * (1)
         end do
         do i = 0, x, 1
           c(i) = (a(i)) * (2) + (b(i)) * (2)
         end do
       END SUBROUTINE foo
#+end_example

     
