#+TITLE:  LabBook
#+AUTHOR: Steven QUINITO MASNADA
#+BABEL: :tangle yes
#+TAGS: Arnaud(a) Brice(b) Script(s) Analysis (c) Ruby(r) R(t) deprecated(d) Modifications(m) noexport(n)

* Todo 
  - [ ] Finish alya kernel
      DEADLINE: <2016-11-10 jeu.> 
* 2016
** October
*** 2016-10-04
**** Meeting Alya
     Loops \to subroutine, inlining.
     Make tutorial to explain the steps.
     24th October telco 14h.
**** Tutorial
***** Original Fortran source code
     #+BEGIN_SRC fortran
             subroutine nsi_element_assembly_split_oss(&
             pnode,pgaus,pevat,gpden,gpvis,gppor,gpsp1,gpsp2,&
             gpvol,gpsha,gpcar,gpadv,gpvep,gpprp,gpgrp,gprhs,&
             gpvel,gpsgs,wgrgr,agrau,elvel,elauu,elaup,elapp,&
             elapu,elrbu,elrbp,dtinv_loc,dtsgs)

             integer(ip), intent(in)    :: pnode,pgaus,pevat
             real(rp),    intent(in)    :: gpden(VECTOR_SIZE,pgaus)
             real(rp),    intent(in)    :: gpvis(VECTOR_SIZE,pgaus)
             real(rp),    intent(in)    :: gppor(VECTOR_SIZE,pgaus)
             real(rp),    intent(in)    :: gpsp1(VECTOR_SIZE,pgaus)
             real(rp),    intent(in)    :: gpsp2(VECTOR_SIZE,pgaus)
             real(rp),    intent(in)    :: gpvol(VECTOR_SIZE,pgaus)
             real(rp),    intent(in)    :: gpsha(VECTOR_SIZE,pnode,pgaus)
             real(rp),    intent(in)    :: gpcar(VECTOR_SIZE,ndime,mnode,pgaus)
             real(rp),    intent(in)    :: gpadv(VECTOR_SIZE,ndime,pgaus)
             real(rp),    intent(inout) :: gpvep(VECTOR_SIZE,ndime,pgaus)
             real(rp),    intent(inout) :: gpprp(VECTOR_SIZE,pgaus)      
             real(rp),    intent(inout) :: gpgrp(VECTOR_SIZE,ndime,pgaus)
             real(rp),    intent(inout) :: gprhs(VECTOR_SIZE,ndime,pgaus)
             real(rp),    intent(in)    :: gpvel(VECTOR_SIZE,ndime,pgaus,*)
             real(rp),    intent(in)    :: gpsgs(VECTOR_SIZE,ndime,pgaus,*)
             real(rp),    intent(out)   :: wgrgr(VECTOR_SIZE,pnode,pnode,pgaus)
             real(rp),    intent(out)   :: agrau(VECTOR_SIZE,pnode,pgaus)
             real(rp),    intent(in)    :: elvel(VECTOR_SIZE,ndime,pnode,*)
             real(rp),    intent(out)   :: elauu(VECTOR_SIZE,pnode*ndime,pnode*ndime)
             real(rp),    intent(out)   :: elaup(VECTOR_SIZE,pnode*ndime,pnode)
             real(rp),    intent(out)   :: elapp(VECTOR_SIZE,pnode,pnode)
             real(rp),    intent(out)   :: elapu(VECTOR_SIZE,pnode,pnode*ndime)
             real(rp),    intent(out)   :: elrbu(VECTOR_SIZE,ndime,pnode)
             real(rp),    intent(out)   :: elrbp(VECTOR_SIZE,pnode)
             real(rp),    intent(in)    :: dtinv_loc(VECTOR_SIZE)
             real(rp),    intent(in)    :: dtsgs(VECTOR_SIZE)
             real(rp)                   :: gpsp1_p(VECTOR_SIZE,pgaus)
             real(rp)                   :: gpsp1_v(VECTOR_SIZE,pgaus)
             real(rp)                   :: c1(VECTOR_SIZE),c2(VECTOR_SIZE)
             real(rp)                   :: c3(VECTOR_SIZE),c4(VECTOR_SIZE)
             real(rp)                   :: alpha(VECTOR_SIZE),beta(VECTOR_SIZE)
             real(rp)                   :: fact0(VECTOR_SIZE)
             real(rp)                   :: fact1(VECTOR_SIZE)
             real(rp)                   :: fact2(VECTOR_SIZE)
             real(rp)                   :: fact3(VECTOR_SIZE)
             real(rp)                   :: fact4(VECTOR_SIZE)
             real(rp)                   :: fact5(VECTOR_SIZE)
             real(rp)                   :: fact6(VECTOR_SIZE)
             real(rp)                   :: fact7(VECTOR_SIZE)
             real(rp)                   :: fact8(VECTOR_SIZE)
             real(rp)                   :: gpveo(VECTOR_SIZE,3)
             real(rp)                   :: fact1_p(VECTOR_SIZE)
             integer(ip)                :: inode,jnode,idofn,jdofn,idofv,jdof2,jdof3
             integer(ip)                :: idof1,idof3,idof2,igaus,idime,jdof1,jdofv,itime

       #ifdef OPENACC
       #define DEF_VECT ivect
       #else
       #define DEF_VECT 1:VECTOR_SIZE
       #endif

       !----------------------------------------------------------------------
       !
       ! possibility of using only pressure stabilization - not ready with limiter - nor with shock capturing
       !
       !----------------------------------------------------------------------

             gpsp1_p = gpsp1
             gpsp1_v = gpsp1
       !if(1==2) gpsp1_v = 0.0_rp
       !if(1==2) gpsp1_p = min(gpsp1_p,1.0_rp/dtinv_loc)    ! Activate this line only if runing without subscales
       ! and you want to limit tau1 like most groups do for small time step

       !----------------------------------------------------------------------
       !
       ! Initialization
       !
       !----------------------------------------------------------------------

             elrbp = 0.0_rp
             elrbu = 0.0_rp
             elapp = 0.0_rp
             elauu = 0.0_rp
             elaup = 0.0_rp
             elapu = 0.0_rp

       !----------------------------------------------------------------------
       !
       ! Test functions
       !
       !----------------------------------------------------------------------

       !
       ! AGRAU = rho * (a.grad) Ni
       ! WGRGR = grad(Ni) . grad(Nj)
       !
             if( ndime == 2 ) then

                do igaus = 1,pgaus
                   do inode = 1,pnode
                      agrau(DEF_VECT,inode,igaus) =  gpden(DEF_VECT,igaus) * (                    &
                      &                gpadv(DEF_VECT,1,igaus)*gpcar(DEF_VECT,1,inode,igaus) &
                      &              + gpadv(DEF_VECT,2,igaus)*gpcar(DEF_VECT,2,inode,igaus) )
                      do jnode = 1,pnode
                         wgrgr(DEF_VECT,inode,jnode,igaus) = &
                         &             gpcar(DEF_VECT,1,inode,igaus)*gpcar(DEF_VECT,1,jnode,igaus) &
                         &           + gpcar(DEF_VECT,2,inode,igaus)*gpcar(DEF_VECT,2,jnode,igaus) 
                      end do
                   end do
                end do

             else

                do igaus = 1,pgaus
                   do inode = 1,pnode
                      agrau(DEF_VECT,inode,igaus) =  gpden(DEF_VECT,igaus) * (                    &
                      &                gpadv(DEF_VECT,1,igaus)*gpcar(DEF_VECT,1,inode,igaus) &
                      &              + gpadv(DEF_VECT,2,igaus)*gpcar(DEF_VECT,2,inode,igaus) &
                      &              + gpadv(DEF_VECT,3,igaus)*gpcar(DEF_VECT,3,inode,igaus) )
                      do jnode = 1,pnode
                         wgrgr(DEF_VECT,inode,jnode,igaus) = &
                         &             gpcar(DEF_VECT,1,inode,igaus)*gpcar(DEF_VECT,1,jnode,igaus) &
                         &           + gpcar(DEF_VECT,2,inode,igaus)*gpcar(DEF_VECT,2,jnode,igaus) & 
                         &           + gpcar(DEF_VECT,3,inode,igaus)*gpcar(DEF_VECT,3,jnode,igaus) 
                      end do
                   end do
                end do

             end if

       !----------------------------------------------------------------------
       !
       ! Auu
       !
       !----------------------------------------------------------------------

       !
       ! Galerkin + ( tau2 * div(u) , div(v) ) + ( tau1 * rho*a.grad(u), rho*a.grad(v) )
       !
             if( ndime == 2 ) then

                do igaus = 1,pgaus

                   fact0(DEF_VECT) = gpsp2(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus)
                   fact6(DEF_VECT) = gpvis(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus)
                   fact7(DEF_VECT) = gpsp1_v(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus) 
                   fact8(DEF_VECT) = pabdf_nsi(1) * gpden(DEF_VECT,igaus) * dtinv_loc(DEF_VECT) + gppor(DEF_VECT,igaus)

                   do inode = 1,pnode

                      idof1 = 2*inode-1
                      idof2 = 2*inode

                      fact1(DEF_VECT) = fact0(DEF_VECT) * gpcar(DEF_VECT,1,inode,igaus) ! div(u) * tau2' * dv/dx
                      fact2(DEF_VECT) = fact0(DEF_VECT) * gpcar(DEF_VECT,2,inode,igaus) ! div(u) * tau2' * dv/dy
                      fact4(DEF_VECT) = gpsha(DEF_VECT,inode,igaus) * gpvol(DEF_VECT,igaus)

                      do jnode = 1,pnode    

                         jdof1 = 2*jnode-1
                         jdof2 = 2*jnode

                         fact5(DEF_VECT) = fact4(DEF_VECT) * ( agrau(DEF_VECT,jnode,igaus) + fact8(DEF_VECT) * gpsha(DEF_VECT,jnode,igaus) ) & ! ( rho/dt N_j + s Nj + rho*(a.grad)Nj ) Ni
                         &         +  fact6(DEF_VECT) * wgrgr(DEF_VECT,inode,jnode,igaus) & ! mu * grad(Ni) . grad(Nj)
                         &         +  fact7(DEF_VECT) * agrau(DEF_VECT,jnode,igaus) * agrau(DEF_VECT,inode,igaus) ! tau1 * rho*(a.grad)Nj * rho*(a.grad)Ni

                         elauu(DEF_VECT,idof1,jdof1) = elauu(DEF_VECT,idof1,jdof1) + fact1(DEF_VECT) * gpcar(DEF_VECT,1,jnode,igaus) + fact5(DEF_VECT)
                         elauu(DEF_VECT,idof2,jdof1) = elauu(DEF_VECT,idof2,jdof1) + fact2(DEF_VECT) * gpcar(DEF_VECT,1,jnode,igaus)
                         elauu(DEF_VECT,idof1,jdof2) = elauu(DEF_VECT,idof1,jdof2) + fact1(DEF_VECT) * gpcar(DEF_VECT,2,jnode,igaus) 
                         elauu(DEF_VECT,idof2,jdof2) = elauu(DEF_VECT,idof2,jdof2) + fact2(DEF_VECT) * gpcar(DEF_VECT,2,jnode,igaus) + fact5(DEF_VECT)

                      end do

                   end do
                end do

             else

                do igaus = 1,pgaus

                   fact0(DEF_VECT) = gpsp2(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus)
                   fact6(DEF_VECT) = gpvis(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus)
                   fact7(DEF_VECT) = gpsp1_v(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus)
                   fact8(DEF_VECT) = pabdf_nsi(1) * gpden(DEF_VECT,igaus) * dtinv_loc(DEF_VECT) + gppor(DEF_VECT,igaus)

                   do inode = 1,pnode

                      idof1 = 3*inode-2
                      idof2 = 3*inode-1
                      idof3 = 3*inode

                      fact1(DEF_VECT) = fact0(DEF_VECT) * gpcar(DEF_VECT,1,inode,igaus) ! div(u) * tau2' * dv/dx
                      fact2(DEF_VECT) = fact0(DEF_VECT) * gpcar(DEF_VECT,2,inode,igaus) ! div(u) * tau2' * dv/dy
                      fact3(DEF_VECT) = fact0(DEF_VECT) * gpcar(DEF_VECT,3,inode,igaus) ! div(u) * tau2' * dv/dz
                      fact4(DEF_VECT) = gpsha(DEF_VECT,inode,igaus) * gpvol(DEF_VECT,igaus)

                      do jnode = 1,pnode    

                         jdof1 = 3*jnode-2
                         jdof2 = 3*jnode-1
                         jdof3 = 3*jnode

                         fact5(DEF_VECT) = fact4(DEF_VECT) * ( agrau(DEF_VECT,jnode,igaus) + fact8(DEF_VECT) * gpsha(DEF_VECT,jnode,igaus) ) & ! ( rho/dt N_j + s Nj + rho*(a.grad)Nj ) Ni
                         +  fact6(DEF_VECT) * wgrgr(DEF_VECT,inode,jnode,igaus) & ! mu * grad(Ni) . grad(Nj)
                         +  fact7(DEF_VECT) * agrau(DEF_VECT,jnode,igaus) * agrau(DEF_VECT,inode,igaus) ! t1 * rho*(a.grad)Nj * rho*(a.grad)Ni

                         elauu(DEF_VECT,idof1,jdof1) = elauu(DEF_VECT,idof1,jdof1) + fact1(DEF_VECT) * gpcar(DEF_VECT,1,jnode,igaus) + fact5(DEF_VECT)
                         elauu(DEF_VECT,idof2,jdof1) = elauu(DEF_VECT,idof2,jdof1) + fact2(DEF_VECT) * gpcar(DEF_VECT,1,jnode,igaus)
                         elauu(DEF_VECT,idof3,jdof1) = elauu(DEF_VECT,idof3,jdof1) + fact3(DEF_VECT) * gpcar(DEF_VECT,1,jnode,igaus)

                         elauu(DEF_VECT,idof1,jdof2) = elauu(DEF_VECT,idof1,jdof2) + fact1(DEF_VECT) * gpcar(DEF_VECT,2,jnode,igaus) 
                         elauu(DEF_VECT,idof2,jdof2) = elauu(DEF_VECT,idof2,jdof2) + fact2(DEF_VECT) * gpcar(DEF_VECT,2,jnode,igaus) + fact5(DEF_VECT)
                         elauu(DEF_VECT,idof3,jdof2) = elauu(DEF_VECT,idof3,jdof2) + fact3(DEF_VECT) * gpcar(DEF_VECT,2,jnode,igaus) 

                         elauu(DEF_VECT,idof1,jdof3) = elauu(DEF_VECT,idof1,jdof3) + fact1(DEF_VECT) * gpcar(DEF_VECT,3,jnode,igaus) 
                         elauu(DEF_VECT,idof2,jdof3) = elauu(DEF_VECT,idof2,jdof3) + fact2(DEF_VECT) * gpcar(DEF_VECT,3,jnode,igaus)
                         elauu(DEF_VECT,idof3,jdof3) = elauu(DEF_VECT,idof3,jdof3) + fact3(DEF_VECT) * gpcar(DEF_VECT,3,jnode,igaus) + fact5(DEF_VECT)

                      end do

                   end do
                end do

             end if

             if( fvins_nsi > 0.9_rp ) then
       !
       ! ( mu*duj/dxi , dv/dxj ) (only div form)
       !
                if( ndime == 2 ) then
                   do igaus = 1,pgaus
                      do inode = 1,pnode
                         do idime = 1,ndime
                            idofv =  (inode-1)*ndime+idime
                            do jnode = 1,pnode
                               fact1                       = gpvis(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus) * gpcar(DEF_VECT,idime,jnode,igaus)     
                               jdofv                       = (jnode-1)*ndime + 1
                               elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,1,inode,igaus)
                               jdofv                       = (jnode-1)*ndime + 2
                               elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,2,inode,igaus)
                            end do
                            if( fvins_nsi == 2.0_rp ) then
                               fact1 = -2.0_rp/3.0_rp * gpvis(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus) * gpcar(DEF_VECT,idime,inode,igaus)
                               do jnode = 1,pnode
                                  jdofv                       = (jnode-1)*ndime + 1 
                                  elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,1,jnode,igaus)
                                  jdofv                       = (jnode-1)*ndime + 2
                                  elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,2,jnode,igaus)
                               end do
                            end if
                         end do
                      end do
                   end do
                else
                   do igaus = 1,pgaus
                      do inode = 1,pnode
                         do idime = 1,ndime
                            idofv = (inode-1)*ndime + idime
                            do jnode = 1,pnode
                               fact1                       = gpvis(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus) * gpcar(DEF_VECT,idime,jnode,igaus)     
                               jdofv                       = (jnode-1)*ndime + 1
                               elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,1,inode,igaus)
                               jdofv                       = (jnode-1)*ndime + 2
                               elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,2,inode,igaus)
                               jdofv                       = (jnode-1)*ndime + 3
                               elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,3,inode,igaus)
                            end do
                            if( fvins_nsi == 2.0_rp ) then
                               fact1                          = -2.0_rp / 3.0_rp * gpvis(DEF_VECT,igaus) * gpvol(DEF_VECT,igaus) * gpcar(DEF_VECT,idime,inode,igaus)
                               do jnode = 1,pnode
                                  jdofv                       = (jnode-1)*ndime + 1
                                  elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,1,jnode,igaus)
                                  jdofv                       = (jnode-1)*ndime + 2
                                  elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,2,jnode,igaus)
                                  jdofv                       = (jnode-1)*ndime + 3
                                  elauu(DEF_VECT,idofv,jdofv) = elauu(DEF_VECT,idofv,jdofv) + fact1(DEF_VECT) * gpcar(DEF_VECT,3,jnode,igaus)
                               end do
                            end if
                         end do
                      end do
                   end do
                end if
             end if

       !
       ! Lumped evolution matrix (only backward euler)
       !
             if( kfl_lumped == 1 ) then 
       !
       ! Remove Galerkin term and add lumped term 
       ! 
                if( ndime == 2 ) then
                   call runend('PREGUNTAR A MATIAS QUE LO PROGRAME')
                else
                   do igaus = 1,pgaus
                      gpveo(DEF_VECT,1:3) = 0.0_rp
                      do inode = 1,pnode
                         do idime = 1,ndime
                            gpveo(DEF_VECT,idime) = gpveo(DEF_VECT,idime) + elvel(DEF_VECT,idime,inode,2) * gpsha(DEF_VECT,inode,igaus)
                         end do
                      end do
                      do inode = 1,pnode
                         idof1                       = 3*inode-2
                         idof2                       = 3*inode-1
                         idof3                       = 3*inode
                         fact0(DEF_VECT)             = gpvol(DEF_VECT,igaus) * gpden(DEF_VECT,igaus) * gpsha(DEF_VECT,inode,igaus) * dtinv_loc(DEF_VECT)
                         elauu(DEF_VECT,idof1,idof1) = elauu(DEF_VECT,idof1,idof1) + fact0(DEF_VECT)
                         elauu(DEF_VECT,idof2,idof2) = elauu(DEF_VECT,idof2,idof2) + fact0(DEF_VECT)
                         elauu(DEF_VECT,idof3,idof3) = elauu(DEF_VECT,idof3,idof3) + fact0(DEF_VECT)
                         do idime = 1,ndime
                            elrbu(DEF_VECT,idime,inode) = elrbu(DEF_VECT,idime,inode) - fact0(DEF_VECT) * gpveo(DEF_VECT,idime)
                            elrbu(DEF_VECT,idime,inode) = elrbu(DEF_VECT,idime,inode) + fact0(DEF_VECT) * elvel(DEF_VECT,idime,inode,2)
                         end do
                         do jnode = 1,pnode 
                            jdof1                       = 3*jnode-2
                            jdof2                       = 3*jnode-1
                            jdof3                       = 3*jnode
                            elauu(DEF_VECT,idof1,jdof1) = elauu(DEF_VECT,idof1,jdof1) - fact0*gpsha(DEF_VECT,jnode,igaus) 
                            elauu(DEF_VECT,idof2,jdof2) = elauu(DEF_VECT,idof2,jdof2) - fact0*gpsha(DEF_VECT,jnode,igaus) 
                            elauu(DEF_VECT,idof3,jdof3) = elauu(DEF_VECT,idof3,jdof3) - fact0*gpsha(DEF_VECT,jnode,igaus) 
                         end do
                      end do
                   end do
                end if

             else if( kfl_lumped == 2 ) then 
       !
       ! No time term have been added up to now: add Galerkin term
       !
                do igaus = 1,pgaus
                   fact0(DEF_VECT) = gpvol(DEF_VECT,igaus) * gpden(DEF_VECT,igaus) * dtinv_loc(DEF_VECT)
                   do inode = 1, pnode
                      fact1(DEF_VECT) = fact0(DEF_VECT) * gpsha(DEF_VECT,inode,igaus)
                      do idime = 1,ndime
                         idof1                       = (inode-1) * ndime + idime
                         elauu(DEF_VECT,idof1,idof1) = elauu(DEF_VECT,idof1,idof1) + fact1(DEF_VECT)
                         elrbu(DEF_VECT,idime,inode) = elrbu(DEF_VECT,idime,inode) + fact1(DEF_VECT) * elvel(DEF_VECT,idime,inode,2)
                      end do
                   end do
                end do

             end if

       !----------------------------------------------------------------------
       !
       ! Apu and Aup
       !
       !----------------------------------------------------------------------
       !
       ! ( div(u) , q ) and - ( p , div(v) ) 
       !
             if( ndime == 2 ) then
                do igaus = 1,pgaus
                   do inode = 1,pnode
                      idof1 = 2*inode-1
                      idof2 = 2*inode
                      do jnode = 1,pnode
                         fact0(DEF_VECT)             = gpvol(DEF_VECT,igaus) * gpsha(DEF_VECT,jnode,igaus) 
                         fact1(DEF_VECT)             = fact0(DEF_VECT) * gpcar(DEF_VECT,1,inode,igaus)
                         fact2(DEF_VECT)             = fact0(DEF_VECT) * gpcar(DEF_VECT,2,inode,igaus)
                         elapu(DEF_VECT,jnode,idof1) = elapu(DEF_VECT,jnode,idof1) + fact1(DEF_VECT)
                         elapu(DEF_VECT,jnode,idof2) = elapu(DEF_VECT,jnode,idof2) + fact2(DEF_VECT)
                         elaup(DEF_VECT,idof1,jnode) = elaup(DEF_VECT,idof1,jnode) - fact1(DEF_VECT)
                         elaup(DEF_VECT,idof2,jnode) = elaup(DEF_VECT,idof2,jnode) - fact2(DEF_VECT)
                      end do
                   end do
                end do
             else
                do igaus = 1,pgaus
                   do inode = 1,pnode
                      idof1 = 3*inode-2
                      idof2 = 3*inode-1
                      idof3 = 3*inode
                      do jnode = 1,pnode
                         fact0(DEF_VECT)             = gpvol(DEF_VECT,igaus) * gpsha(DEF_VECT,jnode,igaus) 
                         fact1(DEF_VECT)             = fact0(DEF_VECT) * gpcar(DEF_VECT,1,inode,igaus)
                         fact2(DEF_VECT)             = fact0(DEF_VECT) * gpcar(DEF_VECT,2,inode,igaus)
                         fact3(DEF_VECT)             = fact0(DEF_VECT) * gpcar(DEF_VECT,3,inode,igaus)
                         elapu(DEF_VECT,jnode,idof1) = elapu(DEF_VECT,jnode,idof1) + fact1(DEF_VECT)
                         elapu(DEF_VECT,jnode,idof2) = elapu(DEF_VECT,jnode,idof2) + fact2(DEF_VECT)
                         elapu(DEF_VECT,jnode,idof3) = elapu(DEF_VECT,jnode,idof3) + fact3(DEF_VECT)
                         elaup(DEF_VECT,idof1,jnode) = elaup(DEF_VECT,idof1,jnode) - fact1(DEF_VECT)
                         elaup(DEF_VECT,idof2,jnode) = elaup(DEF_VECT,idof2,jnode) - fact2(DEF_VECT)
                         elaup(DEF_VECT,idof3,jnode) = elaup(DEF_VECT,idof3,jnode) - fact3(DEF_VECT)
                      end do
                   end do
                end do
             end if

       !----------------------------------------------------------------------
       !
       ! App
       !
       !----------------------------------------------------------------------
       !
       ! Pressure: ( tau1' * grad(p) , grad(q) )
       ! 
             do igaus = 1,pgaus
                do inode = 1,pnode
                   do jnode = inode+1,pnode
                      fact1(DEF_VECT)             = gpsp1_p(DEF_VECT,igaus) * wgrgr(DEF_VECT,jnode,inode,igaus) * gpvol(DEF_VECT,igaus)
                      elapp(DEF_VECT,jnode,inode) = elapp(DEF_VECT,jnode,inode) + fact1(DEF_VECT)
                      elapp(DEF_VECT,inode,jnode) = elapp(DEF_VECT,inode,jnode) + fact1(DEF_VECT)
                   end do
                   fact1(DEF_VECT)             = gpsp1_p(DEF_VECT,igaus) * wgrgr(DEF_VECT,inode,inode,igaus) * gpvol(DEF_VECT,igaus)
                   elapp(DEF_VECT,inode,inode) = elapp(DEF_VECT,inode,inode) + fact1(DEF_VECT)
                end do
             end do

       !----------------------------------------------------------------------
       !
       ! bu and bp
       !
       ! P1  = P [ tau1' * rho * a.grad(u) ]
       ! P1' = P1 + tau1' * rho * u'n / dt
       !
       ! P2  = P [ tau1' * ( grad(p) - f ) ]
       ! P2' = P2 + tau1' * rho * u'n / dt + tau1' * f 
       !
       !----------------------------------------------------------------------
       !
       ! Limiter
       !
             if( kfl_limit_nsi == -1 ) then

                gpvep(DEF_VECT,:,:) = 0.0_rp

             else if( kfl_limit_nsi > 0 ) then

                do igaus = 1,pgaus
                   c1(DEF_VECT) = 0.0_rp
                   c2(DEF_VECT) = 0.0_rp
                   c3(DEF_VECT) = 0.0_rp
                   do idime = 1,ndime
                      c4(DEF_VECT) = 0.0_rp
                      do inode = 1,pnode
                         c4(DEF_VECT) = c4(DEF_VECT) + agrau(DEF_VECT,inode,igaus) * elvel(DEF_VECT,idime,inode,1)
                      end do
                      c4(DEF_VECT) = gpsp1(DEF_VECT,igaus) * c4(DEF_VECT)
                      c1(DEF_VECT) = c1(DEF_VECT) + ( gpvep(DEF_VECT,idime,igaus) - c4(DEF_VECT) )**2
                      c3(DEF_VECT) = c3(DEF_VECT) + gpvep(DEF_VECT,idime,igaus) * gpvep(DEF_VECT,idime,igaus)
                      c2(DEF_VECT) = c2(DEF_VECT) + c4(DEF_VECT) * c4(DEF_VECT)
                   end do
                   c3(DEF_VECT)   = sqrt( c2(DEF_VECT) ) + sqrt( c3(DEF_VECT) )
                   c1(DEF_VECT)   = sqrt( c1(DEF_VECT) )
                   beta(DEF_VECT) = c1(DEF_VECT) / ( c3(DEF_VECT) + epsilon(1.0_rp) )
                   if( kfl_limit_nsi == 1 ) then
                      alpha(DEF_VECT) = min(1.0_rp,2.0_rp*(1.0_rp-beta(DEF_VECT)))
                   else if( kfl_limit_nsi == 2 ) then
                      alpha(DEF_VECT) = 0.5_rp*(tanh(20.0_rp*(beta(DEF_VECT)-0.8_rp))+1.0_rp)
                   end if
                   do idime = 1,ndime
                      gpvep(DEF_VECT,idime,igaus) = alpha(DEF_VECT) * gpvep(DEF_VECT,idime,igaus)
                   end do
                end do

             end if
       !
       ! P2 <= P2 + tau1' * f
       !
             do igaus = 1,pgaus
                do idime = 1,ndime
                   gpgrp(DEF_VECT,idime,igaus) = gpgrp(DEF_VECT,idime,igaus) + gpsp1_p(DEF_VECT,igaus) * gprhs(DEF_VECT,idime,igaus)
                end do
             end do
       !
       ! P1 <= P1 + tau1' * rho * u'n / dt
       ! P2 <= P2 + tau1' * rho * u'n / dt
       !
             if( kfl_sgsti_nsi == 1 ) then
                do igaus = 1,pgaus 
                   fact1(DEF_VECT)    = gpden(DEF_VECT,igaus) * dtsgs(DEF_VECT) * gpsp1_v(DEF_VECT,igaus)
                   fact1_p (DEF_VECT) = gpden(DEF_VECT,igaus) * dtsgs(DEF_VECT) * gpsp1_p(DEF_VECT,igaus)
                   do idime = 1,ndime
                      gpvep(DEF_VECT,idime,igaus) = gpvep(DEF_VECT,idime,igaus) + fact1(DEF_VECT)   * gpsgs(DEF_VECT,idime,igaus,2)
                      gpgrp(DEF_VECT,idime,igaus) = gpgrp(DEF_VECT,idime,igaus) + fact1_p(DEF_VECT) * gpsgs(DEF_VECT,idime,igaus,2)
                   end do
                end do
             end if
       !
       ! bu = ( f + rho*u^n/dt , v ) + ( rho * a.grad(v) , tau1' * rho u'^n/dt + P1 ) 
       !    = ( f + rho*u^n/dt , v ) + ( rho * a.grad(v) , P1' ) 
       !
       ! bp = ( f + rho*u'^n/dt , tau1' grad(q) ) + ( P2 , grad(q) )
       !    = ( P2' , grad(q) ) 
       !
             if( ndime == 2 ) then
                do igaus = 1,pgaus
                   fact4(DEF_VECT) = gpden(DEF_VECT,igaus) * dtinv_loc(DEF_VECT)
                   do itime = 2,nbdfp_nsi
                      gprhs(DEF_VECT,1,igaus) = gprhs(DEF_VECT,1,igaus) - pabdf_nsi(itime) * fact4(DEF_VECT) * gpvel(DEF_VECT,1,igaus,itime)  
                      gprhs(DEF_VECT,2,igaus) = gprhs(DEF_VECT,2,igaus) - pabdf_nsi(itime) * fact4(DEF_VECT) * gpvel(DEF_VECT,2,igaus,itime)
                   end do
                   do inode = 1,pnode
                      fact1(DEF_VECT) = gpvol(DEF_VECT,igaus) * gpsha(DEF_VECT,inode,igaus) ! ( f + rho*u^n/dt , v )
                      fact3(DEF_VECT) = gpvol(DEF_VECT,igaus) * agrau(DEF_VECT,inode,igaus) ! ( rho * a.grad(v) , P1' ) 
                      elrbu(DEF_VECT,1,inode)  = elrbu(DEF_VECT,1,inode) + fact1(DEF_VECT) * gprhs(DEF_VECT,1,igaus) + fact3(DEF_VECT) * gpvep(DEF_VECT,1,igaus) 
                      elrbu(DEF_VECT,2,inode)  = elrbu(DEF_VECT,2,inode) + fact1(DEF_VECT) * gprhs(DEF_VECT,2,igaus) + fact3(DEF_VECT) * gpvep(DEF_VECT,2,igaus) 
                      elrbp(DEF_VECT,inode)    = elrbp(DEF_VECT,inode)   + gpvol(DEF_VECT,igaus) * ( & ! ( P2' , grad(q) ) 
                      &    gpcar(DEF_VECT,1,inode,igaus) * gpgrp(DEF_VECT,1,igaus)  &
                      &  + gpcar(DEF_VECT,2,inode,igaus) * gpgrp(DEF_VECT,2,igaus)  )
                   end do
                end do
             else
                do igaus = 1,pgaus
                   fact4(DEF_VECT) = gpden(DEF_VECT,igaus) * dtinv_loc(DEF_VECT)
                   do itime = 2,nbdfp_nsi
                      gprhs(DEF_VECT,1,igaus) = gprhs(DEF_VECT,1,igaus) - pabdf_nsi(itime) * fact4(DEF_VECT) * gpvel(DEF_VECT,1,igaus,itime)  
                      gprhs(DEF_VECT,2,igaus) = gprhs(DEF_VECT,2,igaus) - pabdf_nsi(itime) * fact4(DEF_VECT) * gpvel(DEF_VECT,2,igaus,itime)
                      gprhs(DEF_VECT,3,igaus) = gprhs(DEF_VECT,3,igaus) - pabdf_nsi(itime) * fact4(DEF_VECT) * gpvel(DEF_VECT,3,igaus,itime)
                   end do
                   do inode = 1,pnode
                      fact1          = gpvol(DEF_VECT,igaus) * gpsha(DEF_VECT,inode,igaus)
                      fact3          = gpvol(DEF_VECT,igaus) * agrau(DEF_VECT,inode,igaus)
                      elrbu(DEF_VECT,1,inode) = elrbu(DEF_VECT,1,inode) + fact1(DEF_VECT) * gprhs(DEF_VECT,1,igaus) + fact3(DEF_VECT) * gpvep(DEF_VECT,1,igaus) 
                      elrbu(DEF_VECT,2,inode) = elrbu(DEF_VECT,2,inode) + fact1(DEF_VECT) * gprhs(DEF_VECT,2,igaus) + fact3(DEF_VECT) * gpvep(DEF_VECT,2,igaus) 
                      elrbu(DEF_VECT,3,inode) = elrbu(DEF_VECT,3,inode) + fact1(DEF_VECT) * gprhs(DEF_VECT,3,igaus) + fact3(DEF_VECT) * gpvep(DEF_VECT,3,igaus) 
                      elrbp(DEF_VECT,inode)   = elrbp(DEF_VECT,inode)   + gpvol(DEF_VECT,igaus) * ( &
                      &    gpcar(DEF_VECT,1,inode,igaus) * gpgrp(DEF_VECT,1,igaus) &
                      &  + gpcar(DEF_VECT,2,inode,igaus) * gpgrp(DEF_VECT,2,igaus) &
                      &  + gpcar(DEF_VECT,3,inode,igaus) * gpgrp(DEF_VECT,3,igaus) )
                   end do
                end do
             end if

             end subroutine nsi_element_assembly_split_oss

     #+END_SRC

***** BOAST
****** BOAST preparation
      - Macros
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          require 'BOAST'
          include BOAST
        #+END_SRC
      - Mocks
        Some variables/functions are not available so we need to fake them:
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          def generate_mocks
          mocks = <<EOF
          function pabdf_nsi(x) result(y)
            integer,intent(in) :: x 
            real :: y
            y = 1.0
          end function pabdf_nsi
          EOF

          return mocks  
          end
        #+END_SRC
      - BOAST declaration
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          def generate_boast_decl(opts, functions = nil)
            $ndime         = Int("ndime", :dir => :in )
            $kfl_lumped    = Int("kfl_lumped",    :dir => :in)
            $mnode         = Int("mnode",         :dir => :in)
            $ntens         = Int("ntens",         :dir => :in)
            $kfl_duatss    = Int("kfl_duatss",    :dir => :in)
            $fact_duatss   = Int("fact_duatss",   :dir => :in)
            $kfl_stabi_nsi = Int("kfl_stabi_nsi", :dir => :in)
            $fvins_nsi     = Real("fvins_nsi",    :dir => :in)
            $fcons_nsi     = Real("fcons_nsi",    :dir => :in)
            $bemol_nsi     = Real("bemol_nsi",    :dir => :in)
            $kfl_regim_nsi = Int("kfl_regim_nsi", :dir => :in)
            $fvela_nsi     = Real("fvela_nsi",    :dir => :in, :dim => [Dim(3)])
            $kfl_rmom2_nsi = Int("kfl_rmom2_nsi", :dir => :in)
            $kfl_press_nsi = Int("kfl_press_nsi", :dir => :in)
            $kfl_p1ve2_nsi = Int("kfl_p1ve2_nsi", :dir => :in)
            $kfl_linea_nsi = Int("kfl_linea_nsi", :dir => :in)
            $kfl_confi_nsi = Int("kfl_confi_nsi", :dir => :in)
            $nbdfp_nsi     = Int("nbdfp_nsi",     :dir => :in)
            $kfl_sgsti_nsi = Int("kfl_sgsti_nsi", :dir => :in)
            $kfl_nota1_nsi = Int("kfl_nota1_nsi", :dir => :in)
            $kfl_limit_nsi = Int("kfl_limit_nsi", :dir => :in)
            $kfl_penal_nsi = Int("kfl_penal_nsi", :dir => :in)
            $penal_nsi     = Real("penal_nsi",    :dir => :in)
            $kfl_bubbl_nsi = Int("kfl_bubbl_nsi", :dir => :in)

            $pnode     = Int("pnode",             :dir => :in)
            $pgaus     = Int("pgaus",             :dir => :in)
            $gpden     = Real("gpden",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            $gpvis     = Real("gpvis",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            $gppor     = Real("gppor",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            $gpsp1     = Real("gpsp1",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            $gpsp2     = Real("gpsp2",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            $gpvol     = Real("gpvol",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            $gpsha     = Real("gpsha",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pnode),Dim($pgaus)])
            $gpcar     = Real("gpcar",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($mnode),Dim($pgaus)])
            $gpadv     = Real("gpadv",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pgaus)])
            $gpvep     = Real("gpvep",            :dir => :inout , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pgaus)])
            $gpgrp     = Real("gpgrp",            :dir => :inout , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pgaus)])
            $gprhs     = Real("gprhs",            :dir => :inout , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pgaus)])
            $gprhc     = Real("gprhc",            :dir => :inout , :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            $gpvel     = Real("gpvel",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pgaus),Dim()])
            $gpsgs     = Real("gpsgs",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pgaus),Dim()])
            $elvel     = Real("elvel",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pnode),Dim()])
            $elpre     = Real("elpre",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pnode),Dim()])
            $elbub     = Real("elbub",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim(1)])

            $wgrgr     = Real("wgrgr",            :dir => :out   ,:vector_length => opts[:vector_length], :dim => [Dim($pnode),Dim($pnode),Dim($pgaus)])
            $agrau     = Real("agrau",            :dir => :out   ,:vector_length => opts[:vector_length], :dim => [Dim($pnode),Dim($pgaus)])

            # Matrices
            $elauu     = Real("elauu",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim($pnode*$ndime),Dim($pnode*$ndime)])
            $elaup     = Real("elaup",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim($pnode*$ndime),Dim($pnode)])
            $elapp     = Real("elapp",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim($pnode),Dim($pnode)])
            $elapu     = Real("elapu",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim($pnode),Dim($pnode*$ndime)])
            $elrbu     = Real("elrbu",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pnode)])
            $elrbp     = Real("elrbp",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim($pnode)])
            # Others
            $dtinv_loc = Real("dtinv_loc",        :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim(1)])
            $dtsgs     = Real("dtsgs",            :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim(1)])
            $pbubl     = Int("pbubl",             :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim(1)])
            $gpsha_bub = Real("gpsha_bub",        :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            $gpcar_bub = Real("gpcar_bub",        :dir => :in    , :vector_length => opts[:vector_length], :dim => [Dim($ndime),Dim($pgaus)])
            # Enrichement Element matrices
            $elauq     = Real("elauq",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim($pnode*$ndime),Dim(1)])
            $elapq     = Real("elapq",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim($pnode),Dim(1)])
            $elaqu     = Real("elaqu",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim(1),Dim($pnode*$ndime)])
            $elaqp     = Real("elaqp",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim(1),Dim($pnode)])
            $elaqq     = Real("elaqq",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim(1),Dim(1)])
            $elrbq     = Real("elrbq",            :dir => :out   , :vector_length => opts[:vector_length], :dim => [Dim(1)])

            p = Procedure("nsi_element_assembly_split_oss",
                          [$pnode,$pgaus,$gpden,$gpvis,$gppor,$gpsp1,$gpsp2,$gpvol,$gpsha,$gpcar,$gpadv,
                           $gpvep,$gpgrp,$gprhs,$gprhc,$gpvel,$gpsgs,$elvel,$elpre,$elbub,$elauu,$elaup,
                           $elapp,$elapu,$elrbu,$elrbp,$dtinv_loc,$dtsgs,$pbubl,$gpsha_bub,$gpcar_bub,
                           $elauq,$elapq,$elaqu,$elaqp,$elaqq,$elrbq,
                           # Original global variables
                           $kfl_lumped,$mnode,$ntens,$kfl_duatss,$fact_duatss,$kfl_stabi_nsi,$fvins_nsi,
                           $fcons_nsi,$bemol_nsi,$kfl_regim_nsi,$fvela_nsi,$kfl_rmom2_nsi,$kfl_press_nsi,
                           $kfl_p1ve2_nsi,$kfl_linea_nsi,$kfl_confi_nsi,$nbdfp_nsi,
                           $kfl_sgsti_nsi,$kfl_nota1_nsi,$kfl_limit_nsi,$kfl_penal_nsi,$penal_nsi,
                           $kfl_bubbl_nsi,$ndime,$agrau,$wgrgr], :functions => functions
                          )
            return p
          end
        #+END_SRC
****** Def parameters
       We can get rid of ndime and vector_size because we can easily
       modif these parameters in boast
       #+BEGIN_SRC ruby :tangle /tmp/alya.rb
         def gen_def_parameters
           parameters =<<EOF
           integer,     parameter  :: ip    = 4               ! 4-byte integer
           integer,     parameter  :: rp    = 8               ! Double precision 

           real(rp),    parameter  :: zeror = epsilon(1.0_rp) ! Almost zero
           integer(ip), parameter  :: TET04 = 30              ! 3D 
           integer(ip), parameter  :: TET10 = 31              ! 3D 
           integer(ip), parameter  :: PYR05 = 32              ! 3D 
           integer(ip), parameter  :: PYR14 = 33              ! 3D 
           integer(ip), parameter  :: PEN06 = 34              ! 3D  
           integer(ip), parameter  :: PEN15 = 35              ! 3D 
           integer(ip), parameter  :: PEN18 = 36              ! 3D 
           integer(ip), parameter  :: HEX08 = 37              ! 3D 
           integer(ip), parameter  :: HEX20 = 38              ! 3D 
           integer(ip), parameter  :: HEX27 = 39              ! 3D 
           integer(ip), parameter  :: HEX64 = 40              ! 3D 
           integer(ip), parameter  :: SHELL = 51              ! 3D shell element
           integer(ip), parameter  :: BAR3D = 52              ! 3D bar element
         EOF
           return parameters
         end
       #+END_SRC
****** Generate reference implementation 
      - Function declaration:
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          def generate_ref_declaration(opts)
               decl_ref =<<EOF
               subroutine nsi_element_assembly_split_oss(&
               pnode,pgaus,gpden,gpvis,gppor,gpsp1,gpsp2,gpvol,   &
               gpsha,gpcar,gpadv,gpvep,gpgrp,gprhs,gprhc,gpvel,   &
               gpsgs,elvel,elpre,elbub,elauu,elaup,elapp,elapu,   &
               elrbu,elrbp,dtinv_loc,dtsgs,pbubl,gpsha_bub,       &
               gpcar_bub,elauq,elapq,elaqu,elaqp,elaqq,elrbq,&
               ! Original global variables
               kfl_lumped,&
               mnode,ntens,&
               kfl_duatss,&
               fact_duatss,&
               kfl_stabi_nsi,&
               fvins_nsi,fcons_nsi,bemol_nsi,kfl_regim_nsi,&
               fvela_nsi,kfl_rmom2_nsi,kfl_press_nsi,&
               kfl_p1ve2_nsi,kfl_linea_nsi,&
               kfl_confi_nsi,nbdfp_nsi,kfl_sgsti_nsi,&
               kfl_nota1_nsi,kfl_limit_nsi,kfl_penal_nsi,&
               penal_nsi,&
               kfl_bubbl_nsi,&
               ndime,agrau,wgrgr)

               #{gen_def_parameters}

               integer(ip), intent(in)    :: ndime 
               integer(ip), intent(in)    :: kfl_lumped
               integer(ip), intent(in)    :: mnode
               integer(ip), intent(in)    :: ntens
               integer(ip), intent(in)    :: kfl_duatss
               integer(ip), intent(in)    :: fact_duatss
               integer(ip), intent(in)    :: kfl_stabi_nsi
               real(rp),    intent(in)    :: fvins_nsi
               real(rp),    intent(in)    :: fcons_nsi
               real(rp),    intent(in)    :: bemol_nsi
               integer(ip), intent(in)    :: kfl_regim_nsi
               real(rp),    intent(in)    :: fvela_nsi(3)
               integer(ip), intent(in)    :: kfl_rmom2_nsi
               integer(ip), intent(in)    :: kfl_press_nsi
               integer(ip), intent(in)    :: kfl_p1ve2_nsi
               integer(ip), intent(in)    :: kfl_linea_nsi
               integer(ip), intent(in)    :: kfl_confi_nsi
               integer(ip), intent(in)    :: nbdfp_nsi
               integer(ip), intent(in)    :: kfl_sgsti_nsi
               integer(ip), intent(in)    :: kfl_nota1_nsi
               integer(ip), intent(in)    :: kfl_limit_nsi
               integer(ip), intent(in)    :: kfl_penal_nsi
               real(rp),    intent(in)    :: penal_nsi
               integer(ip), intent(in)    :: kfl_bubbl_nsi

               integer(ip), intent(in)    :: pnode,pgaus
               real(rp),    intent(in)    :: gpden(#{$p_vector_length},pgaus)
               real(rp),    intent(in)    :: gpvis(#{$p_vector_length},pgaus)
               real(rp),    intent(in)    :: gppor(#{$p_vector_length},pgaus)
               real(rp),    intent(in)    :: gpsp1(#{$p_vector_length},pgaus)
               real(rp),    intent(in)    :: gpsp2(#{$p_vector_length},pgaus)
               real(rp),    intent(in)    :: gpvol(#{$p_vector_length},pgaus)
               real(rp),    intent(in)    :: gpsha(#{$p_vector_length},pnode,pgaus)
               real(rp),    intent(in)    :: gpcar(#{$p_vector_length},ndime,mnode,pgaus)
               real(rp),    intent(in)    :: gpadv(#{$p_vector_length},ndime,pgaus)
               real(rp),    intent(inout) :: gpvep(#{$p_vector_length},ndime,pgaus)
               real(rp),    intent(inout) :: gpgrp(#{$p_vector_length},ndime,pgaus)
               real(rp),    intent(inout) :: gprhs(#{$p_vector_length},ndime,pgaus)
               real(rp),    intent(inout) :: gprhc(#{$p_vector_length},pgaus)
               real(rp),    intent(in)    :: gpvel(#{$p_vector_length},ndime,pgaus,*)
               real(rp),    intent(in)    :: gpsgs(#{$p_vector_length},ndime,pgaus,*)
               real(rp),    intent(in)    :: elvel(#{$p_vector_length},ndime,pnode,*)
               real(rp),    intent(in)    :: elpre(#{$p_vector_length},pnode,*)
               real(rp),    intent(in)    :: elbub(#{$p_vector_length})

               real(rp),    intent(out)   :: wgrgr(#{$p_vector_length},pnode,pnode,pgaus)
               real(rp),    intent(out)   :: agrau(#{$p_vector_length},pnode,pgaus)

               ! Matrices
               real(rp),    intent(out)   :: elauu(#{$p_vector_length},pnode*ndime,pnode*ndime)
               real(rp),    intent(out)   :: elaup(#{$p_vector_length},pnode*ndime,pnode)
               real(rp),    intent(out)   :: elapp(#{$p_vector_length},pnode,pnode)
               real(rp),    intent(out)   :: elapu(#{$p_vector_length},pnode,pnode*ndime)
               real(rp),    intent(out)   :: elrbu(#{$p_vector_length},ndime,pnode)
               real(rp),    intent(out)   :: elrbp(#{$p_vector_length},pnode)
               ! Others
               real(rp),    intent(in)    :: dtinv_loc(#{$p_vector_length})
               real(rp),    intent(in)    :: dtsgs(#{$p_vector_length})
               integer(ip), intent(in)    :: pbubl(#{$p_vector_length})
               real(rp),    intent(in)    :: gpsha_bub(#{$p_vector_length},pgaus)
               real(rp),    intent(in)    :: gpcar_bub(#{$p_vector_length},ndime,pgaus)
               ! Enrichement Element matrices
               real(rp),    intent(out)   :: elauq(#{$p_vector_length},pnode*ndime,1)
               real(rp),    intent(out)   :: elapq(#{$p_vector_length},pnode,1)
               real(rp),    intent(out)   :: elaqu(#{$p_vector_length},1,pnode*ndime)
               real(rp),    intent(out)   :: elaqp(#{$p_vector_length},1,pnode)
               real(rp),    intent(out)   :: elaqq(#{$p_vector_length},1,1)
               real(rp),    intent(out)   :: elrbq(#{$p_vector_length},1)
               ! Local arrays
               real(rp)                   :: gpsp1_p(#{$p_vector_length},pgaus)
               real(rp)                   :: gpsp1_v(#{$p_vector_length},pgaus)
               real(rp)                   :: gpsp2_v(#{$p_vector_length},pgaus)
               real(rp)                   :: c1(#{$p_vector_length})
               real(rp)                   :: c2(#{$p_vector_length})
               real(rp)                   :: c3(#{$p_vector_length})
               real(rp)                   :: c4(#{$p_vector_length})
               real(rp)                   :: alpha(#{$p_vector_length})
               real(rp)                   :: beta(#{$p_vector_length})
               real(rp)                   :: fact0(#{$p_vector_length})
               real(rp)                   :: fact1(#{$p_vector_length})
               real(rp)                   :: fact2(#{$p_vector_length})
               real(rp)                   :: fact3(#{$p_vector_length})
               real(rp)                   :: fact4(#{$p_vector_length})
               real(rp)                   :: fact5(#{$p_vector_length})
               real(rp)                   :: fact6(#{$p_vector_length})
               real(rp)                   :: fact7(#{$p_vector_length})
               real(rp)                   :: fact8(#{$p_vector_length})
               real(rp)                   :: gpveo(#{$p_vector_length},3)
               real(rp)                   :: fact1_p(#{$p_vector_length})
               real(rp)                   :: dtinv_mod(#{$p_vector_length})
               integer(ip)                :: inode,jnode,jdime
               integer(ip)                :: idofv,jdof2,jdof3,ivect
               integer(ip)                :: idof1,idof3,idof2,igaus
               integer(ip)                :: idime,jdof1,jdofv,itime
          EOF
            if opts[:preprocessor] then
              decl_ref = decl_ref + <<EOF
              #ifdef OPENACC
              #define DEF_VECT ivect
              #else
              #define DEF_VECT 1:#{$p_vector_length}
              #endif
          EOF
            end
            return decl_ref 
          end
        #+END_SRC
      - Initialization
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          def generate_ref_initialization
          init = <<EOF
             dtinv_mod = dtinv_loc

             gpsp1_p = gpsp1
             gpsp1_v = gpsp1
             gpsp2_v = gpsp2

             if( kfl_nota1_nsi == 1 ) gpsp1_v = 0.0_rp 

             elrbp = 0.0_rp
             elrbu = 0.0_rp
             elapp = 0.0_rp
             elauu = 0.0_rp
             elaup = 0.0_rp
             elapu = 0.0_rp
          EOF
            return init
          end 
        #+END_SRC
******* V1 
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          def generate_ref_v1(options)        
            opts = {:vector_length => 1, :preprocessor => false, :nests => (1..10).to_a}
            opts.update(options)
            macros = ""

            if opts[:preprocessor] then
              $p_vector_length = "VECTOR_SIZE"
              $p_def_vect = "DEF_VECT"
              macros = <<EOF
                #define VECTOR_SIZE #{opts[:vector_length]}
          EOF
            else
              $p_vector_length = "#{opts[:vector_length]}"
              $p_def_vect = "1:#{opts[:vector_length]}"
            end
       #+END_SRC
      - First nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          first_nest = <<EOF
           if( ndime == 2 ) then

              do igaus = 1,pgaus
                 do inode = 1,pnode
                    agrau(#{$p_def_vect},inode,igaus) =  gpden(#{$p_def_vect},igaus) * (                    &
                    &                gpadv(#{$p_def_vect},1,igaus)*gpcar(#{$p_def_vect},1,inode,igaus) &
                    &              + gpadv(#{$p_def_vect},2,igaus)*gpcar(#{$p_def_vect},2,inode,igaus) )
                    do jnode = 1,pnode
                       wgrgr(#{$p_def_vect},inode,jnode,igaus) = &
                       &             gpcar(#{$p_def_vect},1,inode,igaus)*gpcar(#{$p_def_vect},1,jnode,igaus) &
                       &           + gpcar(#{$p_def_vect},2,inode,igaus)*gpcar(#{$p_def_vect},2,jnode,igaus) 
                    end do
                 end do
              end do

           else

              do igaus = 1,pgaus
                 do inode = 1,pnode
                    agrau(#{$p_def_vect},inode,igaus) =  gpden(#{$p_def_vect},igaus) * (                    &
                    &                gpadv(#{$p_def_vect},1,igaus)*gpcar(#{$p_def_vect},1,inode,igaus) &
                    &              + gpadv(#{$p_def_vect},2,igaus)*gpcar(#{$p_def_vect},2,inode,igaus) &
                    &              + gpadv(#{$p_def_vect},3,igaus)*gpcar(#{$p_def_vect},3,inode,igaus) )
                    do jnode = 1,pnode
                       wgrgr(#{$p_def_vect},inode,jnode,igaus) = &
                       &             gpcar(#{$p_def_vect},1,inode,igaus)*gpcar(#{$p_def_vect},1,jnode,igaus) &
                       &           + gpcar(#{$p_def_vect},2,inode,igaus)*gpcar(#{$p_def_vect},2,jnode,igaus) & 
                       &           + gpcar(#{$p_def_vect},3,inode,igaus)*gpcar(#{$p_def_vect},3,jnode,igaus) 
                    end do
                 end do
              end do

           end if
          EOF
        #+END_SRC
      - Second nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          second_nest = <<EOF
             if( ndime == 2 ) then

                do igaus = 1,pgaus

                   fact0(#{$p_def_vect}) = gpsp2(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus)
                   fact6(#{$p_def_vect}) = gpvis(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus)
                   fact7(#{$p_def_vect}) = gpsp1_v(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus) 
                   fact8(#{$p_def_vect}) = pabdf_nsi(1) * gpden(#{$p_def_vect},igaus) * dtinv_loc(#{$p_def_vect}) + gppor(#{$p_def_vect},igaus)

                   do inode = 1,pnode

                      idof1 = 2*inode-1
                      idof2 = 2*inode

                      fact1(#{$p_def_vect}) = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,inode,igaus) 
                      fact2(#{$p_def_vect}) = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,inode,igaus) 
                      fact4(#{$p_def_vect}) = gpsha(#{$p_def_vect},inode,igaus) * gpvol(#{$p_def_vect},igaus)

                      do jnode = 1,pnode    

                         jdof1 = 2*jnode-1
                         jdof2 = 2*jnode

                         fact5(#{$p_def_vect}) = fact4(#{$p_def_vect}) * ( agrau(#{$p_def_vect},jnode,igaus) + fact8(#{$p_def_vect}) * gpsha(#{$p_def_vect},jnode,igaus) ) & 
                         &         +  fact6(#{$p_def_vect}) * wgrgr(#{$p_def_vect},inode,jnode,igaus) & 
                         &         +  fact7(#{$p_def_vect}) * agrau(#{$p_def_vect},jnode,igaus) * agrau(#{$p_def_vect},inode,igaus) 

                         elauu(#{$p_def_vect},idof1,jdof1) = elauu(#{$p_def_vect},idof1,jdof1) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,jnode,igaus) + fact5(#{$p_def_vect})
                         elauu(#{$p_def_vect},idof2,jdof1) = elauu(#{$p_def_vect},idof2,jdof1) + fact2(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,jnode,igaus)
                         elauu(#{$p_def_vect},idof1,jdof2) = elauu(#{$p_def_vect},idof1,jdof2) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,jnode,igaus) 
                         elauu(#{$p_def_vect},idof2,jdof2) = elauu(#{$p_def_vect},idof2,jdof2) + fact2(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,jnode,igaus) + fact5(#{$p_def_vect})

                      end do

                   end do
                end do

             else

                do igaus = 1,pgaus

                   fact0(#{$p_def_vect}) = gpsp2(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus)
                   fact6(#{$p_def_vect}) = gpvis(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus)
                   fact7(#{$p_def_vect}) = gpsp1_v(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus)
                   fact8(#{$p_def_vect}) = pabdf_nsi(1) * gpden(#{$p_def_vect},igaus) * dtinv_loc(#{$p_def_vect}) + gppor(#{$p_def_vect},igaus)

                   do inode = 1,pnode

                      idof1 = 3*inode-2
                      idof2 = 3*inode-1
                      idof3 = 3*inode

                      fact1(#{$p_def_vect}) = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,inode,igaus) 
                      fact2(#{$p_def_vect}) = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,inode,igaus) 
                      fact3(#{$p_def_vect}) = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},3,inode,igaus) 
                      fact4(#{$p_def_vect}) = gpsha(#{$p_def_vect},inode,igaus) * gpvol(#{$p_def_vect},igaus)

                      do jnode = 1,pnode    

                         jdof1 = 3*jnode-2
                         jdof2 = 3*jnode-1
                         jdof3 = 3*jnode

                         fact5(#{$p_def_vect}) = fact4(#{$p_def_vect}) * ( agrau(#{$p_def_vect},jnode,igaus) + fact8(#{$p_def_vect}) * gpsha(#{$p_def_vect},jnode,igaus) ) & 
                         +  fact6(#{$p_def_vect}) * wgrgr(#{$p_def_vect},inode,jnode,igaus) & 
                         +  fact7(#{$p_def_vect}) * agrau(#{$p_def_vect},jnode,igaus) * agrau(#{$p_def_vect},inode,igaus) 

                         elauu(#{$p_def_vect},idof1,jdof1) = elauu(#{$p_def_vect},idof1,jdof1) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,jnode,igaus) + fact5(#{$p_def_vect})
                         elauu(#{$p_def_vect},idof2,jdof1) = elauu(#{$p_def_vect},idof2,jdof1) + fact2(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,jnode,igaus)
                         elauu(#{$p_def_vect},idof3,jdof1) = elauu(#{$p_def_vect},idof3,jdof1) + fact3(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,jnode,igaus)

                         elauu(#{$p_def_vect},idof1,jdof2) = elauu(#{$p_def_vect},idof1,jdof2) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,jnode,igaus) 
                         elauu(#{$p_def_vect},idof2,jdof2) = elauu(#{$p_def_vect},idof2,jdof2) + fact2(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,jnode,igaus) + fact5(#{$p_def_vect})
                         elauu(#{$p_def_vect},idof3,jdof2) = elauu(#{$p_def_vect},idof3,jdof2) + fact3(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,jnode,igaus) 

                         elauu(#{$p_def_vect},idof1,jdof3) = elauu(#{$p_def_vect},idof1,jdof3) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},3,jnode,igaus) 
                         elauu(#{$p_def_vect},idof2,jdof3) = elauu(#{$p_def_vect},idof2,jdof3) + fact2(#{$p_def_vect}) * gpcar(#{$p_def_vect},3,jnode,igaus)
                         elauu(#{$p_def_vect},idof3,jdof3) = elauu(#{$p_def_vect},idof3,jdof3) + fact3(#{$p_def_vect}) * gpcar(#{$p_def_vect},3,jnode,igaus) + fact5(#{$p_def_vect})

                      end do

                   end do
                end do

             end if

          EOF
        #+END_SRC
      - Third nest
        #+BEGIN_SRC ruby :tangle  /tmp/alya.rb
          third_nest = <<EOF
             if( fvins_nsi > 0.9_rp ) then
                if( ndime == 2 ) then
                   do igaus = 1,pgaus
                      do inode = 1,pnode
                         do idime = 1,ndime
                            idofv =  (inode-1)*ndime+idime
                            do jnode = 1,pnode
                               fact1                       = gpvis(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus) * gpcar(#{$p_def_vect},idime,jnode,igaus)     
                               jdofv                       = (jnode-1)*ndime + 1
                               elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,inode,igaus)
                               jdofv                       = (jnode-1)*ndime + 2
                               elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,inode,igaus)
                            end do
                            if( fvins_nsi == 2.0_rp ) then
                               fact1 = -2.0_rp/3.0_rp * gpvis(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus) * gpcar(#{$p_def_vect},idime,inode,igaus)
                               do jnode = 1,pnode
                                  jdofv                       = (jnode-1)*ndime + 1 
                                  elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,jnode,igaus)
                                  jdofv                       = (jnode-1)*ndime + 2
                                  elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,jnode,igaus)
                               end do
                            end if
                         end do
                      end do
                   end do
                else
                   do igaus = 1,pgaus
                      do inode = 1,pnode
                         do idime = 1,ndime
                            idofv = (inode-1)*ndime + idime
                            do jnode = 1,pnode
                               fact1                       = gpvis(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus) * gpcar(#{$p_def_vect},idime,jnode,igaus)     
                               jdofv                       = (jnode-1)*ndime + 1
                               elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,inode,igaus)
                               jdofv                       = (jnode-1)*ndime + 2
                               elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,inode,igaus)
                               jdofv                       = (jnode-1)*ndime + 3
                               elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},3,inode,igaus)
                            end do
                            if( fvins_nsi == 2.0 ) then
                               fact1                          = -2.0_rp / 3.0_rp * gpvis(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus) * gpcar(#{$p_def_vect},idime,inode,igaus)
                               do jnode = 1,pnode
                                  jdofv                       = (jnode-1)*ndime + 1
                                  elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,jnode,igaus)
                                  jdofv                       = (jnode-1)*ndime + 2
                                  elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,jnode,igaus)
                                  jdofv                       = (jnode-1)*ndime + 3
                                  elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},3,jnode,igaus)
                               end do
                            end if
                         end do
                      end do
                   end do
                end if
             end if
          EOF
        #+END_SRC
      - Fourth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          fourth_nest = <<EOF
             if( kfl_lumped == 1 ) then 
                if( ndime == 2 ) then
                   call runend('PREGUNTAR A MATIAS QUE LO PROGRAME')
                else
                   do igaus = 1,pgaus
                      gpveo(#{$p_def_vect},1:3) = 0.0_rp
                      do inode = 1,pnode
                         do idime = 1,ndime
                            gpveo(#{$p_def_vect},idime) = gpveo(#{$p_def_vect},idime) + elvel(#{$p_def_vect},idime,inode,2) * gpsha(#{$p_def_vect},inode,igaus)
                         end do
                      end do
                      do inode = 1,pnode
                         idof1                       = 3*inode-2
                         idof2                       = 3*inode-1
                         idof3                       = 3*inode
                         fact0(#{$p_def_vect})             = gpvol(#{$p_def_vect},igaus) * gpden(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},inode,igaus) * dtinv_loc(#{$p_def_vect})
                         elauu(#{$p_def_vect},idof1,idof1) = elauu(#{$p_def_vect},idof1,idof1) + fact0(#{$p_def_vect})
                         elauu(#{$p_def_vect},idof2,idof2) = elauu(#{$p_def_vect},idof2,idof2) + fact0(#{$p_def_vect})
                         elauu(#{$p_def_vect},idof3,idof3) = elauu(#{$p_def_vect},idof3,idof3) + fact0(#{$p_def_vect})
                         do idime = 1,ndime
                            elrbu(#{$p_def_vect},idime,inode) = elrbu(#{$p_def_vect},idime,inode) - fact0(#{$p_def_vect}) * gpveo(#{$p_def_vect},idime)
                            elrbu(#{$p_def_vect},idime,inode) = elrbu(#{$p_def_vect},idime,inode) + fact0(#{$p_def_vect}) * elvel(#{$p_def_vect},idime,inode,2)
                         end do
                         do jnode = 1,pnode 
                            jdof1                       = 3*jnode-2
                            jdof2                       = 3*jnode-1
                            jdof3                       = 3*jnode
                            elauu(#{$p_def_vect},idof1,jdof1) = elauu(#{$p_def_vect},idof1,jdof1) - fact0*gpsha(#{$p_def_vect},jnode,igaus) 
                            elauu(#{$p_def_vect},idof2,jdof2) = elauu(#{$p_def_vect},idof2,jdof2) - fact0*gpsha(#{$p_def_vect},jnode,igaus) 
                            elauu(#{$p_def_vect},idof3,jdof3) = elauu(#{$p_def_vect},idof3,jdof3) - fact0*gpsha(#{$p_def_vect},jnode,igaus) 
                         end do
                      end do
                   end do
                end if

             else if( kfl_lumped == 2 ) then 
                do igaus = 1,pgaus
                   fact0(#{$p_def_vect}) = gpvol(#{$p_def_vect},igaus) * gpden(#{$p_def_vect},igaus) * dtinv_loc(#{$p_def_vect})
                   do inode = 1, pnode
                      fact1(#{$p_def_vect}) = fact0(#{$p_def_vect}) * gpsha(#{$p_def_vect},inode,igaus)
                      do idime = 1,ndime
                         idof1                       = (inode-1) * ndime + idime
                         elauu(#{$p_def_vect},idof1,idof1) = elauu(#{$p_def_vect},idof1,idof1) + fact1(#{$p_def_vect})
                         elrbu(#{$p_def_vect},idime,inode) = elrbu(#{$p_def_vect},idime,inode) + fact1(#{$p_def_vect}) * elvel(#{$p_def_vect},idime,inode,2)
                      end do
                   end do
                end do

             end if
          EOF
        #+END_SRC
      - Fifth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          fifth_nest = <<EOF
             if( ndime == 2 ) then
                do igaus = 1,pgaus
                   do inode = 1,pnode
                      idof1 = 2*inode-1
                      idof2 = 2*inode
                      do jnode = 1,pnode
                         fact0(#{$p_def_vect})             = gpvol(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},jnode,igaus) 
                         fact1(#{$p_def_vect})             = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,inode,igaus)
                         fact2(#{$p_def_vect})             = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,inode,igaus)
                         elapu(#{$p_def_vect},jnode,idof1) = elapu(#{$p_def_vect},jnode,idof1) + fact1(#{$p_def_vect})
                         elapu(#{$p_def_vect},jnode,idof2) = elapu(#{$p_def_vect},jnode,idof2) + fact2(#{$p_def_vect})
                         elaup(#{$p_def_vect},idof1,jnode) = elaup(#{$p_def_vect},idof1,jnode) - fact1(#{$p_def_vect})
                         elaup(#{$p_def_vect},idof2,jnode) = elaup(#{$p_def_vect},idof2,jnode) - fact2(#{$p_def_vect})
                      end do
                   end do
                end do
             else
                do igaus = 1,pgaus
                   do inode = 1,pnode
                      idof1 = 3*inode-2
                      idof2 = 3*inode-1
                      idof3 = 3*inode
                      do jnode = 1,pnode
                         fact0(#{$p_def_vect})             = gpvol(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},jnode,igaus) 
                         fact1(#{$p_def_vect})             = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},1,inode,igaus)
                         fact2(#{$p_def_vect})             = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},2,inode,igaus)
                         fact3(#{$p_def_vect})             = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},3,inode,igaus)
                         elapu(#{$p_def_vect},jnode,idof1) = elapu(#{$p_def_vect},jnode,idof1) + fact1(#{$p_def_vect})
                         elapu(#{$p_def_vect},jnode,idof2) = elapu(#{$p_def_vect},jnode,idof2) + fact2(#{$p_def_vect})
                         elapu(#{$p_def_vect},jnode,idof3) = elapu(#{$p_def_vect},jnode,idof3) + fact3(#{$p_def_vect})
                         elaup(#{$p_def_vect},idof1,jnode) = elaup(#{$p_def_vect},idof1,jnode) - fact1(#{$p_def_vect})
                         elaup(#{$p_def_vect},idof2,jnode) = elaup(#{$p_def_vect},idof2,jnode) - fact2(#{$p_def_vect})
                         elaup(#{$p_def_vect},idof3,jnode) = elaup(#{$p_def_vect},idof3,jnode) - fact3(#{$p_def_vect})
                      end do
                   end do
                end do
             end if
          EOF
        #+END_SRC
      - Sixth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          sixth_nest = <<EOF
             do igaus = 1,pgaus
                do inode = 1,pnode
                   do jnode = inode+1,pnode
                      fact1(#{$p_def_vect})             = gpsp1_p(#{$p_def_vect},igaus) * wgrgr(#{$p_def_vect},jnode,inode,igaus) * gpvol(#{$p_def_vect},igaus)
                      elapp(#{$p_def_vect},jnode,inode) = elapp(#{$p_def_vect},jnode,inode) + fact1(#{$p_def_vect})
                      elapp(#{$p_def_vect},inode,jnode) = elapp(#{$p_def_vect},inode,jnode) + fact1(#{$p_def_vect})
                   end do
                   fact1(#{$p_def_vect})             = gpsp1_p(#{$p_def_vect},igaus) * wgrgr(#{$p_def_vect},inode,inode,igaus) * gpvol(#{$p_def_vect},igaus)
                   elapp(#{$p_def_vect},inode,inode) = elapp(#{$p_def_vect},inode,inode) + fact1(#{$p_def_vect})
                end do
             end do
          EOF
        #+END_SRC
      - Seventh nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          seventh_nest = <<EOF
             if( kfl_limit_nsi == -1 ) then

                gpvep(#{$p_def_vect},:,:) = 0.0_rp

             else if( kfl_limit_nsi > 0 ) then

                do igaus = 1,pgaus
                   c1(#{$p_def_vect}) = 0.0_rp
                   c2(#{$p_def_vect}) = 0.0_rp
                   c3(#{$p_def_vect}) = 0.0_rp
                   do idime = 1,ndime
                      c4(#{$p_def_vect}) = 0.0_rp
                      do inode = 1,pnode
                         c4(#{$p_def_vect}) = c4(#{$p_def_vect}) + agrau(#{$p_def_vect},inode,igaus) * elvel(#{$p_def_vect},idime,inode,1)
                      end do
                      c4(#{$p_def_vect}) = gpsp1(#{$p_def_vect},igaus) * c4(#{$p_def_vect})
                      c1(#{$p_def_vect}) = c1(#{$p_def_vect}) + ( gpvep(#{$p_def_vect},idime,igaus) - c4(#{$p_def_vect}) )**2
                      c3(#{$p_def_vect}) = c3(#{$p_def_vect}) + gpvep(#{$p_def_vect},idime,igaus) * gpvep(#{$p_def_vect},idime,igaus)
                      c2(#{$p_def_vect}) = c2(#{$p_def_vect}) + c4(#{$p_def_vect}) * c4(#{$p_def_vect})
                   end do
                   c3(#{$p_def_vect})   = sqrt( c2(#{$p_def_vect}) ) + sqrt( c3(#{$p_def_vect}) )
                   c1(#{$p_def_vect})   = sqrt( c1(#{$p_def_vect}) )
                   beta(#{$p_def_vect}) = c1(#{$p_def_vect}) / ( c3(#{$p_def_vect}) + epsilon(1.0_rp) )
                   if( kfl_limit_nsi == 1 ) then
                      alpha(#{$p_def_vect}) = min(1.0_rp,2.0_rp*(1.0-beta(#{$p_def_vect})))
                   else if( kfl_limit_nsi == 2 ) then
                      alpha(#{$p_def_vect}) = 0.5_rp*(tanh(20.0_rp*(beta(#{$p_def_vect})-0.8_rp))+1.0_rp)
                   end if
                   do idime = 1,ndime
                      gpvep(#{$p_def_vect},idime,igaus) = alpha(#{$p_def_vect}) * gpvep(#{$p_def_vect},idime,igaus)
                   end do
                end do

             end if
          EOF
        #+END_SRC
      - Eighth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          eighth_nest = <<EOF
             do igaus = 1,pgaus
                do idime = 1,ndime
                   gpgrp(#{$p_def_vect},idime,igaus) = gpgrp(#{$p_def_vect},idime,igaus) + gpsp1_p(#{$p_def_vect},igaus) * gprhs(#{$p_def_vect},idime,igaus)
                end do
             end do
          EOF
        #+END_SRC
      - Nineth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          nineth_nest = <<EOF
             if( kfl_sgsti_nsi == 1 ) then
                do igaus = 1,pgaus 
                   fact1(#{$p_def_vect})    = gpden(#{$p_def_vect},igaus) * dtsgs(#{$p_def_vect}) * gpsp1_v(#{$p_def_vect},igaus)
                   fact1_p (#{$p_def_vect}) = gpden(#{$p_def_vect},igaus) * dtsgs(#{$p_def_vect}) * gpsp1_p(#{$p_def_vect},igaus)
                   do idime = 1,ndime
                      gpvep(#{$p_def_vect},idime,igaus) = gpvep(#{$p_def_vect},idime,igaus) + fact1(#{$p_def_vect})   * gpsgs(#{$p_def_vect},idime,igaus,2)
                      gpgrp(#{$p_def_vect},idime,igaus) = gpgrp(#{$p_def_vect},idime,igaus) + fact1_p(#{$p_def_vect}) * gpsgs(#{$p_def_vect},idime,igaus,2)
                   end do
                end do
             end if
          EOF
        #+END_SRC
      - Tenth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          tenth_nest = <<EOF
             if( ndime == 2 ) then
                do igaus = 1,pgaus
                   fact4(#{$p_def_vect}) = gpden(#{$p_def_vect},igaus) * dtinv_loc(#{$p_def_vect})
                   do itime = 2,nbdfp_nsi
                      gprhs(#{$p_def_vect},1,igaus) = gprhs(#{$p_def_vect},1,igaus) - pabdf_nsi(itime) * fact4(#{$p_def_vect}) * gpvel(#{$p_def_vect},1,igaus,itime)  
                      gprhs(#{$p_def_vect},2,igaus) = gprhs(#{$p_def_vect},2,igaus) - pabdf_nsi(itime) * fact4(#{$p_def_vect}) * gpvel(#{$p_def_vect},2,igaus,itime)
                   end do
                   do inode = 1,pnode
                      fact1(#{$p_def_vect}) = gpvol(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},inode,igaus)
                      fact3(#{$p_def_vect}) = gpvol(#{$p_def_vect},igaus) * agrau(#{$p_def_vect},inode,igaus)
                      elrbu(#{$p_def_vect},1,inode)  = elrbu(#{$p_def_vect},1,inode) + fact1(#{$p_def_vect}) * gprhs(#{$p_def_vect},1,igaus) + fact3(#{$p_def_vect}) * gpvep(#{$p_def_vect},1,igaus) 
                      elrbu(#{$p_def_vect},2,inode)  = elrbu(#{$p_def_vect},2,inode) + fact1(#{$p_def_vect}) * gprhs(#{$p_def_vect},2,igaus) + fact3(#{$p_def_vect}) * gpvep(#{$p_def_vect},2,igaus) 
                      elrbp(#{$p_def_vect},inode)    = elrbp(#{$p_def_vect},inode)   + gpvol(#{$p_def_vect},igaus) * ( & ! ( P2' , grad(q) ) 
                      &    gpcar(#{$p_def_vect},1,inode,igaus) * gpgrp(#{$p_def_vect},1,igaus)  &
                      &  + gpcar(#{$p_def_vect},2,inode,igaus) * gpgrp(#{$p_def_vect},2,igaus)  )
                   end do
                end do
             else
                do igaus = 1,pgaus
                   fact4(#{$p_def_vect}) = gpden(#{$p_def_vect},igaus) * dtinv_loc(#{$p_def_vect})
                   do itime = 2,nbdfp_nsi
                      gprhs(#{$p_def_vect},1,igaus) = gprhs(#{$p_def_vect},1,igaus) - pabdf_nsi(itime) * fact4(#{$p_def_vect}) * gpvel(#{$p_def_vect},1,igaus,itime)  
                      gprhs(#{$p_def_vect},2,igaus) = gprhs(#{$p_def_vect},2,igaus) - pabdf_nsi(itime) * fact4(#{$p_def_vect}) * gpvel(#{$p_def_vect},2,igaus,itime)
                      gprhs(#{$p_def_vect},3,igaus) = gprhs(#{$p_def_vect},3,igaus) - pabdf_nsi(itime) * fact4(#{$p_def_vect}) * gpvel(#{$p_def_vect},3,igaus,itime)
                   end do
                   do inode = 1,pnode
                      fact1          = gpvol(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},inode,igaus)
                      fact3          = gpvol(#{$p_def_vect},igaus) * agrau(#{$p_def_vect},inode,igaus)
                      elrbu(#{$p_def_vect},1,inode) = elrbu(#{$p_def_vect},1,inode) + fact1(#{$p_def_vect}) * gprhs(#{$p_def_vect},1,igaus) + fact3(#{$p_def_vect}) * gpvep(#{$p_def_vect},1,igaus) 
                      elrbu(#{$p_def_vect},2,inode) = elrbu(#{$p_def_vect},2,inode) + fact1(#{$p_def_vect}) * gprhs(#{$p_def_vect},2,igaus) + fact3(#{$p_def_vect}) * gpvep(#{$p_def_vect},2,igaus) 
                      elrbu(#{$p_def_vect},3,inode) = elrbu(#{$p_def_vect},3,inode) + fact1(#{$p_def_vect}) * gprhs(#{$p_def_vect},3,igaus) + fact3(#{$p_def_vect}) * gpvep(#{$p_def_vect},3,igaus) 
                      elrbp(#{$p_def_vect},inode)   = elrbp(#{$p_def_vect},inode)   + gpvol(#{$p_def_vect},igaus) * ( &
                      &    gpcar(#{$p_def_vect},1,inode,igaus) * gpgrp(#{$p_def_vect},1,igaus) &
                      &  + gpcar(#{$p_def_vect},2,inode,igaus) * gpgrp(#{$p_def_vect},2,igaus) &
                      &  + gpcar(#{$p_def_vect},3,inode,igaus) * gpgrp(#{$p_def_vect},3,igaus) )
                   end do
                end do
             end if

          EOF
        #+END_SRC
      - Assembling pieces
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          set_lang(FORTRAN)
          k = CKernel::new(:includes => "immintrin.h")
          p = generate_boast_decl(opts)
          k.procedure = p
          get_output.print macros
          get_output.print generate_mocks
          get_output.print generate_ref_declaration(opts)
          get_output.print generate_ref_initialization
          get_output.print first_nest if opts[:nests].include? 1
          get_output.print second_nest if opts[:nests].include? 2
          get_output.print third_nest if opts[:nests].include? 3
          get_output.print fourth_nest if opts[:nests].include? 4
          get_output.print fifth_nest if opts[:nests].include? 5
          get_output.print sixth_nest if opts[:nests].include? 6
          get_output.print seventh_nest if opts[:nests].include? 7
          get_output.print eighth_nest if opts[:nests].include? 8
          get_output.print nineth_nest if opts[:nests].include? 9
          get_output.print tenth_nest if opts[:nests].include? 10
          get_output.print "end subroutine nsi_element_assembly_split_oss"
          return k
          end  
        #+END_SRC
******* V2
       #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          def generate_ref_v2(options)        
            opts = {:vector_length => 1, :preprocessor => false, :nests => (1..10).to_a}
            opts.update(options)
            macros = ""

            if opts[:preprocessor] then
              $p_vector_length = "VECTOR_SIZE"
              $p_def_vect = "DEF_VECT"
              macros = <<EOF
                #define VECTOR_SIZE #{opts[:vector_length]}
          EOF
            else
              $p_vector_length = "#{opts[:vector_length]}"
              $p_def_vect = "1:#{opts[:vector_length]}"
            end
            
            nests = []
       #+END_SRC
******** First nest 
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
            nests[0] = <<EOF
             agrau(#{$p_def_vect},:,:)   = 0.0_rp
                 wgrgr(#{$p_def_vect},:,:,:) = 0.0_rp 
                 do igaus = 1,pgaus
                    do inode = 1,pnode
                       do idime = 1,ndime
                          agrau(#{$p_def_vect},inode,igaus) =  agrau(#{$p_def_vect},inode,igaus) + &
                                                        gpadv(#{$p_def_vect},idime,igaus) * gpcar(#{$p_def_vect},idime,inode,igaus)
                       end do
                       agrau(#{$p_def_vect},inode,igaus) =  gpden(#{$p_def_vect},igaus) * agrau(#{$p_def_vect},inode,igaus) 
                       do jnode = 1,pnode
                          do idime = 1,ndime
                             wgrgr(#{$p_def_vect},inode,jnode,igaus) = wgrgr(#{$p_def_vect},inode,jnode,igaus) + &
                                                                gpcar(#{$p_def_vect},idime,inode,igaus)*gpcar(#{$p_def_vect},idime,jnode,igaus)
                          end do
                       end do
                    end do
                 end do
          EOF
         #+END_SRC
******** Second nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
           nests[1] = <<EOF
             do igaus = 1,pgaus

                fact0(#{$p_def_vect}) = gpsp2_v(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus)
                fact6(#{$p_def_vect}) = gpvis(#{$p_def_vect},igaus)   * gpvol(#{$p_def_vect},igaus)
                fact7(#{$p_def_vect}) = gpsp1_v(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus)
                fact8(#{$p_def_vect}) = pabdf_nsi(1) * gpden(#{$p_def_vect},igaus) * dtinv_mod(#{$p_def_vect}) + gppor(#{$p_def_vect},igaus)

                do inode = 1,pnode
                   do idime = 1,ndime

                      idofv           = (inode-1)*ndime+idime
                      fact1(#{$p_def_vect}) = fact0(#{$p_def_vect}) * gpcar(#{$p_def_vect},idime,inode,igaus)      

                      do jnode = 1,pnode    
                         do jdime = 1,ndime                   
                            jdofv                       = (jnode-1)*ndime+jdime
                            elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},jdime,jnode,igaus)                   
                         end do

                         jdofv           = (jnode-1)*ndime+idime
                         fact4(#{$p_def_vect}) = gpsha(#{$p_def_vect},inode,igaus) * gpvol(#{$p_def_vect},igaus)
                         fact5(#{$p_def_vect}) = fact4(#{$p_def_vect}) * ( agrau(#{$p_def_vect},jnode,igaus) + fact8(#{$p_def_vect}) * gpsha(#{$p_def_vect},jnode,igaus) ) + fact6(#{$p_def_vect}) *   wgrgr(#{$p_def_vect},inode,jnode,igaus) + fact7(#{$p_def_vect}) *   agrau(#{$p_def_vect},jnode,igaus) * agrau(#{$p_def_vect},inode,igaus)   
                         elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact5(#{$p_def_vect})

                      end do
                   end do
                end do
             end do
          EOF          
         #+END_SRC
******** Thrid nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
             nests[2] =<<EOF
             if( fvins_nsi > 0.9_rp ) then
                do igaus = 1,pgaus
                   do inode = 1,pnode
                      do idime = 1,ndime
                         idofv = (inode-1)*ndime + idime
                         do jnode = 1,pnode
                            fact1(#{$p_def_vect}) = gpvis(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus) * gpcar(#{$p_def_vect},idime,jnode,igaus)     
                            do jdime = 1,ndime
                               jdofv                       = (jnode-1)*ndime + jdime
                               elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},jdime,inode,igaus)
                            end do
                         end do
                         if( fvins_nsi == 2.0_rp ) then
                            fact1(#{$p_def_vect}) = -2.0_rp / 3.0_rp * gpvis(#{$p_def_vect},igaus) * gpvol(#{$p_def_vect},igaus) * gpcar(#{$p_def_vect},idime,inode,igaus)
                            do jnode = 1,pnode
                               do jdime = 1,ndime
                                  jdofv                       = (jnode-1)*ndime + jdime
                                  elauu(#{$p_def_vect},idofv,jdofv) = elauu(#{$p_def_vect},idofv,jdofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},jdime,jnode,igaus)
                               end do
                            end do
                         end if
                      end do
                   end do
                end do
             end if
           EOF
         #+END_SRC
******** Fourth nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
           nests[3] =<<EOF
           if( kfl_lumped == 1 ) then 
              if( ndime == 2 ) then
                 stop
              else
                 do igaus = 1,pgaus
                    gpveo(#{$p_def_vect},1:3) = 0.0_rp
                    do inode = 1,pnode
                       do idime = 1,ndime
                          gpveo(#{$p_def_vect},idime) = gpveo(#{$p_def_vect},idime) + elvel(#{$p_def_vect},idime,inode,2) * gpsha(#{$p_def_vect},inode,igaus)
                       end do
                    end do
                    do inode = 1,pnode
                       idof1                       = 3*inode-2
                       idof2                       = 3*inode-1
                       idof3                       = 3*inode
                       fact0(#{$p_def_vect})             = gpvol(#{$p_def_vect},igaus) * gpden(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},inode,igaus) * dtinv_mod(#{$p_def_vect})
                       elauu(#{$p_def_vect},idof1,idof1) = elauu(#{$p_def_vect},idof1,idof1) + fact0(#{$p_def_vect})
                       elauu(#{$p_def_vect},idof2,idof2) = elauu(#{$p_def_vect},idof2,idof2) + fact0(#{$p_def_vect})
                       elauu(#{$p_def_vect},idof3,idof3) = elauu(#{$p_def_vect},idof3,idof3) + fact0(#{$p_def_vect})
                       do idime = 1,ndime
                          elrbu(#{$p_def_vect},idime,inode) = elrbu(#{$p_def_vect},idime,inode) - fact0(#{$p_def_vect}) * gpveo(#{$p_def_vect},idime)
                          elrbu(#{$p_def_vect},idime,inode) = elrbu(#{$p_def_vect},idime,inode) + fact0(#{$p_def_vect}) * elvel(#{$p_def_vect},idime,inode,2)
                       end do
                       do jnode = 1,pnode 
                          jdof1                       = 3*jnode-2
                          jdof2                       = 3*jnode-1
                          jdof3                       = 3*jnode
                          elauu(#{$p_def_vect},idof1,jdof1) = elauu(#{$p_def_vect},idof1,jdof1) - fact0(#{$p_def_vect}) * gpsha(#{$p_def_vect},jnode,igaus) 
                          elauu(#{$p_def_vect},idof2,jdof2) = elauu(#{$p_def_vect},idof2,jdof2) - fact0(#{$p_def_vect}) * gpsha(#{$p_def_vect},jnode,igaus) 
                          elauu(#{$p_def_vect},idof3,jdof3) = elauu(#{$p_def_vect},idof3,jdof3) - fact0(#{$p_def_vect}) * gpsha(#{$p_def_vect},jnode,igaus) 
                       end do
                    end do
                 end do
              end if

           else if( kfl_lumped == 2 ) then 
              do igaus = 1,pgaus
                 fact0(#{$p_def_vect}) = gpvol(#{$p_def_vect},igaus) * gpden(#{$p_def_vect},igaus) * dtinv_mod(#{$p_def_vect})
                 do inode = 1, pnode
                    fact1(#{$p_def_vect}) = fact0(#{$p_def_vect}) * gpsha(#{$p_def_vect},inode,igaus)
                    do idime = 1,ndime
                       idof1                       = (inode-1) * ndime + idime
                       elauu(#{$p_def_vect},idof1,idof1) = elauu(#{$p_def_vect},idof1,idof1) + fact1(#{$p_def_vect})
                       elrbu(#{$p_def_vect},idime,inode) = elrbu(#{$p_def_vect},idime,inode) + fact1(#{$p_def_vect}) * elvel(#{$p_def_vect},idime,inode,2)
                    end do
                 end do
              end do
           end if
           EOF
         #+END_SRC
******** Fifth nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
            nests[4] =<<EOF
            if( ndime == 2 ) then
               do igaus = 1,pgaus
                  do inode = 1,pnode
                     idof1 = 2*inode-1
                     idof2 = 2*inode
                     do jnode = 1,pnode
                        fact0(#{$p_def_vect})             = gpvol(#{$p_def_vect},igaus)       * gpsha(#{$p_def_vect},jnode,igaus) 
                        fact1(#{$p_def_vect})             = fact0(#{$p_def_vect})             * gpcar(#{$p_def_vect},1,inode,igaus)
                        fact2(#{$p_def_vect})             = fact0(#{$p_def_vect})             * gpcar(#{$p_def_vect},2,inode,igaus)
                        elapu(#{$p_def_vect},jnode,idof1) = elapu(#{$p_def_vect},jnode,idof1) + fact1(#{$p_def_vect})
                        elapu(#{$p_def_vect},jnode,idof2) = elapu(#{$p_def_vect},jnode,idof2) + fact2(#{$p_def_vect})
                        elaup(#{$p_def_vect},idof1,jnode) = elaup(#{$p_def_vect},idof1,jnode) - fact1(#{$p_def_vect})
                        elaup(#{$p_def_vect},idof2,jnode) = elaup(#{$p_def_vect},idof2,jnode) - fact2(#{$p_def_vect})
                     end do
                  end do
               end do
            else
               do igaus = 1,pgaus
                  do inode = 1,pnode
                     idof1 = 3*inode-2
                     idof2 = 3*inode-1
                     idof3 = 3*inode
                     do jnode = 1,pnode
                        fact0(#{$p_def_vect})             = gpvol(#{$p_def_vect},igaus)       * gpsha(#{$p_def_vect},jnode,igaus) 
                        fact1(#{$p_def_vect})             = fact0(#{$p_def_vect})             * gpcar(#{$p_def_vect},1,inode,igaus)
                        fact2(#{$p_def_vect})             = fact0(#{$p_def_vect})             * gpcar(#{$p_def_vect},2,inode,igaus)
                        fact3(#{$p_def_vect})             = fact0(#{$p_def_vect})             * gpcar(#{$p_def_vect},3,inode,igaus)
                        elapu(#{$p_def_vect},jnode,idof1) = elapu(#{$p_def_vect},jnode,idof1) + fact1(#{$p_def_vect})
                        elapu(#{$p_def_vect},jnode,idof2) = elapu(#{$p_def_vect},jnode,idof2) + fact2(#{$p_def_vect})
                        elapu(#{$p_def_vect},jnode,idof3) = elapu(#{$p_def_vect},jnode,idof3) + fact3(#{$p_def_vect}) 
                        elaup(#{$p_def_vect},idof1,jnode) = elaup(#{$p_def_vect},idof1,jnode) - fact1(#{$p_def_vect})
                        elaup(#{$p_def_vect},idof2,jnode) = elaup(#{$p_def_vect},idof2,jnode) - fact2(#{$p_def_vect})
                        elaup(#{$p_def_vect},idof3,jnode) = elaup(#{$p_def_vect},idof3,jnode) - fact3(#{$p_def_vect})
                     end do
                  end do
               end do
            end if
           EOF
         #+END_SRC
******** Sixth nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
           nests[5] =<<EOF
            if( kfl_stabi_nsi /= -1 ) then
               do igaus = 1,pgaus
                  do inode = 1,pnode
                     do jnode = inode+1,pnode
                        fact1(#{$p_def_vect})             = gpsp1_p(#{$p_def_vect},igaus) * wgrgr(#{$p_def_vect},jnode,inode,igaus) * gpvol(#{$p_def_vect},igaus)
                        elapp(#{$p_def_vect},jnode,inode) = elapp(#{$p_def_vect},jnode,inode) + fact1(#{$p_def_vect})
                        elapp(#{$p_def_vect},inode,jnode) = elapp(#{$p_def_vect},inode,jnode) + fact1(#{$p_def_vect})
                     end do
                     fact1(#{$p_def_vect})             = gpsp1_p(#{$p_def_vect},igaus) * wgrgr(#{$p_def_vect},inode,inode,igaus) * gpvol(#{$p_def_vect},igaus)
                     elapp(#{$p_def_vect},inode,inode) = elapp(#{$p_def_vect},inode,inode) + fact1(#{$p_def_vect})
                  end do
               end do
             end if
           EOF
         #+END_SRC
******** Seventh nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
           nests[6] = <<EOF
            do igaus = 1,pgaus
              fact1(#{$p_def_vect}) = penal_nsi * gpvol(#{$p_def_vect},igaus)
              do inode = 1,pnode
                elapp(#{$p_def_vect},inode,inode) = elapp(#{$p_def_vect},inode,inode) + fact1(#{$p_def_vect}) * gpsha(#{$p_def_vect},inode,igaus)
                elrbp(#{$p_def_vect},inode)       = elrbp(#{$p_def_vect},inode)       + fact1(#{$p_def_vect}) * gpsha(#{$p_def_vect},inode,igaus) * elpre(#{$p_def_vect},inode,1) 
              end do
            end do
           EOF
         #+END_SRC
******** Eighth nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
           nests[7] =<<EOF
           if( kfl_stabi_nsi == -1 ) then
              gpvep(#{$p_def_vect},:,:) = 0.0_rp 
           else if( kfl_limit_nsi == -1 ) then
              gpvep(#{$p_def_vect},:,:) = 0.0_rp
           else if( kfl_limit_nsi > 0 ) then
              do igaus = 1,pgaus
                 c1(#{$p_def_vect}) = 0.0_rp
                 c2(#{$p_def_vect}) = 0.0_rp
                 c3(#{$p_def_vect}) = 0.0_rp
                 do idime = 1,ndime
                    c4(#{$p_def_vect}) = 0.0_rp
                    do inode = 1,pnode
                       c4(#{$p_def_vect}) = c4(#{$p_def_vect}) + agrau(#{$p_def_vect},inode,igaus) * elvel(#{$p_def_vect},idime,inode,1)
                    end do
                    c4(#{$p_def_vect}) = gpsp1(#{$p_def_vect},igaus) * c4(#{$p_def_vect})
                    c1(#{$p_def_vect}) = c1(#{$p_def_vect}) + ( gpvep(#{$p_def_vect},idime,igaus) - c4(#{$p_def_vect}) )**2
                    c3(#{$p_def_vect}) = c3(#{$p_def_vect}) + gpvep(#{$p_def_vect},idime,igaus) * gpvep(#{$p_def_vect},idime,igaus)
                    c2(#{$p_def_vect}) = c2(#{$p_def_vect}) + c4(#{$p_def_vect}) * c4(#{$p_def_vect})
                 end do
                 c3(#{$p_def_vect})   = sqrt( c2(#{$p_def_vect}) ) + sqrt( c3(#{$p_def_vect}) )
                 c1(#{$p_def_vect})   = sqrt( c1(#{$p_def_vect}) )
                 beta(#{$p_def_vect}) = c1(#{$p_def_vect}) / ( c3(#{$p_def_vect}) + epsilon(1.0_rp) )
                 if( kfl_limit_nsi == 1 ) then
                    alpha(#{$p_def_vect}) = min(1.0_rp,2.0_rp*(1.0_rp-beta(#{$p_def_vect})))
                 else if( kfl_limit_nsi == 2 ) then
                    alpha(#{$p_def_vect}) = 0.5_rp*(tanh(20.0_rp*(beta(#{$p_def_vect})-0.8_rp))+1.0_rp)
                 end if
                 do idime = 1,ndime
                    gpvep(#{$p_def_vect},idime,igaus) = alpha(#{$p_def_vect}) * gpvep(#{$p_def_vect},idime,igaus)
                 end do
              end do
           end if
           EOF
         #+END_SRC
******** Nineth nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
           nests[8] =<<EOF
           if( kfl_stabi_nsi == -1 ) then
              gpgrp(#{$p_def_vect},:,:) = 0.0_rp
           else
              do igaus = 1,pgaus
                 do idime = 1,ndime
                    gpgrp(#{$p_def_vect},idime,igaus) = gpgrp(#{$p_def_vect},idime,igaus) + gpsp1_p(#{$p_def_vect},igaus) * gprhs(#{$p_def_vect},idime,igaus)
                 end do
              end do
              if( kfl_sgsti_nsi == 1 ) then
                 do igaus = 1,pgaus 
                    fact1(#{$p_def_vect})    = gpden(#{$p_def_vect},igaus) * dtsgs(#{$p_def_vect}) * gpsp1_v(#{$p_def_vect},igaus)
                    fact1_p (#{$p_def_vect}) = gpden(#{$p_def_vect},igaus) * dtsgs(#{$p_def_vect}) * gpsp1_p(#{$p_def_vect},igaus)
                    do idime = 1,ndime
                       gpvep(#{$p_def_vect},idime,igaus) = gpvep(#{$p_def_vect},idime,igaus) + fact1(#{$p_def_vect})   * gpsgs(#{$p_def_vect},idime,igaus,2)
                       gpgrp(#{$p_def_vect},idime,igaus) = gpgrp(#{$p_def_vect},idime,igaus) + fact1_p(#{$p_def_vect}) * gpsgs(#{$p_def_vect},idime,igaus,2)
                    end do
                 end do
              end if
           end if
           EOF
         #+END_SRC
******** Tenth nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
           nests[9] =<<EOF
           do igaus = 1,pgaus
              fact4(#{$p_def_vect}) = gpden(#{$p_def_vect},igaus) * dtinv_mod(#{$p_def_vect})
              do itime = 2,nbdfp_nsi
                 do idime = 1,ndime
                    gprhs(#{$p_def_vect},idime,igaus) = gprhs(#{$p_def_vect},idime,igaus) - pabdf_nsi(itime) * fact4(#{$p_def_vect}) * gpvel(#{$p_def_vect},idime,igaus,itime)
                 end do
              end do
              do inode = 1,pnode
                 fact1(#{$p_def_vect}) = gpvol(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},inode,igaus)  ! ( f + rho*u^n/dt , v )
                 fact3(#{$p_def_vect}) = gpvol(#{$p_def_vect},igaus) * agrau(#{$p_def_vect},inode,igaus)  ! ( rho * a.grad(v) , P1' ) 
                 do idime = 1,ndime
                    elrbu(#{$p_def_vect},idime,inode) = elrbu(#{$p_def_vect},idime,inode) + fact1(#{$p_def_vect}) * gprhs(#{$p_def_vect},idime,igaus) &
                         &                                                    + fact3(#{$p_def_vect}) * gpvep(#{$p_def_vect},idime,igaus)              
                 end do
                 elrbp(#{$p_def_vect},inode) = elrbp(#{$p_def_vect},inode) + gpvol(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},inode,igaus) * gprhc(#{$p_def_vect},igaus)                ! ( rhs, q )
                 do idime = 1,ndime
                    elrbp(#{$p_def_vect},inode) = elrbp(#{$p_def_vect},inode) + gpvol(#{$p_def_vect},igaus) * gpcar(#{$p_def_vect},idime,inode,igaus) * gpgrp(#{$p_def_vect},idime,igaus) ! ( P2' , grad(q) ) 
                 end do
              end do
           end do
           EOF                 
         #+END_SRC
******** Eleventh nest
         #+BEGIN_SRC ruby :tangle /tmp/alya.rb
           nests[10] =<<EOF
           if( maxval(pbubl) == 1 ) then
              if( kfl_stabi_nsi /= -1 ) then
                 write(6,*) 'BUBBLE NOT CODED FOR SPLIT OSS'
                 stop
              end if

              elauq = 0.0_rp
              elapq = 0.0_rp
              elaqu = 0.0_rp
              elaqp = 0.0_rp
              elaqq = 0.0_rp
              elrbq = 0.0_rp

              if( kfl_press_nsi == 1 ) then
                 do igaus = 1,pgaus
                    fact1(#{$p_def_vect}) = gpvol(#{$p_def_vect},igaus) * gpsha_bub(#{$p_def_vect},igaus)
                    do inode = 1,pnode
                       do idime = 1,ndime
                          idofv = (inode-1)*ndime + idime
                          elauq(#{$p_def_vect},idofv,1) = elauq(#{$p_def_vect},idofv,1) - fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},idime,inode,igaus)
                          elaqu(#{$p_def_vect},1,idofv) = elaqu(#{$p_def_vect},1,idofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},idime,inode,igaus) 
                       end do
                    end do
                 end do
              else
                 do igaus = 1,pgaus
                    fact1(#{$p_def_vect}) = gpvol(#{$p_def_vect},igaus) * gpsha_bub(#{$p_def_vect},igaus)
                    do inode = 1,pnode
                       do idime = 1,ndime
                          idofv = (inode-1)*ndime + idime
                          elauq(#{$p_def_vect},idofv,1) = elauq(#{$p_def_vect},idofv,1) + gpvol(#{$p_def_vect},igaus) * gpsha(#{$p_def_vect},inode,igaus) * gpcar_bub(#{$p_def_vect},idime,igaus)
                          elaqu(#{$p_def_vect},1,idofv) = elaqu(#{$p_def_vect},1,idofv) + fact1(#{$p_def_vect}) * gpcar(#{$p_def_vect},idime,inode,igaus) 
                       end do
                    end do
                 end do
              end if
                 
              do igaus = 1,pgaus
                 elaqq(#{$p_def_vect},1,1) = elaqq(#{$p_def_vect},1,1) + gpvol(#{$p_def_vect},igaus) * gpsha_bub(#{$p_def_vect},igaus) * penal_nsi
                 elrbq(#{$p_def_vect},1)   = elrbq(#{$p_def_vect},1)   + gpvol(#{$p_def_vect},igaus) * gpsha_bub(#{$p_def_vect},igaus) * penal_nsi * elbub(#{$p_def_vect}) 
                 elrbq(#{$p_def_vect},1)   = elrbq(#{$p_def_vect},1)   + gpvol(#{$p_def_vect},igaus) * gpsha_bub(#{$p_def_vect},igaus) * gprhc(#{$p_def_vect},igaus) 
              end do

           end if
           EOF
         #+END_SRC
******** Assembling pieces
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          set_lang(FORTRAN)
          k = CKernel::new(:includes => "immintrin.h")
          p = generate_boast_decl(opts)
          k.procedure = p
          get_output.print macros
          get_output.print generate_mocks
          get_output.print generate_ref_declaration(opts)
          get_output.print generate_ref_initialization

          opts[:nests].each{|n|
            get_output.print nests[n-1]
          }

          get_output.print "end subroutine nsi_element_assembly_split_oss"
          return k
          end  
        #+END_SRC
****** BOAST implementation
******* Looking for general pattern :noexport:
        - First:
          Possible to reuse gpcar(:,dim,inode,igaus)
          #+BEGIN_SRC fortran
            agrau(:,inode,igaus) = gpden(:,igaus) * (
                                                gpadv(:,dim,igaus)*gpcar(:,dim,inode,igaus) 
                                                + etc)
            wgrgr(:,inode,jnode,igaus) = gpcar(:,1,inode,igaus)*gpcar(:,1,jnode,igaus)
                                                + etc 
          #+END_SRC
        - Second
          #+BEGIN_SRC fortran
            fact0(:) = gpsp2(:,igaus) * gpvol(:,igaus)
            fact6(:) = gpvis(:,igaus) * gpvol(:,igaus)
            fact7(:) = gpsp1_v(:,igaus) * gpvol(:,igaus) 
            fact8(:) = pabdf_nsi(1) * gpden(:,igaus) * dtinv_loc(:) + gppor(:,igaus)

            factDIM(:) = fact0(:) * gpcar(:,DIM,inode,igaus)
            ...
            fact4(:) = gpsha(:,inode,igaus) * gpvol(:,igaus)

            fact5(:) = fact4(:) * ( agrau(:,jnode,igaus) + fact8(:) * gpsha(:,jnode,igaus) ) & ! ( rho/dt N_j + s Nj + rho*(a.grad)Nj ) Ni
            &         +  fact6(:) * wgrgr(:,inode,jnode,igaus) & ! mu * grad(Ni) . grad(Nj)
            &         +  fact7(:) * agrau(:,jnode,igaus) * agrau(:,inode,igaus) ! tau1 * rho*(a.grad)Nj * rho*(a.grad)Ni

            elauu(:,idofDIMJ,jdofDIMI) = elauu(:,idofDIMJ,jdofDIMI) + factDIMJ(:) * gpcar(:,1,jnode,igaus) + fact5(:)
            elauu(:,idofDIMJ,jdofDIMI) = elauu(:,idofDIMJ,jdofDIMI) + factDIMJ(:) * gpcar(:,1,jnode,igaus)
            ...
                  
          #+END_SRC
        - Third
          Some similarities with the second nest, elauu is almost
          computed the same way with unrolling on the dimension.
          #+BEGIN_SRC fortran
            fact1                       = gpvis(:,igaus) * gpvol(:,igaus) * gpcar(:,idime,jnode,igaus)     
            elauu(:,idofv,jdofv) = elauu(:,idofv,jdofv) + fact1(:) * gpcar(:,DIM,inode,igaus)

            fact1 = -2.0_rp/3.0_rp * gpvis(:,igaus) * gpvol(:,igaus) * gpcar(:,idime,inode,igaus)
            elauu(:,idofv,jdofv) = elauu(:,idofv,jdofv) + fact1(:) * gpcar(:,DIM,inode,igaus)
          #+END_SRC
        - Fourth
          The first elauu and elbru is calculated in the same way between
          kfl_lumped = 1 and 2. Fact 0 = Fact1 but fact1 invovles less
          computations better reuse. The first is unrolled. In
          kfl_lumped = 1 te second elauu is computed with a slightly
          different factor. We could try to parametrize the
          computation of elauu.
          #+BEGIN_SRC fortran
            if( kfl_lumped == 1 ) then 
               gpveo(:,idime) = gpveo(:,idime) + elvel(:,idime,inode,2) * gpsha(:,inode,igaus)
               fact0(:)             = gpvol(:,igaus) * gpden(:,igaus) * gpsha(:,inode,igaus) * dtinv_loc(:)
               elauu(:,idofDIM,idofDIM) = elauu(:,idofDIM,idofDIM) + fact0(:)
               ...

               elrbu(:,idime,inode) = elrbu(:,idime,inode) - fact0(:) * gpveo(:,idime)
               elrbu(:,idime,inode) = elrbu(:,idime,inode) + fact0(:) * elvel(:,idime,inode,2)

               elauu(:,idofDIM,jdofDIM) = elauu(:,idofDIM,jdofDIM) - fact0*gpsha(:,jnode,igaus) 
               ...
            else if( kfl_lumped == 2 ) then 
               fact0(:) = gpvol(:,igaus) * gpden(:,igaus) * dtinv_loc(:)
               fact1(:) = fact0(:) * gpsha(:,inode,igaus)
               elauu(:,idof1,idof1) = elauu(:,idof1,idof1) + fact1(:)
               elrbu(:,idime,inode) = elrbu(:,idime,inode) + fact1(:) * elvel(:,idime,inode,2)
            end if
                  
          #+END_SRC
        - Fiveth
          Same pattern as four. Very close to 2. fact4 = fact0 of 2.
          #+BEGIN_SRC fortran
            ! ( div(u) , q ) and - ( p , div(v) ) 
            !
            fact0(:)             = gpvol(:,igaus) * gpsha(:,jnode,igaus) 
            factDIM(:)             = fact0(:) * gpcar(:,DIM,inode,igaus)
            ...

            elapu(:,jnode,idofDIM) = elapu(:,jnode,idofDIM) + factDIM(:)
            ...

            elaup(:,idofDIM,jnode) = elaup(:,idofDIM,jnode) - factDIM(:)
            ...
          #+END_SRC
        - Sixth
          #+BEGIN_SRC fortran
            !     Pressure: ( tau1' * grad(p) , grad(q) )
            !     
            fact1(:)             = gpsp1_p(:,igaus) * wgrgr(:,jnode,inode,igaus) * gpvol(:,igaus)
            elapp(:,jnode,inode) = elapp(:,jnode,inode) + fact1(:)
            elapp(:,inode,jnode) = elapp(:,inode,jnode) + fact1(:)

            fact1(:)             = gpsp1_p(:,igaus) * wgrgr(:,inode,inode,igaus) * gpvol(:,igaus)
            elapp(:,inode,inode) = elapp(:,inode,inode) + fact1(:)
          #+END_SRC
        - Seventh
          #+BEGIN_SRC fortran
            !----------------------------------------------------------------------
            !
            ! bu and bp
            !
            ! P1  = P [ tau1' * rho * a.grad(u) ]
            ! P1' = P1 + tau1' * rho * u'n / dt
            !
            ! P2  = P [ tau1' * ( grad(p) - f ) ]
            ! P2' = P2 + tau1' * rho * u'n / dt + tau1' * f 
            !
            !----------------------------------------------------------------------

                  c4(:) = c4(:) + agrau(:,inode,igaus) * elvel(:,idime,inode,1)

                  c4(:) = gpsp1(:,igaus) * c4(:)
                  c1(:) = c1(:) + ( gpvep(:,idime,igaus) - c4(:) )**2
                  c3(:) = c3(:) + gpvep(:,idime,igaus) * gpvep(:,idime,igaus)
                  c2(:) = c2(:) + c4(:) * c4(:)

                  c3(:)   = sqrt( c2(:) ) + sqrt( c3(:) )
                  c1(:)   = sqrt( c1(:) )
                  beta(:) = c1(:) / ( c3(:) + epsilon(1.0_rp) )

                  if( kfl_limit_nsi == 1 ) then
                     alpha(:) = min(1.0_rp,2.0_rp*(1.0_rp-beta(:)))
                  else if( kfl_limit_nsi == 2 ) then
                     alpha(:) = 0.5_rp*(tanh(20.0_rp*(beta(:)-0.8_rp))+1.0_rp)
                  end if

                  gpvep(:,idime,igaus) = alpha(:) * gpvep(:,idime,igaus)
          #+END_SRC
        - Eighth
          #+BEGIN_SRC fortran
            !     
            !     P2 <= P2 + tau1' * f
            !     
            gpgrp(DEF_VECT,idime,igaus) = gpgrp(DEF_VECT,idime,igaus) + gpsp1_p(DEF_VECT,igaus) * gprhs(DEF_VECT,idime,igaus)
          #+END_SRC
        - Nineth
          #+BEGIN_SRC fortran
            !     P1 <= P1 + tau1' * rho * u'n / dt
            !     P2 <= P2 + tau1' * rho * u'n / dt
            !     
                  fact1(DEF_VECT)    = gpden(DEF_VECT,igaus) * dtsgs(DEF_VECT) * gpsp1_v(DEF_VECT,igaus)
                  fact1_p (DEF_VECT) = gpden(DEF_VECT,igaus) * dtsgs(DEF_VECT) * gpsp1_p(DEF_VECT,igaus)

                  gpvep(DEF_VECT,idime,igaus) = gpvep(DEF_VECT,idime,igaus) + fact1(DEF_VECT)   * gpsgs(DEF_VECT,idime,igaus,2)
                  gpgrp(DEF_VECT,idime,igaus) = gpgrp(DEF_VECT,idime,igaus) + fact1_p(DEF_VECT) * gpsgs(DEF_VECT,idime,igaus,2)
          #+END_SRC
        - Tenth
          #+BEGIN_SRC fortran
            !     bu = ( f + rho*u^n/dt , v ) + ( rho * a.grad(v) , tau1' * rho u'^n/dt + P1 ) 
            !    = ( f + rho*u^n/dt , v ) + ( rho * a.grad(v) , P1' ) 
            !
            ! bp = ( f + rho*u'^n/dt , tau1' grad(q) ) + ( P2 , grad(q) )
            !    = ( P2' , grad(q) ) 
            !

                  fact4(DEF_VECT) = gpden(DEF_VECT,igaus) * dtinv_loc(DEF_VECT)

                  gprhs(DEF_VECT,DIM,igaus) = gprhs(DEF_VECT,DIM,igaus) - pabdf_nsi(itime) * fact4(DEF_VECT) * gpvel(DEF_VECT,DIM,igaus,itime)  
                  ...


                  fact1(DEF_VECT) = gpvol(DEF_VECT,igaus) * gpsha(DEF_VECT,inode,igaus) ! ( f + rho*u^n/dt , v )
                  fact3(DEF_VECT) = gpvol(DEF_VECT,igaus) * agrau(DEF_VECT,inode,igaus) ! ( rho * a.grad(v) , P1' ) 

                  elrbu(DEF_VECT,DIM,inode)  = elrbu(DEF_VECT,DIM,inode) + fact1(DEF_VECT) * gprhs(DEF_VECT,DIM,igaus) + fact3(DEF_VECT) * gpvep(DEF_VECT,DIM,igaus) 
                  ...

                  elrbp(DEF_VECT,inode)    = elrbp(DEF_VECT,inode)   + gpvol(DEF_VECT,igaus) * ( ! ( P2' , grad(q) ) 
                  gpcar(DEF_VECT,DIM,inode,igaus) * gpgrp(DEF_VECT,DIM,igaus)  
                  + ...
          #+END_SRC
******* Fake pabdf_nsi
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          def generate_boast_implem(options) 
            opts = {:vector_length => 1, :preprocessor => false, :nests => (1..10).to_a, :unroll => false}
            opts.update(options)
            register_funccall("sqrt")
            register_funccall("maxval")
            register_funccall("min")
            register_funccall("epsilon")
            register_funccall("tanh")

            x = Int("x", :dir => :in)
            y = Real("y")
            pabdf_nsi = Procedure("pabdf_nsi",[x], :return => y){
              pr y === 1.0
            }          
            k_pabdf_nsi = CKernel::new
            k_pabdf_nsi.procedure = pabdf_nsi
            k_pabdf_nsi.build
            
        #+END_SRC
******* Declaration
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          p = generate_boast_decl(opts, [pabdf_nsi])
          k = CKernel::new( :includes => "immintrin.h" )
          k.procedure = p
          pr k_pabdf_nsi.procedure
          opn p
            # Local arrays
            decl gpsp1_p   = Real("gpsp1_p",   :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            decl gpsp1_v   = Real("gpsp1_v",   :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            decl gpsp2_v   = Real("gpsp2_v",   :vector_length => opts[:vector_length], :dim => [Dim($pgaus)])
            decl c1        = Real("c1",        :vector_length => opts[:vector_length], :dim => [Dim(1)])
            decl c2        = Real("c2",        :vector_length => opts[:vector_length], :dim => [Dim(1)])
            decl c3        = Real("c3",        :vector_length => opts[:vector_length], :dim => [Dim(1)])
            decl c4        = Real("c4",        :vector_length => opts[:vector_length], :dim => [Dim(1)])
            decl alpha     = Real("alpha",     :vector_length => opts[:vector_length], :dim => [Dim(1)])
            decl beta      = Real("beta",      :vector_length => opts[:vector_length], :dim => [Dim(1)])

            decl gpveo     = Real("gpveo",     :vector_length => opts[:vector_length], :dim => [Dim(3)])
            decl fact1_p   = Real("fact1_p",   :vector_length => opts[:vector_length], :dim => [Dim(1)])
            decl dtinv_mod = Real("dtinv_mod", :vector_length => opts[:vector_length], :dim => [Dim(1)])
            decl inode     = Int("inode")
            decl jnode     = Int("jnode")
            decl jdime     = Int("jdime")
            decl idofv     = Int("idofv")
            decl ivect     = Int("ivect")
            decl igaus     = Int("igaus")
            decl idime     = Int("idime")
            decl jdofv     = Int("jdofv")
            decl itime     = Int("itime")

            decl fact = Real('fact',           :vector_length => opts[:vector_length], :dim => [Dim(8)])

            decl idof = Int("idof", :dim => [Dim(3)])
            decl jdof = Int("jdof", :dim => [Dim(3)])
        #+END_SRC
******* Initialisation
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:unroll] then
            dimensions = [2,3]
          else
            dimensions = [$ndime]
          end
          pr dtinv_mod === $dtinv_loc
          pr gpsp1_p === $gpsp1
          pr gpsp1_v === $gpsp1
          pr gpsp2_v === $gpsp2

          pr If( $kfl_nota1_nsi == 1 => lambda{ pr gpsp1_v === 0.0 } )

          pr $elrbp === 0.0
          pr $elrbu === 0.0
          pr $elapp === 0.0
          pr $elauu === 0.0
          pr $elaup === 0.0
          pr $elapu === 0.0
        #+END_SRC
******* First loop
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 1 then
            for1 = []

            2.times{|j|
              dim = j+2
              exp1 = ""
              exp2 = ""
              dim.times{|i|
                exp1 += "$gpadv[#{i+1},igaus]*$gpcar[#{i+1},inode,igaus]"
                exp2 += "$gpcar[#{i+1},inode,igaus]*$gpcar[#{i+1},jnode,igaus]"
                exp1 +=  " + " if i+1 < dim
                exp2 +=  " + " if i+1 < dim
              }
              
              form_agrau = "pr $agrau[inode,igaus] === $gpden[igaus] * (#{exp1})"
              form_wgrgr = "pr $wgrgr[inode,jnode,igaus] === #{exp2}"

              for1[j] = For(igaus,1,$pgaus){
                pr For(inode,1,$pnode){
                  eval form_agrau
                  pr For(jnode,1,$pnode){                    
                    eval form_wgrgr
                  }
                }
              }
            }

            pr If($ndime == 2 => lambda{
                    pr for1[0]
                  }, else: lambda{
                    pr for1[1]
                  })  
          end
        #+END_SRC
******* Second loop
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 2 then
            block_fact0 = lambda{
              pr fact[0] === $gpsp2[igaus] * $gpvol[igaus]
            }

            block_fact6 = lambda{
              pr fact[6] === $gpvis[igaus] * $gpvol[igaus]
            }

            block_fact7 = lambda{
              pr fact[7] === gpsp1_v[igaus] * $gpvol[igaus]
            }
            
            block_fact8 = lambda{
              pr fact[8] ===  $gpden[igaus] * k_pabdf_nsi.procedure.call(1) * $dtinv_loc[1] + $gppor[igaus]
            }

            block_fact5 = lambda{
              pr fact[5] === fact[4] * ($agrau[jnode,igaus] + fact[8] * $gpsha[jnode,igaus] ) + fact[6] * $wgrgr[inode,jnode,igaus] + fact[7] * $agrau[jnode,igaus] * $agrau[inode,igaus]
            }
            
            block_factn = lambda{|dim|
              dim.times{|i|
                pr fact[i+1] === fact[0] * $gpcar[i+1,inode,igaus]
              }
            }

            block_fact4 = lambda {
              pr fact[4] === $gpsha[inode,igaus] * $gpvol[igaus]
            }

            block_elauu = lambda{|dim|              
              for i in 0...dim do 
                for j in 0...dim do
                  exp = "pr $elauu[idof[#{j}],jdof[#{i}]] === $elauu[idof[#{j}],jdof[#{i}]] + fact[#{j+1}] * $gpcar[#{i+1},jnode,igaus]"
                  exp = exp + " + fact[#{5}]" if i == j
                  eval exp
                end
              end
            }
            # end            

            for1 = []
            2.times{|j|
              dim = j+2
              for1[j] = For(igaus,1,$pgaus){ 
                block_fact0.call               
                block_fact6.call
                block_fact7.call
                block_fact8.call

                pr For(inode,1,$pnode){
                  dim.times{|i|
                    pr idof[i] === inode*dim - dim+i+1
                  }
                  block_factn.call(dim)
                  block_fact4.call
                  
                  pr For(jnode,1,$pnode){
                    dim.times{|i|
                      pr jdof[i] === jnode*dim - dim+i+1
                    }

                    block_fact5.call
                    block_elauu.call(dim)
                  }
                }
              }
            }
            pr If($ndime == 2 => lambda{
                    pr for1[0]
                  }, else: lambda{
                    pr for1[1]
                  })  
          end
        #+END_SRC
******* Third nest
        Different loop reorganisation can be made here. Fact1 coudl be
        computed more efficiently. The memory access to gpcar are made
        in a contiguous way but by column. It access different memory
        location pnode^2 x ndime times for gpcar. Same thing for elauu,
        there are 2.(2.ndime^2 . pnode^2 + ndime/x . pnode ). The 1/x
        come from contiguous memory access that allow to take
        advantages of L1 cache with a size of cache x. Because gpcar
        is accessed sequentially to compute elauu. Here to compute elauu
        we can either use the cache for elauu or gpcar.
        Access to elauu are most costly than gpcar because it is accessed more
        often. So made be it worth to reorganize loops to access elauu
        the more sequentially possible.

        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 3 then
            for_inode = For(inode,1,$pnode)
            for_jnode = For(jnode,1,$pnode)
            for_idime = For(idime,1,$ndime)
            for_jdime = lambda{ |dim| return For(jdime,1,dim) }

            block1 = lambda{
              pr fact[1] === $gpvis[igaus] * $gpvol[igaus] * $gpcar[idime,jnode,igaus]
            }

            block2 = lambda{
              pr idofv === (inode-1)*$ndime + idime
            }

            block3 = lambda{
              pr jdofv === (jnode-1)*$ndime + jdime
              pr $elauu[idofv,jdofv] === $elauu[idofv,jdofv] + fact[1] * $gpcar[jdime,inode,igaus]
            }

            block4 = lambda{
              # pr fact[1] === gpvis[1,igaus] * -0.66666668653488159 * gpvol[1,igaus] * gpcar[1,idime,inode,igaus]
              pr fact[1] === $gpvis[igaus] * (-2.0 / 3.0) * $gpvol[igaus] * $gpcar[idime,inode,igaus]
            }

            block5 = lambda{
              pr jdofv === (jnode-1)*$ndime + jdime
              pr $elauu[idofv,jdofv] === $elauu[idofv,jdofv] + fact[1] * $gpcar[jdime,jnode,igaus]
            }


            pr If($fvins_nsi > 0.9){
              for1 = []
              2.times{|j|
                dim = j+2
                for1[j] = For(igaus,1,$pgaus){ 

                  opn for_inode
                    opn for_idime
                      block2.call
                      opn for_jnode
                        block1.call
                        pr for_jdime.call(dim).unroll, &block3
                      close for_jnode
                      pr If($fvins_nsi == 2.0){
                        block4.call
                        opn for_jnode
                          pr for_jdime.call(dim).unroll, &block5
                        close for_jnode
                      }
                    close for_idime
                  close for_inode
                }
              }
              pr If($ndime == 2 => lambda{
                      pr for1[0]
                    }, else: lambda{
                      pr for1[1]
                    })  
              else
                pr for1[0]
              end
            }
          end
        #+END_SRC
******* Fourth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 4 then
            exp_fact0 = fact[0] === $gpvol[igaus] * $gpden[igaus] * dtinv_mod[1]            
            exp_fact1 = fact[1] === fact[0] *$gpsha[inode,igaus]
            exp_elrbu = $elrbu[idime,inode] === $elrbu[idime,inode] + fact[1] * $elvel[idime,inode,2]

            for_elauu1 = []           
            for_elbru2 = []
            (2..3).each{|dim|
              for_elauu1[for_elauu1.length] = For(idime,1,dim){
                pr idof[idime] === (inode-1)*dim+idime
                pr $elauu[idof[idime],idof[idime]] === $elauu[idof[idime],idof[idime]] + fact[1]
              }
              for_elbru2[for_elbru2.length] = For(idime,1,dim){
                pr exp_elrbu
              }
            }

            for_elauu2 = For(jdime,1,3){
              pr jdof[jdime] === (jnode-1)*$ndime+jdime
              pr $elauu[idof[jdime],jdof[jdime]] === $elauu[idof[jdime],jdof[jdime]] - fact[1] * $gpsha[jnode,igaus]
            }

            for_elbru1 = For(idime,1,3){
              pr $elrbu[idime,inode] ===  $elrbu[idime,inode] - fact[1] * gpveo[idime]
              pr exp_elrbu
            }

            block_kfl_lumped_1 = lambda{
              pr For(igaus,1,$pgaus){
                pr gpveo === 0.0 
                pr For(inode,1,$pnode){
                  for1 = For(idime,1,3){
                    pr gpveo[idime] === gpveo[idime] + $elvel[idime,inode,2] * $gpsha[inode,igaus] 
                  }
                  if opts[:unroll] then
                    pr for1.unroll
                  else
                    pr for1
                  end
                }
                pr exp_fact0
                pr For(inode,1,$pnode){
                  pr exp_fact1
                  if opts[:unroll] then
                    pr for_elauu1[1].unroll
                    pr for_elbru1.unroll
                  else
                    pr for_elauu1[1]
                    pr for_elbru1
                  end
                  pr For(jnode,1,$pnode){
                    if opts[:unroll] then
                      pr for_elauu2.unroll
                    else
                      pr for_elauu2
                    end
                  }
                }
              }
            }

            block_kfl_lumped_2 = []
            2.times{|i|
              block_kfl_lumped_2[i] = lambda{
                pr For(igaus,1,$pgaus){
                  pr exp_fact0
                  pr For(inode,1,$pnode){
                    pr exp_fact1
                    if opts[:unroll] then
                      pr for_elauu1[i].unroll
                      pr for_elbru2[i].unroll
                    else
                      pr for_elauu1[i]
                      pr for_elbru2[i]
                    end
                  }
                }
              }
            }

            if_kfl_lumped_1 = lambda{ pr If($ndime == 2 => lambda{}, :else => block_kfl_lumped_1) }      
            if_kfl_lumped_2 = lambda{ pr If($ndime == 2 => block_kfl_lumped_2[0] , :else => block_kfl_lumped_2[1])}

            pr If($kfl_lumped == 1 => if_kfl_lumped_1, $kfl_lumped == 2 => if_kfl_lumped_2)  
          end
        #+END_SRC

******* Fifth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 5 then
            for1 = []
            (2..3).each{|dim|
              for1[for1.length] = For(igaus,1,$pgaus){
                pr For(inode,1,$pnode){
                  for2 = For(idime,1,dim){
                    pr idof[idime] === (inode-1)*dim + idime
                  }
                  if opts[:unroll] then
                    pr for2.unroll
                  else
                    pr for2
                  end
                  pr For(jnode,1,$pnode){
                    pr fact[0] === $gpvol[igaus] * $gpsha[jnode,igaus]
                    for i in 1..dim do
                      pr fact[i] === fact[0] * $gpcar[i,inode,igaus]
                    end
                    for2 = For(jdime,1,dim){
                      pr $elapu[jnode,idof[jdime]] === $elapu[jnode,idof[jdime]] + fact[jdime]
                    }
                    if opts[:unroll] then
                      pr for2.unroll
                    else
                      pr for2
                    end
                    for2 = For(jdime,1,dim){
                      pr $elaup[idof[jdime],jnode] === $elaup[idof[jdime],jnode] - fact[jdime]
                    }
                    if opts[:unroll] then
                      pr for2.unroll
                    else
                      pr for2
                    end
                  }
                }
              }
            }

            pr If($ndime == 2 => lambda{
                    pr for1[0]
                  }, else: lambda{
                    pr for1[1]
                  })  
            
          end
        #+END_SRC
******* Sixth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 6 then
            pr If($kfl_stabi_nsi != -1){
              pr For(igaus,1,$pgaus){
                pr For(inode,1,$pnode){
                  pr For(jnode,inode+1,$pnode){
                    pr fact[1]             === gpsp1_p[igaus] * $wgrgr[jnode,inode,igaus] * $gpvol[igaus]
                    pr $elapp[jnode,inode] === $elapp[jnode,inode] + fact[1]
                    pr $elapp[inode,jnode] === $elapp[inode,jnode] + fact[1]
                  }
                  pr fact[1]             === gpsp1_p[igaus] * $wgrgr[inode,inode,igaus] * $gpvol[igaus]
                  pr $elapp[inode,inode] === $elapp[inode,inode] + fact[1]
                }
              }
            }
          end
        #+END_SRC
******* Seventh nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 7 then
            pr For(igaus,1,$pgaus){
              pr fact[1] === $penal_nsi * $gpvol[igaus]
              pr For(inode,1,$pnode){
                pr $elapp[inode,inode] === $elapp[inode,inode] + fact[1] * $gpsha[inode,igaus]
                pr $elrbp[inode]       === $elrbp[inode]       + fact[1] * $gpsha[inode,igaus] * $elpre[inode,1]
              }
            }
          end
        #+END_SRC        
******* Eighth nest
        Maybe blocking can be interesting for the first nested loop.
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 8 then
            for_igaus = For(igaus,1,$pgaus){
              pr c1[1] === 0.0 
              pr c2[1] === 0.0 
              pr c3[1] === 0.0 
              
              pr For(idime,1,$ndime){
                pr c4[1] === 0.0
                pr For(inode,1,$pnode){
                  pr c4[1] === c4[1] + $agrau[inode,igaus] * $elvel[idime,inode,1]
                }
                pr c4[1] === $gpsp1[igaus] * c4[1]
                pr c1[1] === c1[1] + ( $gpvep[idime,igaus] - c4[1] )**2
                pr c3[1] === c3[1] + $gpvep[idime,igaus] * $gpvep[idime,igaus]
                pr c2[1] === c2[1] + c4[1] * c4[1]
              }

              # Impossible to have operator with register functions
              # pr c3[1]   === sqrt( c2[1] ) + sqrt( c3[1] )  
              pr c3[1]   === sqrt( c3[1] )  
              pr c3[1]   === c3[1] + sqrt( c2[1] )
              pr c1[1]   === sqrt( c1[1] )
              pr beta[1] === c1[1] / ( c3[1] + epsilon(1.0) )

              pr If($kfl_limit_nsi == 1 => lambda{
                      pr alpha[1] === min(1.0,(-beta[1]+1.0)*2.0)
                    }, $kfl_limit_nsi == 2 => lambda{
                      pr alpha[1] === (tanh((beta[1]-0.8)*20.0)+1.0)*0.5
                    })
              pr For(idime,1,$ndime){
                pr $gpvep[idime,igaus] === alpha[1] * $gpvep[idime,igaus]
              }
            }

            
            pr If( $kfl_stabi_nsi == -1 => lambda{
                     pr $gpvep === 0.0
                   }, $kfl_limit_nsi == -1 => lambda{
                     pr $gpvep === 0.0
                   }, $kfl_limit_nsi > 0 => lambda{ pr for_igaus } )
          end
        #+END_SRC        
******* Nineth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 9 then
            for_igaus = []
            for_igaus[0] = []
            for_igaus[1] = []
            
            if opts[:unroll] then
              dimensions = [2,3]
            else
              dimensions = [$ndime]
            end
          
            dimensions.each{|dim|
          
              for_igaus[0][for_igaus[0].length] = For(igaus,1,$pgaus){
                for1 = For(idime,1,dim){
                  pr $gpgrp[idime,igaus] === $gpgrp[idime,igaus] + gpsp1_p[igaus] * $gprhs[idime,igaus]
                }
                if opts[:unroll] then
                  pr for1.unroll
                else
                  pr for1
                end
              }
                    
              for_igaus[1][for_igaus[1].length] = For(igaus,1,$pgaus){
                pr fact[1]     === $gpden[igaus] * $dtsgs[1] * gpsp1_v[igaus]
                pr fact1_p[1]  === $gpden[igaus] * $dtsgs[1] * gpsp1_p[igaus]
                for1 = For(idime,1,dim){
                  pr $gpvep[idime,igaus] === $gpvep[idime,igaus] + fact[1]    * $gpsgs[idime,igaus,2]
                  pr $gpgrp[idime,igaus] === $gpgrp[idime,igaus] + fact1_p[1] * $gpsgs[idime,igaus,2]
                }
                if opts[:unroll] then
                  pr for1.unroll
                else
                  pr for1
                end
              }
            }
          
            if_ndime = []
            2.times{|i|
              if opts[:unroll] then
                if_ndime[i] = If($ndime == 2 => lambda{
                                   pr for_igaus[i][0]
                                 }, :else => lambda{
                                   pr for_igaus[i][1]
                                 })
              else
                if_ndime[i] = for_igaus[i][0]
              end
            }
            
            block = lambda{
              pr if_ndime[0]
              pr If($kfl_sgsti_nsi == 1){
                pr if_ndime[1]
              }
            }
          
            pr If($kfl_stabi_nsi == -1 => lambda{ pr $gpgrp === 0.0 }, :else => block)
          end
        #+END_SRC        
******* Tenth nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 10 then
            for_igaus = []
            dimensions.each{|dim|
              for_igaus[for_igaus.length] = For(igaus,1,$pgaus){
                pr fact[4] === $gpden[igaus] * dtinv_mod[1]
                pr For(itime,2,$nbdfp_nsi){
                  for_idime = For(idime,1,dim){
                    pr $gprhs[idime,igaus] === $gprhs[idime,igaus] - k_pabdf_nsi.procedure.call(itime) * fact[4] * $gpvel[idime,igaus,itime]
                  }
                  if opts[:unroll] then
                    pr for_idime.unroll
                  else
                    pr for_idime
                  end
                }
                pr For(inode,1,$pnode){
                  pr fact[1] === $gpvol[igaus] * $gpsha[inode,igaus]  # ( f + rho*u^n/dt , v )
                  pr fact[3] === $gpvol[igaus] * $agrau[inode,igaus]  # ( rho * a.grad(v) , P1' ) 
                  for_idime = For(idime,1,dim){
                    pr $elrbu[idime,inode] === $elrbu[idime,inode] + fact[1] * $gprhs[idime,igaus] + fact[3] * $gpvep[idime,igaus]
                  }
                  if opts[:unroll] then
                    pr for_idime.unroll
                  else
                    pr for_idime
                  end
                  pr $elrbp[inode] === $elrbp[inode] + $gpvol[igaus] * $gpsha[inode,igaus] * $gprhc[igaus]  # ( rhs, q )
                  for_idime = For(idime,1,dim){
                    pr $elrbp[inode] === $elrbp[inode] + $gpvol[igaus] * $gpcar[idime,inode,igaus] * $gpgrp[idime,igaus] # ( P2' , grad(q) ) 
                  }
                  if opts[:unroll] then
                    pr for_idime.unroll
                  else
                    pr for_idime
                  end
                }
              }
            }
            
            if opts[:unroll] then
              pr If($ndime == 2 => lambda{ pr for_igaus[0] }, :else => lambda{ pr for_igaus[1] })
            else
              pr for_igaus[0]
            end
          end
        #+END_SRC        

******* Eleventh nest
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
          if opts[:nests].include? 11 then
            exp_elauq = []
            exp_elauq[0] = "$elauq[idof[dim],1] === $elauq[idof[dim],1] - fact[1] * $gpcar[idime,inode,igaus]"
            exp_elauq[1] = "$elauq[idof[dim],1] === $elauq[idof[dim],1] + $gpvol[igaus] * $gpsha[inode,igaus] * $gpcar_bub[idime,igaus]"

            block_igaus = lambda{|dim,exp|
              return For(igaus,1,$pgaus){
                pr fact[1] === $gpvol[igaus] * $gpsha_bub[igaus]
                pr For(inode,1,$pnode){
                  for_idime = For(idime,1,dim){
                    pr idof[dim] === (inode-1)*dim + idime
                    pr eval exp
                    pr $elaqu[1,idof[dim]] === $elaqu[1,idof[dim]] + fact[1] * $gpcar[idime,inode,igaus]
                  }
                  if opts[:unroll] then
                    pr for_idime.unroll
                  else
                    pr for_idime
                  end
                }
              }
            }

            if opts[:unroll] then
              if_kfl_press_nsi_1 = If($ndime == 2 => lambda{ pr block_igaus.call(dimensions[0],exp_elauq[0]) }, :else => lambda{ pr block_igaus.call(dimensions[1],exp_elauq[0]) })
              if_kfl_press_nsi_else = If($ndime == 2 => lambda{ pr block_igaus.call(dimensions[0],exp_elauq[1]) }, :else => lambda{ pr block_igaus.call(dimensions[1],exp_elauq[1]) })
            else
              if_kfl_press_nsi_1 = block_igaus.call(dimensions[0],exp_elauq[0])
              if_kfl_press_nsi_else = block_igaus.call(dimensions[0],exp_elauq[1])
            end

            pr If(maxval($pbubl) == 1){
              pr If($kfl_stabi_nsi != -1){
                if get_lang == FORTRAN then
                  stop
                end
              }
              
              pr $elauq === 0.0
              pr $elapq === 0.0
              pr $elaqu === 0.0
              pr $elaqp === 0.0
              pr $elaqq === 0.0
              pr $elrbq === 0.0

              pr If($kfl_press_nsi == 1 => lambda{ pr if_kfl_press_nsi_1}, :else => lambda{ pr if_kfl_press_nsi_else })

              pr For(igaus,1,$pgaus){
                pr $elaqq[1,1] === $elaqq[1,1] + $gpvol[igaus] * $gpsha_bub[igaus] * $penal_nsi
                pr $elrbq[1]   === $elrbq[1]   + $gpvol[igaus] * $gpsha_bub[igaus] * $penal_nsi * $elbub[1]
                pr $elrbq[1]   === $elrbq[1]   + $gpvol[igaus] * $gpsha_bub[igaus] * $gprhc[igaus]
              }
            }
          end
        #+END_SRC        
******* Closing procedure
        #+BEGIN_SRC ruby :tangle /tmp/alya.rb
            close p
            return k
          end        
        
        #+END_SRC
****** Comparing with ref
      - Runing kernel
        #+BEGIN_SRC ruby 
          require '/tmp/alya.rb'
          nests = [1,2]
          vector_size=2

          k_orig_params = {:vector_length => vector_size, :preprocessor => false, :nests => nests}
          k_boast_params = {:vector_length => vector_size, :nests => nests}

          k_orig = generate_ref(k_orig_params)
          k_orig.build(:FCFLAGS => "-cpp")

          set_lang(FORTRAN)
          set_fortran_line_length(120)
          k_boast = generate_boast_implem(k_boast_params)
          k_boast.build

          pnode = 100
          mnode = 100
          pgaus = 100
          pevat = 100
          ndime = 2
          fvins_nsi = 2.0
          kfl_lumped = 1
          kfl_limit_nsi = 1
          kfl_sgsti_nsi = 1
          nbdfp_nsi = 3

          stats_boast = []
          stats_ref = []

          NArray.srand(10)
          100.times{|i|
            gpden = NArray.float(vector_size,pgaus).random
            gpvis = NArray.float(vector_size,pgaus).random
            gppor = NArray.float(vector_size,pgaus).random 
            gpsp1 = NArray.float(vector_size,pgaus).random 
            gpsp2 = NArray.float(vector_size,pgaus).random 
            gpvol = NArray.float(vector_size,pgaus).random 
            gpsha = NArray.float(vector_size,pnode,pgaus).random 
            gpcar = NArray.float(vector_size,ndime,mnode,pgaus).random
            gpadv = NArray.float(vector_size,ndime,pgaus).random 
            gpvep = NArray.float(vector_size,ndime,pgaus).random 
            gpprp = NArray.float(vector_size,pgaus).random 
            gpgrp = NArray.float(vector_size,ndime,pgaus).random 
            gprhs = NArray.float(vector_size,ndime,pgaus).random 
            gpvel = NArray.float(vector_size,ndime,pgaus,10).random #dynamic
            gpsgs = NArray.float(vector_size,ndime,pgaus,10).random #dynamic 
            elvel = NArray.float(vector_size,ndime,pnode,10).random #dynamic
            dtinv_loc = NArray.float(vector_size).random
            dtsgs = NArray.float(vector_size).random

            wgrgr_ref = NArray.float(vector_size,pnode,pnode,pgaus)
            agrau_ref = NArray.float(vector_size,pnode,pgaus)
            elauu_ref = NArray.float(vector_size,pnode*ndime,pnode*ndime)
            elaup_ref = NArray.float(vector_size,pnode*ndime,pnode)
            elapp_ref = NArray.float(vector_size,pnode,pnode)
            elapu_ref = NArray.float(vector_size,pnode,pnode*ndime)
            elrbu_ref = NArray.float(vector_size,ndime,pnode)
            elrbp_ref = NArray.float(vector_size,pnode)

            wgrgr_boast = NArray.float(vector_size,pnode,pnode,pgaus)
            agrau_boast = NArray.float(vector_size,pnode,pgaus)
            elauu_boast = NArray.float(vector_size,pnode*ndime,pnode*ndime)
            elaup_boast = NArray.float(vector_size,pnode*ndime,pnode)
            elapp_boast = NArray.float(vector_size,pnode,pnode)
            elapu_boast = NArray.float(vector_size,pnode,pnode*ndime)
            elrbu_boast = NArray.float(vector_size,ndime,pnode)
            elrbp_boast = NArray.float(vector_size,pnode)

            stats_ref[i] = k_orig.run(ndime,mnode,pnode,pgaus,pevat,gpden,gpvis,gppor,
                                   gpsp1,gpsp2,gpvol,gpsha,gpcar,gpadv,gpvep,gpprp,
                                   gpgrp,gprhs,gpvel,gpsgs,wgrgr_ref,agrau_ref,elvel,elauu_ref,
                                   elaup_ref,elapp_ref,elapu_ref,elrbu_ref,elrbp_ref,dtinv_loc,dtsgs,
                                   fvins_nsi,kfl_lumped,kfl_limit_nsi,kfl_sgsti_nsi,nbdfp_nsi)

            stats_boast[i] = k_boast.run(ndime,mnode,pnode,pgaus,pevat,gpden,gpvis,gppor,
                                      gpsp1,gpsp2,gpvol,gpsha,gpcar,gpadv,gpvep,gpprp,
                                      gpgrp,gprhs,gpvel,gpsgs,wgrgr_boast,agrau_boast,elvel,elauu_boast,
                                      elaup_boast,elapp_boast,elapu_boast,elrbu_boast,elrbp_boast,dtinv_loc,dtsgs,
                                      fvins_nsi,kfl_lumped,kfl_limit_nsi,kfl_sgsti_nsi,nbdfp_nsi)

            exit if not agrau_boast == agrau_ref
            exit if not wgrgr_boast == wgrgr_ref
            exit if not elauu_boast == elauu_ref
          }
          t = []
          t[0] = stats_ref.inject(0){|sum,e| sum+e[:duration]} / stats_ref.length
          t[1] = stats_boast.inject(0){|sum,e| sum+e[:duration]} / stats_boast.length
          t
        #+END_SRC

        #+RESULTS:
        | 0.16196962300999998 | 0.034613893740000005 |

* Sandbox :noexport:
** Fortran
*** Loop vectorization
    #+BEGIN_SRC fortran
      #define PGAUS 10
      #define PNODE 50
       #define DEF_VECT 75
            
            program test
            
            real :: t1(DEF_VECT,PNODE,PGAUS)
            real :: t2(DEF_VECT,PNODE,PGAUS)
            real :: t3(DEF_VECT,PGAUS)
            real :: res1(DEF_VECT,PNODE,PGAUS)
            real :: res1b(DEF_VECT,PNODE,PGAUS)
            real :: res2(DEF_VECT,PNODE,PNODE,PGAUS)
            real :: res2b(DEF_VECT,PNODE,PNODE,PGAUS)
            logical :: b
            
            call random_number(t1)
            call random_number(t2)
            call random_number(t3)
            

            do igaus = 1,PGAUS
               do inode = 1,PNODE
                  res1b(:,inode,igaus) = t3(:,igaus) * t1(:,inode,igaus)
               end do
            end do
            
      !     Simplified
            do inode = 1,PNODE
               res1(:,inode,:) = t3(:,:) * t1(:,inode,:)
            end do
            
      !     Verification
            b = .true.
            do i = 1,DEF_VECT
               do igaus = 1,PGAUS
                  do inode = 1,PNODE
                     if (res1(i,inode,igaus) /= res1b(i,inode,igaus)) then
                        b = .false.
                     end if
                  end do
               end do
            end do
            
            if (b) then
               print *, "Ok"
            else
               print *, "Error"
            end if
            
      !     Original
            do igaus = 1,PGAUS
               do inode = 1,PNODE
                  do jnode = 1,PNODE
                     res2(:,inode,jnode,igaus) = t1(:,inode,igaus) * t1(:,jnode,igaus)
                  end do
               end do
            end do
            
      !     Simplified
            do inode = 1,PNODE
               do jnode = 1,PNODE
                  res2b(:,inode,jnode,:) = t1(:,inode,:) * t1(:,jnode,:)
               end do
            end do
            
            b = .true.
            
            do i = 1,DEF_VECT
               do igaus = 1,PGAUS
                  do inode = 1,PNODE
                     do jnode = 1,PNODE
                        if (res2(i,inode,jnode,igaus) /= res2b(i,inode,jnode,igaus)) then
                           b = .false.
                        end if
                     end do
                  end do
               end do
            end do
            
            if (b) then
               print *, "Ok"
            else
               print *, "Error"
            end if
            
            end program test        
    #+END_SRC

** BOAST
*** Expression
    #+BEGIN_SRC ruby 
      require 'BOAST'
      include BOAST

      p = Procedure("foo"){
        decl x = Int("x")
        exp = x === 1
        pr exp
      }
              
      k = p.ckernel
      k.build
    #+END_SRC

    #+RESULTS:
    : SUBROUTINE foo()
    :   integer, parameter :: wp=kind(1.0d0)
    :   integer(kind=4) :: x
    :   x = 1
    : END SUBROUTINE foo

*** Arrays
    #+BEGIN_SRC ruby 
      require 'BOAST'
      include BOAST

      set_lang(FORTRAN)
      p = Procedure("foo"){
        decl a = Real('a', :vector_length => 2, :dim => [Dim(10)])
        # decl a = Real('a', :dim => [Dim(10)])
        pr a[1,1..2] === 0.0
      }

      k = p.ckernel
      k.build
    #+END_SRC

    #+RESULTS:

*** Playing with vectors
**** Vectorization in fortran
    #+BEGIN_SRC ruby 
            require 'BOAST'
            include BOAST
            require 'narray'
            set_lang(FORTRAN)

            k1 = BOAST::CKernel::new
            k2 = BOAST::CKernel::new

            pgaus = Int("pgaus", :dir => :in)
            pnode = Int("pnode", :dir => :in)
            def_vect = Int("def_vect", :dir => :in)
            ndime = Int("ndime", :dir => :in)
            gpden = Real("gpden", :dir => :in, :dim => [Dim(def_vect),Dim(pgaus)])
            gpadv = Real("gpadv", :dir => :in, :dim => [Dim(def_vect),Dim(ndime),Dim(pgaus)])
            gpcar = Real("gpcar", :dir => :in, :dim => [Dim(def_vect),Dim(ndime),Dim(pnode),Dim(pgaus)])
            agrau1 = Real("agrau", :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])
            agrau2 = Real("agrau", :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])

            p1 = Procedure::new("foo",[pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau1])
            k1.code.print <<EOF
            subroutine foo(pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau)
              integer, parameter :: wp=kind(1.0d0)
              integer(kind=4), intent(in) :: pgaus
              integer(kind=4), intent(in) :: pnode
              integer(kind=4), intent(in) :: def_vect
              integer(kind=4), intent(in) :: ndime
              real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpden
              real(kind=8), intent(in), dimension(def_vect, ndime, pgaus) :: gpadv
              real(kind=8), intent(in), dimension(def_vect, ndime, pnode, pgaus) :: gpcar
              real(kind=8), intent(out), dimension(def_vect, pnode, pgaus) :: agrau
              integer(kind=4) :: igaus
              integer(kind=4) :: inode

              do igaus = 1,pgaus  
                do inode = 1,pnode
                            agrau(:,inode,igaus) =  gpden(:,igaus) * ( gpadv(:,1,igaus)*gpcar(:,1,inode,igaus) + gpadv(:,2,igaus)*gpcar(:,2,inode,igaus) )                      
                end do
               end do
            end subroutine foo
      EOF
            k1.procedure = p1


            p2 = Procedure::new("foo",[pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau2])
            k2.code.print <<EOF
            subroutine foo(pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau)
              integer, parameter :: wp=kind(1.0d0)
              integer(kind=4), intent(in) :: pgaus
              integer(kind=4), intent(in) :: pnode
              integer(kind=4), intent(in) :: def_vect
              integer(kind=4), intent(in) :: ndime
              real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpden
              real(kind=8), intent(in), dimension(def_vect, ndime, pgaus) :: gpadv
              real(kind=8), intent(in), dimension(def_vect, ndime, pnode, pgaus) :: gpcar
              real(kind=8), intent(out), dimension(def_vect, pnode, pgaus) :: agrau
              integer(kind=4) :: igaus
              integer(kind=4) :: inode

                do inode = 1,pnode
                            agrau(:,inode,:) =  gpden(:,:) * ( gpadv(:,1,:)*gpcar(:,1,inode,:) + gpadv(:,2,:)*gpcar(:,2,inode,:) )                      
                end do
            end subroutine foo
      EOF
            k2.procedure = p2

            stats1 = []
            stats2 = []

            checker = []

            pgaus = 20
            def_vect = 10
            pnode = 8
            ndime = 2
            
            10000.times{|i|
              gpden = NArray.float(def_vect, pgaus).random
              gpadv = NArray.float(def_vect, ndime, pgaus).random
              gpcar = NArray.float(def_vect, ndime, pnode, pgaus).random
              agrau1 = NArray.float(def_vect, pnode, pgaus)
              agrau2 = NArray.float(def_vect, pnode, pgaus)

              stats1[i] = k1.run(pgaus, pnode, def_vect, ndime, gpden, gpadv, gpcar, agrau1)
              stats2[i] = k2.run(pgaus, pnode, def_vect, ndime, gpden, gpadv, gpcar, agrau2)
              checker[i] = agrau1 == agrau2
            }
            
            t = []
            t[1] = stats1.inject(0){|sum,e| sum+e[:duration]} / stats1.length
            t[2] = stats2.inject(0){|sum,e| sum+e[:duration]} / stats2.length
            t
            
            # checker.include? false
    #+END_SRC

    #+RESULTS:
    | hline | 3.4143904999999938e-06 | 3.3715627999999837e-06 |
    
**** Trying using vectors
      This does not compile but the generated C code is correct.
     #+BEGIN_SRC ruby :tangle 
       require 'BOAST'
       include BOAST
       require 'narray'

       set_array_start(0)
       set_lang(C)
       #set_model(:sandybridge)

       vector_length = 4
       x = Int("x", :dir => :in)

       a = Int("a", :vector_length => vector_length, :dir => :in, :dim => [Dim(x)])
       b = Int("b", :vector_length => vector_length, :dir => :in, :dim => [Dim(x)])
       c = Int("c", :vector_length => vector_length, :dir => :out, :dim => [Dim(x)])


       p1 = Procedure("foo", [x,a,b,c]){
         decl i = Int("i")
         pr For(i,0,x){
           pr c[i] === a[i] + b[i]
         }
       }

       k1 = p1.ckernel

       # k1.build
     #+END_SRC

     #+RESULTS:
     : void foo(const int32_t x, const __m128i * a, const __m128i * b, __m128i * c){
     :   int32_t i;
     :   for (i = 0; i <= x; i += 1) {
     :     c[i] = _mm_add_epi32( a[i], b[i] );
     :   }
     : }

      Working vector c code:
      #+BEGIN_SRC C :tangle /tmp/vec2.c
        #include<stdio.h>
        #include<stdint.h>
        #include <emmintrin.h>

        #define SIZE 12
        #define VEC_LEN 4

        void foo(const int32_t x, const __m128i *a, const __m128i *b, __m128i * c){
            int i;
            for(i = 0; i < x; i++){
                c[i] = _mm_add_epi32( a[i], b[i] );
            }
        }

        void print128_num(__m128i *var, int32_t size)
        {
            int i;
            /* printf("Numerical:"); */
            for(i = 0; i < size; i++){
                uint32_t *val = (uint32_t*) &var[i];
                printf("%i %i %i %i ", 
                       val[0], val[1], val[2], val[3]);
            }
            printf("\n");
        }

        int main (int argc, char **argv){
            int32_t size = SIZE/VEC_LEN;
            int32_t t1[SIZE] = {1,2,3,4,5,6,7,8};
            int32_t t2[SIZE] = {8,7,6,5,4,3,2,1};

            int i;
            unsigned int seed1 = 3;
            unsigned int seed2 = 8;

            for(i = 0; i < SIZE; i++){
                t1[i] = rand_r(&seed1) % 10;
            }

            for(i = 0; i < SIZE; i++){
                t2[i] = rand_r(&seed2) % 10;
            }
            
            for(i = 0; i < SIZE; i++){
                printf("%d ", t1[i]);
            }
            printf("\n");

            for(i = 0; i < SIZE; i++){
                printf("%d ", t2[i]);
            }
            printf("\n");
            
            /* __m128i a = _mm_set_epi32(4, 3, 2, 1); */
            /* __m128i b = _mm_set_epi32(7, 6, 5, 4); */
            __m128i *a;
            __m128i *b;
            __m128i *c = malloc(sizeof(__m128i)*size);

            a = (__m128i*) t1;
            b = (__m128i*) t2;

            foo(size,a,b,c);

            print128_num(c, size);
            return 0;
        }
      #+END_SRC

      1D arrays:
     #+BEGIN_SRC ruby 
       require 'BOAST'
       include BOAST
       require 'narray'

       set_array_start(0)

       v_len = 1
       x = Int("x", :dir => :in)
       a = Int("a", :dir => :in, :dim => [Dim(x)])
       b = Int("b", :dir => :in, :dim => [Dim(x)])
       c = Int("c", :dir => :out, :dim => [Dim(x)])

       p1 = Procedure::new("foo", [x,a,b,c]){      
         decl i = Int("i")       
         if get_lang == CL or get_lang == CUDA then
           decl a1 = Int("a1", :vector_length => v_len)
           decl b1 = Int("b1", :vector_length => v_len)
           decl c1 = Int("c1", :vector_length => v_len)

           pr i === get_global_id(0) * v_len
           pr a1 === a[i]
           pr b1 === b[i]
           pr c1 === c[i]
           pr c1 === a1 + b1
           pr c[i] === c1
           
         else
           decl a1 = Int("a1", :vector_length => v_len, :dim => [Dim(x/v_len)], :allocate => true)
           decl b1 = Int("b1", :vector_length => v_len,  :dim => [Dim(x/v_len)], :allocate => true)
           decl c1 = Int("c1", :vector_length => v_len, :dim => [Dim(x/v_len)], :allocate => true)
           
           expr = [a1[i] === a[i*v_len], 
                   b1[i] === b[i*v_len],
                   c1[i] === c[i*v_len],
                   c1[i] === a1[i] + b1[i],
                   c[i*v_len] === c1[i]]

           pr For(i, 0, x/v_len-1){
             expr.each{|e| pr e}
           }
         end
       }

       set_lang(CL)
       k1 = p1.ckernel
       k1.build

       set_lang(C)
       k2 = CKernel::new
       BOAST::get_output.puts "#include <emmintrin.h>"             
       pr p1
       k2.procedure = p1
       k2.build

       x = 512
       NArray.srand(10)
       a = NArray.int(x).random!(x)
       b = NArray.int(x).random!(x)
       c1 = NArray.int(x)
       c2 = NArray.int(x)

       k1.run(x,a,b,c1,:global_work_size => [512,1,1], :local_work_size => [128, 1, 1])
       k2.run(x,a,b,c2,:global_work_size => [128,1,1], :local_work_size => [128, 1, 1])
       c1 == c2
  
     #+END_SRC

     #+RESULTS:
     : true

      2D arrays:
     #+BEGIN_SRC ruby :tangle /tmp/vec2D.rb
       require 'BOAST'
       include BOAST
       require 'narray'

       set_array_start(0)

       v_len = 4
       x = Int("x", :dir => :in)
       a = Int("a", :dir => :in, :dim => [Dim(x),Dim(x)])
       b = Int("b", :dir => :in, :dim => [Dim(x),Dim(x)])
       c = Int("c", :dir => :out, :dim => [Dim(x),Dim(x)])

       p1 = Procedure::new("foo", [x,a,b,c]){      
         decl i = Int("i")       
         decl j = Int("j")       
         if get_lang == CL or get_lang == CUDA then
           decl a1 = Int("a1", :vector_length => v_len)
           decl b1 = Int("b1", :vector_length => v_len)
           decl c1 = Int("c1", :vector_length => v_len)

           pr i === get_global_id(0) * v_len
           pr j === get_global_id(1)
           pr a1 === a[i,j]
           pr b1 === b[i,j]
           pr c1 === a1 + b1
           pr c[i,j] === c1           
         else
           decl a1 = Int("a1", :vector_length => v_len, :dim => [Dim(x/v_len),Dim(x)], :allocate => true)
           decl b1 = Int("b1", :vector_length => v_len, :dim => [Dim(x/v_len),Dim(x)], :allocate => true)
           decl c1 = Int("c1", :vector_length => v_len, :dim => [Dim(x/v_len),Dim(x)], :allocate => true)
           
           pr For(j, 0, x-1){
             pr For(i, 0, x/v_len-1){
               pr a1[i,j] === a[i*v_len,j]
               pr b1[i,j] === b[i*v_len,j]
               pr c1[i,j] === c[i*v_len,j]
               pr c1[i,j] === a1[i,j] + b1[i,j]
               pr c[i*v_len,j] === c1[i,j]
             }
           }
         end
       }

       set_lang(CL)
       k1 = p1.ckernel
       k1.build

       set_lang(C)
       k2 = CKernel::new
       BOAST::get_output.puts "#include <emmintrin.h>"             
       pr p1
       k2.procedure = p1
       k2.build

       x = 512
       NArray.srand(10)
       a = NArray.int(x,x).random!(10)
       b = NArray.int(x,x).random!(10)
       c1 = NArray.int(x,x)
       c2 = NArray.int(x,x)

       k1.run(x,a,b,c1,:global_work_size => [128,512,1], :local_work_size => [128, 1, 1])
       k2.run(x,a,b,c2,:global_work_size => [1024,8,1], :local_work_size => [128, 1, 1])
       c1 == c2
     #+END_SRC

     #+RESULTS:
     #+begin_example
     #include <emmintrin.h>
     void foo(const int32_t x, const int32_t * a, const int32_t * b, int32_t * c){
       int32_t i;
       int32_t j;
       __m128i a1[(x)*((x) / (4))];
       __m128i b1[(x)*((x) / (4))];
       __m128i c1[(x)*((x) / (4))];
       for (j = 0; j <= x - (1); j += 1) {
         for (i = 0; i <= (x) / (4) - (1); i += 1) {
           a1[i + ((x) / (4)) * (j)] = _mm_loadu_si128( &a[(i) * (4) + (x) * (j)] );
           b1[i + ((x) / (4)) * (j)] = _mm_loadu_si128( &b[(i) * (4) + (x) * (j)] );
           c1[i + ((x) / (4)) * (j)] = _mm_loadu_si128( &c[(i) * (4) + (x) * (j)] );
           c1[i + ((x) / (4)) * (j)] = _mm_add_epi32( a1[i + ((x) / (4)) * (j)], b1[i + ((x) / (4)) * (j)] );
           _mm_storeu_si128( (__m128i * ) &c[(i) * (4) + (x) * (j)], c1[i + ((x) / (4)) * (j)] );
         }
       }
     }
#+end_example

     #+BEGIN_SRC ruby :tangle /tmp/vec2D.rb
       require 'BOAST'
       include BOAST
       require 'narray'

       set_array_start(0)

       v_len = 4
       x = Int("x", :dir => :in)
       a = Int("a", :dir => :in, :dim => [Dim(x),Dim(x)])

       p = Procedure::new("foo", [x,a]){      
         decl a1 = Int("a1", :vector_length => v_len, :dim => [Dim(x/v_len),Dim(x)], :allocate => true)         
         pr a1 === a
       }

       set_lang(FORTRAN)
       k = CKernel::new
       if get_lang == C then
         BOAST::get_output.puts "#include <emmintrin.h>"             
       end
       pr p
       k.procedure = p
       k.build

       x = 512
       NArray.srand(10)
       a = NArray.int(x,x).random!(10)

       k.run(x,a)
       k
     #+END_SRC

     #+RESULTS:
****** Verifying vectors
       #+BEGIN_SRC ruby
         require 'BOAST'
         include BOAST
         require 'narray'

         v_len = 2
         x = Int("x", :dir => :in)
         a = Real("a", :dir => :in, :dim => [Dim(v_len),Dim(x)])
         b = Real("b", :dir => :in, :dim => [Dim(v_len),Dim(x)])
         c = Real("c", :dir => :out, :dim => [Dim(v_len),Dim(x)])

         p1 = Procedure::new("foo", [x,a,b,c]){      
           decl i = Int("i")       
           decl a1 = Real("a1", :vector_length => v_len)
           decl b1 = Real("b1", :vector_length => v_len)
           decl c1 = Real("c1", :vector_length => v_len)
           
           pr For(i,1,x){
             pr a1 === a[1,i]
             pr b1 === b[1,i]
             pr c1 === a1 + b1
             pr c[1,i] === c1
           }
         }

         p2 = Procedure::new("bar", [x,a,b,c]){      
           decl i = Int("i")       
           decl j = Int("j")       

           pr For(i,1,x){
             pr For(j,1,v_len){
               pr c[j,i] === a[j,i] + b[j,i]
             }
           }
         }

         set_lang(FORTRAN)
         k1 = CKernel::new
         BOAST::get_output.puts "#include <emmintrin.h>"             
         pr p1
         k1.procedure = p1
         k1.build

         set_lang(C)
         k2 = p2.ckernel

         x = 8
         NArray.srand(10)
         a = NArray.float(v_len,x).random(x)
         b = NArray.float(v_len,x).random(x)
         c1 = NArray.float(v_len,x)
         c2 = NArray.float(v_len,x)

         k1.run(x,a,b,c1)
         k2.run(x,a,b,c2)
         c1 == c2

       #+END_SRC

       #+RESULTS:
       : true

****** Vectorizing first loop
     #+BEGIN_SRC ruby
       require 'BOAST'
       include BOAST
       require 'narray'
       set_lang(FORTRAN)

       pgaus = Int("pgaus", :dir => :in)
       pnode = Int("pnode", :dir => :in)
       def_vect = Int("def_vect", :dir => :in)
       ndime = Int("ndime", :dir => :in)
       gpden = Real("gpden", :vector_length => 2, :dir => :in, :dim => [Dim(def_vect),Dim(pgaus)])
       gpadv = Real("gpadv", :vector_length => 2, :dir => :in, :dim => [Dim(def_vect),Dim(ndime),Dim(pgaus)])
       gpcar = Real("gpcar", :vector_length => 2, :dir => :in, :dim => [Dim(def_vect),Dim(ndime),Dim(pnode),Dim(pgaus)])
       agrau = Real("agrau", :vector_length => 2, :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])


       p1 = Procedure::new("foo",[pgaus,pnode,def_vect,ndime,gpden,gpadv,gpcar,agrau]){
         decl igaus = Int("igaus")
         decl inode = Int("inode")
         pr For(igaus,1,pgaus){
           pr For(inode,1,pnode){

           }
         }
       }
       k1 = p1.ckernel

     #+END_SRC

     #+RESULTS:
     #+begin_example
     SUBROUTINE foo(pgaus, pnode, def_vect, ndime, gpden, gpadv, gpcar, agr&
     &au)
       integer, parameter :: wp=kind(1.0d0)
       integer(kind=4), intent(in) :: pgaus
       integer(kind=4), intent(in) :: pnode
       integer(kind=4), intent(in) :: def_vect
       integer(kind=4), intent(in) :: ndime
       real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpden
       real(kind=8), intent(in), dimension(def_vect, ndime, pgaus) :: gpadv
       real(kind=8), intent(in), dimension(def_vect, ndime, pnode, pgaus) :&
     &: gpcar
       real(kind=8), intent(out), dimension(def_vect, pnode, pgaus) :: agra&
     &u
     END SUBROUTINE foo
#+end_example

**** Generic 
       #+BEGIN_SRC ruby
         require 'BOAST'
         include BOAST

         pgaus = Int("pgaus", :dir => :in)
         pnode = Int("pnode", :dir => :in)
         def_vect = Int("def_vect", :dir => :in)
         gpden = Real("gpden", :dir => :in, :dim => [Dim(def_vect),Dim(pgaus)])
         gpadv = Real("gpadv", :dir => :in, :dim => [Dim(def_vect),Dim(pgaus)])
         gpcar = Real("gpcar", :dir => :in, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])
         agrau = Real("agrau", :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pgaus)])
         wgrgr = Real("wgrgr", :dir => :out, :dim => [Dim(def_vect),Dim(pnode),Dim(pnode),Dim(pgaus)])

         orig1 = Procedure("orig1", [pgaus,pnode,def_vect,gpden,gpadv,agrau,wgrgr]){
           decl igaus = Int("igaus")
           decl inode = Int("inode")

           pr For(igaus,1,pgaus){
             pr For(inode,1,pnode){
# pr agrau[1..def_vect,inode,igaus]
               # pr agrau[1..def_vect,inode,igaus] === gpden[1..def_vect,igaus] * ( 
               #                                       gpadv[1..def_vect,igaus]*gpcar[1..def_vect,inode,igaus])
             }
           }
         }

         k = orig1.ckernel
         k

       #+END_SRC

       #+RESULTS:
=SUBROUTINE orig1(pgaus, pnode, def_vect, gpden, gpadv, agrau, wgrgr)
  integer, parameter :: wp=kind(1.0d0)
  integer(kind=4), intent(in) :: pgaus
  integer(kind=4), intent(in) :: pnode
  integer(kind=4), intent(in) :: def_vect
  real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpden
  real(kind=8), intent(in), dimension(def_vect, pgaus) :: gpadv
  real(kind=8), intent(out), dimension(def_vect, pnode, pgaus) :: agra&
&u
  real(kind=8), intent(out), dimension(def_vect, pnode, pnode, pgaus) &
&:: wgrgr
  integer(kind=4) :: igaus
  integer(kind=4) :: inode
  do igaus = 1, pgaus, 1
    do inode = 1, pnode, 1
    end do
  end do
END SUBROUTINE orig1
*** Vector addition: Loop vs vectorization
       Code not portable, vector style works only in Fortran.
       #+BEGIN_SRC ruby
         require 'BOAST'
         include BOAST

         s = Int("s")
         a = Real("a", :dir => :in, :dim => [Dim(s)])
         b = Real("b", :dir => :in, :dim => [Dim(s)])
         c = Real("c", :dir => :out, :dim => [Dim(s)])

         p1 = Procedure("p1", [s,a,b,c]){
           decl i = Int("i")
           pr For(i,0,s){
             pr c[i] === a[i] + b[i]
           }
         }

         p2 = Procedure("p2", [s,a,b,c]){
           pr  c === a + b
         }


         set_array_start(0)
         set_lang(FORTRAN)
         k1 = p1.ckernel
         k2 = p2.ckernel
         BOAST::verbose = true
         # k1.build(:FCFLAGS => "-ftree-vectorize")
         # k1.build(:FCFLAGS => "-O3")


         stats1 = []
         stats2 = []

         s = 128

         1000.times{ |i|

           a = NArray.float(s).random
           b = NArray.float(s).random
           c = NArray.float(s)

           stats1[i] = k1.run(s, a, b, c, :global_work_size => [1024,1024,1], :local_work_size => [32, 32, 1])
           stats2[i] = k2.run(s, a, b, c, :global_work_size => [1024,1024,1], :local_work_size => [32, 32, 1])

         }

         t = []
         t[1] = stats1.inject(0){|sum,e| sum+e[:duration]} / stats1.length
         t[2] = stats2.inject(0){|sum,e| sum+e[:duration]} / stats2.length

         k1
       #+END_SRC

       #+RESULTS:
       #+begin_example
       SUBROUTINE p1(s, a, b, c)
         integer, parameter :: wp=kind(1.0d0)
         integer(kind=4) :: s
         real(kind=8), intent(in), dimension(0:s - (1)) :: a
         real(kind=8), intent(in), dimension(0:s - (1)) :: b
         real(kind=8), intent(out), dimension(0:s - (1)) :: c
         integer(kind=4) :: i
         do i = 0, s, 1
           c(i) = a(i) + b(i)
         end do
       END SUBROUTINE p1
#+end_example
       
*** Unrolling
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      # set_array_start(0)
      a = Int("a",:dir => :out, :dim => [Dim(10)]) 

      p1 = Procedure::new("p1",[a]){
        i = Int("i")
        for1 = For(i,1,10){
          pr a[i] === a[i] + i
        }
        pr for1.unroll
      }
      set_lang(C)
      k = p1.ckernel

      a = NArray.int(10).random!(20)
      k.run(a)
      k
    #+END_SRC

    #+RESULTS:
    #+begin_example
    void p1(int32_t * a){
      a[1 - (1)] = a[1 - (1)] + 1;
      a[2 - (1)] = a[2 - (1)] + 2;
      a[3 - (1)] = a[3 - (1)] + 3;
      a[4 - (1)] = a[4 - (1)] + 4;
      a[5 - (1)] = a[5 - (1)] + 5;
      a[6 - (1)] = a[6 - (1)] + 6;
      a[7 - (1)] = a[7 - (1)] + 7;
      a[8 - (1)] = a[8 - (1)] + 8;
      a[9 - (1)] = a[9 - (1)] + 9;
      a[10 - (1)] = a[10 - (1)] + 10;
    }
#+end_example

*** Copying external function
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST

      body = <<EOF
      subroutine foo(x,y) 
        integer, intent(in) :: x(10)
        integer, intent(out) :: y(10)
        y = 2*x
      end subroutine foo
      EOF

      x = Int("x", :dir => :in, :dim => [Dim(10)])
      y = Int("y", :dir => :out, :dim => [Dim(10)])
      p = Procedure::new("foo", [x,y])
      k = CKernel::new
      k.procedure = p
      get_output.print body
      k.build
      x = NArray.int(10).random!(20)
      y = NArray.int(10)
      k.run(x,y)
      y
    #+END_SRC

    #+RESULTS:
    : NArray.int(10): 
    : [ 22, 16, 36, 22, 12, 8, 22, 22, 10, 28 ]

*** Calling a function
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      x = Int("x", :dir => :in)               
      y = Int("y")               
      a = Int("a", :dir => :inout, :dim => [Dim(x)])                

      p1 = Procedure("p1", [x],:return => y){
          pr y === 1
      }

      set_lang(FORTRAN)
      k1 = CKernel::new
      k1.procedure = p1

      k1.build
      k2 = CKernel::new(:kernels =>[k1])
      p2 = Procedure("p2",[x,a]){
        decl i = Int("i")
        pr For(i,1,x){
          pr a[i] === a[i] + k1.procedure.call(x)        
        }
      }

      pr p1
      pr p2
      k2.procedure = p2
           
      x = 10
      a = NArray.int(x)
      puts k2
      k2.build
      k2.run(x,a)
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      x = Int("x", :dir => :in)               
      y = Int("y")               
      a = Int("a", :dir => :inout, :dim => [Dim(x)])                

      p1 = Procedure("p1", [x],:return => y){
        pr y === 1
      }

      set_lang(FORTRAN)
      k1 = CKernel::new
      k1.procedure = p1

      k1.build
      k2 = CKernel::new
      p2 = Procedure("p2",[x,a],:functions => [p1]){
        decl i = Int("i")
        pr For(i,1,x){
          pr a[i] === a[i] + k1.procedure.call(x)        
        }
      }

      pr p1
      pr p2
      k2.procedure = p2

      x = 10
      a = NArray.int(x)
      puts k2
      k2.build
      k2.run(x,a)

    #+END_SRC

    #+RESULTS:
    | :duration=>1.037e-06 |

*** Modular loops
    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      decl a = Int("a", :dir => :inout, :dim => [Dim(4)])

      p = Procedure("foo",[a]){
        decl i = Int("i")
        decl j = Int("j")
        decl b = Int("b")

        f1 = For(i,1,3)
        f2 = For(j,1,4)
        pr b === 0

        opn f2
          opn f1
            pr b === b + 1
            pr a[j] === b
          close f1
        close f2
      }

      k = p.ckernel
      k.build
      a = NArray.int(4)
      k.run(a)
      a
                
    #+END_SRC

    #+RESULTS:
    : NArray.int(4): 
    : [ 3, 6, 9, 12 ]

    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      decl a = Int("a", :dir => :inout, :dim => [Dim(4)])

      p = Procedure("foo",[a]){
        decl i = Int("i")
        decl j = Int("j")
        decl b = Int("b")

        (2..3).each{|dim|
        f1 = For(i,1,3)
        f2 = For(j,1,dim)
        block = lambda {
            pr b === b + 1
            pr a[j] === b
        }

        pr b === 0
       
        f4 = lambda{ pr f2.unroll, &block}

        lambda{ pr f1, &f4}.call
        }
      }

      k = p.ckernel
      k.build
      a = NArray.int(4)
      # k.run(a)
      # a
      k
                
    #+END_SRC

    #+RESULTS:
    #+begin_example
    SUBROUTINE foo(a)
      integer, parameter :: wp=kind(1.0d0)
      integer(kind=4), intent(inout), dimension(4) :: a
      integer(kind=4) :: i
      integer(kind=4) :: j
      integer(kind=4) :: b
      b = 0
      do i = 1, 3, 1
        b = b + 1
        a(1) = b
        b = b + 1
        a(2) = b
      end do
      b = 0
      do i = 1, 3, 1
        b = b + 1
        a(1) = b
        b = b + 1
        a(2) = b
        b = b + 1
        a(3) = b
      end do
    END SUBROUTINE foo
#+end_example

    #+BEGIN_SRC ruby
      require 'BOAST'
      include BOAST
      require 'narray'

      p = Procedure("foo"){
        decl inode = Int("inode")
        decl jnode = Int("jnode")
        decl idime = Int("idime")
        decl jdime = Int("jdime")
        decl igaus = Int("igaus")
        decl idofv = Int("idofv")
        decl jdofv = Int("jdofv")

        decl pnode = Int("pnode")
        decl ndime = Int("ndime")
        decl pgaus = Int("pgaus")
        decl gpvis = Int("gpvis", :dim => [Dim(1),Dim(5)])
        decl gpvol = Int("gpvol", :dim => [Dim(1),Dim(5)])
        decl gpcar = Int("gpcar", :dim => [Dim(1),Dim(3),Dim(5)])
        decl elauu = Int("elauu", :dim => [Dim(1),Dim(5),Dim(5)])
        decl fact1 = Int("fact1")
        
        for_inode = For(inode,1,pnode)
        for_jnode = For(jnode,1,pnode)
        for_idime = For(idime,1,ndime)

        for_jdime = lambda{|dim|
          return For(jdime,1,dim)
        }

        block1 = lambda{
          pr fact1 === gpvis[1,igaus] * gpvol[1,igaus] * gpcar[1,idime,jnode,igaus]
        }

        block2 = lambda{
          pr idofv === (inode-1)*ndime + idime
        }

        block3 = lambda{
          # pr jdofv === (jnode-1)*ndime + jdime
          pr jdofv === ndime + jdime
          # pr elauu[1,idofv,jdofv] === elauu[1,idofv,jdofv] * fact1 * gpcar[1,idime,inode,igaus]
        }

        dim = 3

        pr For(igaus,1,pgaus){ 
          opn for_inode
          opn for_idime
          # block2.call
          opn for_jnode
          block1.call
          lambda{ pr for_jdime.call(dim).unroll, &block3 }.call
          close for_jnode
          close for_idime
          close for_inode
        }
        
      }
      k = p.ckernel
    #+END_SRC

    #+RESULTS:
    #+begin_example
    SUBROUTINE foo()
      integer, parameter :: wp=kind(1.0d0)
      integer(kind=4) :: inode
      integer(kind=4) :: jnode
      integer(kind=4) :: idime
      integer(kind=4) :: jdime
      integer(kind=4) :: igaus
      integer(kind=4) :: idofv
      integer(kind=4) :: jdofv
      integer(kind=4) :: pnode
      integer(kind=4) :: ndime
      integer(kind=4) :: pgaus
      integer(kind=4), dimension(1, 5) :: gpvis
      integer(kind=4), dimension(1, 5) :: gpvol
      integer(kind=4), dimension(1, 3, 5) :: gpcar
      integer(kind=4), dimension(1, 5, 5) :: elauu
      integer(kind=4) :: fact1
      do igaus = 1, pgaus, 1
        do inode = 1, pnode, 1
          do idime = 1, ndime, 1
            do jnode = 1, pnode, 1
              fact1 = ((gpvis(1, igaus)) * (gpvol(1, igaus))) * (gpcar(1, &
    &idime, jnode))
              jdofv = ndime + 1
              jdofv = ndime + 2
              jdofv = ndime + 3
            end do
          end do
        end do
      end do
    END SUBROUTINE foo
#+end_example

** Ruby
*** Meta
**** Eval string of string 
    This one would be good but it does not work, it fails to find the
    variable i:
    #+BEGIN_SRC ruby 
      exp1 = ""
      code=<<EOF
        dim = 3
        dim.times{|i|
          exp1 += "v_gpadv[#{i+1}]"
          exp1 +=  " + " if i+1 < dim
        }
      EOF
      eval code
      exp1
    #+END_SRC

    #+RESULTS:

     This solution works but is a little bit ugly, it is more
     difficult to read the expression:
    #+BEGIN_SRC ruby 
      exp1 = ""
      code=<<EOF
        dim = 3
        dim.times{|i|
          exp1 += "v_gpadv[" + (i+1).to_s + "]"
          exp1 +=  " + " if i+1 < dim
        }
      EOF
      eval code
      exp1
    #+END_SRC

    #+RESULTS:

     This one is better, we can still read the expression and it is
     concise:
     #+BEGIN_SRC ruby 
      exp1 = ""
      code=<<EOF
        dim = 3
        dim.times{|i|
          exp1 += sprintf("v_gpadv[%d]", i)
          exp1 +=  " + " if i+1 < dim
        }
      EOF
      eval code
      exp1     
     #+END_SRC

     #+RESULTS:
     : v_gpadv[0] + v_gpadv[1] + v_gpadv[2]

     #+BEGIN_SRC ruby 
     a = "a_1"
     b = "b_1"
     a_1 = [1,2,3]
     b_1 = [4,5,6]
     i = 2
     exp = "#{a_1}[#{i}] + #{b_1}[#{i}]"
     eval exp
     #+END_SRC

     #+RESULTS:
     : 9

**** Generate array of blocks
     - Array of a block
       #+BEGIN_SRC ruby
         exp1 = ["",""]
         x = []
         2.times{|j|
           x[j] = Proc.new{
             dim = j+2
             dim.times{|i|
               exp1[j] += "v_gpadv[" + (i+1).to_s + "]*v_gpcar[" + (i+1).to_s + "]"
               exp1[j] +=  " + " if i+1 < dim
             }
           }
         }
         x[0].call
         x[1].call
         exp1
       #+END_SRC

       #+RESULTS:
     | v_gpadv[1]*v_gpcar[1] + v_gpadv[2]*v_gpcar[2] | v_gpadv[1]*v_gpcar[1] + v_gpadv[2]*v_gpcar[2] + v_gpadv[3]*v_gpcar[3] |

     - Array of For:
       #+BEGIN_SRC ruby 
         require 'BOAST'
         include BOAST

         x = Int("x", :dir => :in)
         a = Int("a", :dir => :in, :dim => [Dim(x)])
         b = Int("b", :dir => :in, :dim => [Dim(x)])
         c = Int("c", :dir => :in, :dim => [Dim(x)])

         p = Procedure("foo",[x,a,b,c]){         
           decl i = Int("i")
           for1 = []
           3.times{|j|
             for1[j] =  For(i,0,x){
               pr c[i] === a[i] * j  + b[i] * j
             }
           }
           pr for1[1]
           pr for1[2]
         }
         k = p.ckernel
       #+END_SRC

       #+RESULTS:
       #+begin_example
       SUBROUTINE foo(x, a, b, c)
         integer, parameter :: wp=kind(1.0d0)
         integer(kind=4), intent(in) :: x
         integer(kind=4), intent(in), dimension(x) :: a
         integer(kind=4), intent(in), dimension(x) :: b
         integer(kind=4), intent(in), dimension(x) :: c
         integer(kind=4) :: i
         do i = 0, x, 1
           c(i) = (a(i)) * (1) + (b(i)) * (1)
         end do
         do i = 0, x, 1
           c(i) = (a(i)) * (2) + (b(i)) * (2)
         end do
       END SUBROUTINE foo
#+end_example

     
